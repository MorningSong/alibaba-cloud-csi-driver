// This file is auto-generated, don't edit it. Thanks.
package client

import (
	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	openapiutil "github.com/alibabacloud-go/darabonba-openapi/v2/utils"
	"github.com/alibabacloud-go/tea/dara"
)

type iAddClientToBlackListRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientIP(v string) *AddClientToBlackListRequest
	GetClientIP() *string
	SetClientToken(v string) *AddClientToBlackListRequest
	GetClientToken() *string
	SetFileSystemId(v string) *AddClientToBlackListRequest
	GetFileSystemId() *string
	SetRegionId(v string) *AddClientToBlackListRequest
	GetRegionId() *string
}

type AddClientToBlackListRequest struct {
	// The IP address of the client to add.
	//
	// This parameter is required.
	//
	// example:
	//
	// 192.168.0.0
	ClientIP *string `json:"ClientIP,omitempty" xml:"ClientIP,omitempty"`
	// This parameter ensures the idempotency of each request. A ClientToken is generated for each client. Make sure that each ClientToken is unique between different requests. The parameter can be a maximum of 64 characters in length and contain ASCII characters.
	//
	// For more information, see [How to ensure idempotence](https://www.alibabacloud.com/help/doc-detail/25693.htm).
	//
	// This parameter is required.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-426655440000
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1ca404a348
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The ID of the region where the file system resides.
	//
	// This parameter is required.
	//
	// example:
	//
	// cn-hangzhou
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s AddClientToBlackListRequest) String() string {
	return dara.Prettify(s)
}

func (s AddClientToBlackListRequest) GoString() string {
	return s.String()
}

func (s *AddClientToBlackListRequest) GetClientIP() *string {
	return s.ClientIP
}

func (s *AddClientToBlackListRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *AddClientToBlackListRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *AddClientToBlackListRequest) GetRegionId() *string {
	return s.RegionId
}

func (s *AddClientToBlackListRequest) SetClientIP(v string) *AddClientToBlackListRequest {
	s.ClientIP = &v
	return s
}

func (s *AddClientToBlackListRequest) SetClientToken(v string) *AddClientToBlackListRequest {
	s.ClientToken = &v
	return s
}

func (s *AddClientToBlackListRequest) SetFileSystemId(v string) *AddClientToBlackListRequest {
	s.FileSystemId = &v
	return s
}

func (s *AddClientToBlackListRequest) SetRegionId(v string) *AddClientToBlackListRequest {
	s.RegionId = &v
	return s
}

func (s *AddClientToBlackListRequest) Validate() error {
	return dara.Validate(s)
}

type iAddClientToBlackListResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *AddClientToBlackListResponseBody
	GetRequestId() *string
}

type AddClientToBlackListResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// A70BEE5D-76D3-49FB-B58F-1F398211A5C3
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddClientToBlackListResponseBody) String() string {
	return dara.Prettify(s)
}

func (s AddClientToBlackListResponseBody) GoString() string {
	return s.String()
}

func (s *AddClientToBlackListResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *AddClientToBlackListResponseBody) SetRequestId(v string) *AddClientToBlackListResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddClientToBlackListResponseBody) Validate() error {
	return dara.Validate(s)
}

type iAddClientToBlackListResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *AddClientToBlackListResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *AddClientToBlackListResponse
	GetStatusCode() *int32
	SetBody(v *AddClientToBlackListResponseBody) *AddClientToBlackListResponse
	GetBody() *AddClientToBlackListResponseBody
}

type AddClientToBlackListResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AddClientToBlackListResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AddClientToBlackListResponse) String() string {
	return dara.Prettify(s)
}

func (s AddClientToBlackListResponse) GoString() string {
	return s.String()
}

func (s *AddClientToBlackListResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *AddClientToBlackListResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *AddClientToBlackListResponse) GetBody() *AddClientToBlackListResponseBody {
	return s.Body
}

func (s *AddClientToBlackListResponse) SetHeaders(v map[string]*string) *AddClientToBlackListResponse {
	s.Headers = v
	return s
}

func (s *AddClientToBlackListResponse) SetStatusCode(v int32) *AddClientToBlackListResponse {
	s.StatusCode = &v
	return s
}

func (s *AddClientToBlackListResponse) SetBody(v *AddClientToBlackListResponseBody) *AddClientToBlackListResponse {
	s.Body = v
	return s
}

func (s *AddClientToBlackListResponse) Validate() error {
	return dara.Validate(s)
}

type iApplyAutoSnapshotPolicyRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAutoSnapshotPolicyId(v string) *ApplyAutoSnapshotPolicyRequest
	GetAutoSnapshotPolicyId() *string
	SetFileSystemIds(v string) *ApplyAutoSnapshotPolicyRequest
	GetFileSystemIds() *string
}

type ApplyAutoSnapshotPolicyRequest struct {
	// The ID of the automatic snapshot policy.
	//
	// This parameter is required.
	//
	// example:
	//
	// sp-extreme-233e6****
	AutoSnapshotPolicyId *string `json:"AutoSnapshotPolicyId,omitempty" xml:"AutoSnapshotPolicyId,omitempty"`
	// The IDs of advanced Extreme NAS file systems.
	//
	// You can specify a maximum of 100 file system IDs at a time. If you want to apply an automatic snapshot policy to multiple file systems, separate the file system IDs with commas (,).
	//
	// This parameter is required.
	//
	// example:
	//
	// extreme-233e6****,extreme -23vbp****,extreme -23vas****
	FileSystemIds *string `json:"FileSystemIds,omitempty" xml:"FileSystemIds,omitempty"`
}

func (s ApplyAutoSnapshotPolicyRequest) String() string {
	return dara.Prettify(s)
}

func (s ApplyAutoSnapshotPolicyRequest) GoString() string {
	return s.String()
}

func (s *ApplyAutoSnapshotPolicyRequest) GetAutoSnapshotPolicyId() *string {
	return s.AutoSnapshotPolicyId
}

func (s *ApplyAutoSnapshotPolicyRequest) GetFileSystemIds() *string {
	return s.FileSystemIds
}

func (s *ApplyAutoSnapshotPolicyRequest) SetAutoSnapshotPolicyId(v string) *ApplyAutoSnapshotPolicyRequest {
	s.AutoSnapshotPolicyId = &v
	return s
}

func (s *ApplyAutoSnapshotPolicyRequest) SetFileSystemIds(v string) *ApplyAutoSnapshotPolicyRequest {
	s.FileSystemIds = &v
	return s
}

func (s *ApplyAutoSnapshotPolicyRequest) Validate() error {
	return dara.Validate(s)
}

type iApplyAutoSnapshotPolicyResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *ApplyAutoSnapshotPolicyResponseBody
	GetRequestId() *string
}

type ApplyAutoSnapshotPolicyResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 473469C7-AA6F-4DC5-B3DB-A3DC0DE3****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ApplyAutoSnapshotPolicyResponseBody) String() string {
	return dara.Prettify(s)
}

func (s ApplyAutoSnapshotPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *ApplyAutoSnapshotPolicyResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *ApplyAutoSnapshotPolicyResponseBody) SetRequestId(v string) *ApplyAutoSnapshotPolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *ApplyAutoSnapshotPolicyResponseBody) Validate() error {
	return dara.Validate(s)
}

type iApplyAutoSnapshotPolicyResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *ApplyAutoSnapshotPolicyResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *ApplyAutoSnapshotPolicyResponse
	GetStatusCode() *int32
	SetBody(v *ApplyAutoSnapshotPolicyResponseBody) *ApplyAutoSnapshotPolicyResponse
	GetBody() *ApplyAutoSnapshotPolicyResponseBody
}

type ApplyAutoSnapshotPolicyResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ApplyAutoSnapshotPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ApplyAutoSnapshotPolicyResponse) String() string {
	return dara.Prettify(s)
}

func (s ApplyAutoSnapshotPolicyResponse) GoString() string {
	return s.String()
}

func (s *ApplyAutoSnapshotPolicyResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *ApplyAutoSnapshotPolicyResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *ApplyAutoSnapshotPolicyResponse) GetBody() *ApplyAutoSnapshotPolicyResponseBody {
	return s.Body
}

func (s *ApplyAutoSnapshotPolicyResponse) SetHeaders(v map[string]*string) *ApplyAutoSnapshotPolicyResponse {
	s.Headers = v
	return s
}

func (s *ApplyAutoSnapshotPolicyResponse) SetStatusCode(v int32) *ApplyAutoSnapshotPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *ApplyAutoSnapshotPolicyResponse) SetBody(v *ApplyAutoSnapshotPolicyResponseBody) *ApplyAutoSnapshotPolicyResponse {
	s.Body = v
	return s
}

func (s *ApplyAutoSnapshotPolicyResponse) Validate() error {
	return dara.Validate(s)
}

type iApplyDataFlowAutoRefreshRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAutoRefreshInterval(v int64) *ApplyDataFlowAutoRefreshRequest
	GetAutoRefreshInterval() *int64
	SetAutoRefreshPolicy(v string) *ApplyDataFlowAutoRefreshRequest
	GetAutoRefreshPolicy() *string
	SetAutoRefreshs(v []*ApplyDataFlowAutoRefreshRequestAutoRefreshs) *ApplyDataFlowAutoRefreshRequest
	GetAutoRefreshs() []*ApplyDataFlowAutoRefreshRequestAutoRefreshs
	SetClientToken(v string) *ApplyDataFlowAutoRefreshRequest
	GetClientToken() *string
	SetDataFlowId(v string) *ApplyDataFlowAutoRefreshRequest
	GetDataFlowId() *string
	SetDryRun(v bool) *ApplyDataFlowAutoRefreshRequest
	GetDryRun() *bool
	SetFileSystemId(v string) *ApplyDataFlowAutoRefreshRequest
	GetFileSystemId() *string
}

type ApplyDataFlowAutoRefreshRequest struct {
	// The automatic update interval. CPFS checks whether data is updated in the directory at the interval specified by this parameter. If data is updated, CPFS starts an automatic update task. Unit: minutes.
	//
	// Valid values: 5 to 526600. Default value: 10.
	//
	// example:
	//
	// 10
	AutoRefreshInterval *int64 `json:"AutoRefreshInterval,omitempty" xml:"AutoRefreshInterval,omitempty"`
	// The automatic update policy. The updated data in the source storage is imported into the CPFS file system based on the policy. Valid values:
	//
	// 	- None (default): Updated data in the source storage is not automatically imported into the CPFS file system. You can run a dataflow task to import the updated data from the source storage.
	//
	// 	- ImportChanged: Updated data in the source storage is automatically imported into the CPFS file system.
	//
	// example:
	//
	// None
	AutoRefreshPolicy *string `json:"AutoRefreshPolicy,omitempty" xml:"AutoRefreshPolicy,omitempty"`
	// The automatic update configurations.
	//
	// This parameter is required.
	AutoRefreshs []*ApplyDataFlowAutoRefreshRequestAutoRefreshs `json:"AutoRefreshs,omitempty" xml:"AutoRefreshs,omitempty" type:"Repeated"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// >  If you do not specify this parameter, the system automatically uses the request ID as the client token. The value of RequestId may be different for each API request.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-42665544****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The dataflow ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// df-194433a5be31****
	DataFlowId *string `json:"DataFlowId,omitempty" xml:"DataFlowId,omitempty"`
	// Specifies whether to perform a dry run.
	//
	// During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no file system is created and no fee is incurred.
	//
	// Valid values:
	//
	// 	- true: performs a dry run. The system checks the required parameters, request syntax, limits, and available NAS resources. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the FileSystemId parameter.
	//
	// 	- false (default): performs a dry run and sends the request. If the request passes the dry run, a file system is created.
	//
	// example:
	//
	// false
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// cpfs-099394bd928c****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
}

func (s ApplyDataFlowAutoRefreshRequest) String() string {
	return dara.Prettify(s)
}

func (s ApplyDataFlowAutoRefreshRequest) GoString() string {
	return s.String()
}

func (s *ApplyDataFlowAutoRefreshRequest) GetAutoRefreshInterval() *int64 {
	return s.AutoRefreshInterval
}

func (s *ApplyDataFlowAutoRefreshRequest) GetAutoRefreshPolicy() *string {
	return s.AutoRefreshPolicy
}

func (s *ApplyDataFlowAutoRefreshRequest) GetAutoRefreshs() []*ApplyDataFlowAutoRefreshRequestAutoRefreshs {
	return s.AutoRefreshs
}

func (s *ApplyDataFlowAutoRefreshRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *ApplyDataFlowAutoRefreshRequest) GetDataFlowId() *string {
	return s.DataFlowId
}

func (s *ApplyDataFlowAutoRefreshRequest) GetDryRun() *bool {
	return s.DryRun
}

func (s *ApplyDataFlowAutoRefreshRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *ApplyDataFlowAutoRefreshRequest) SetAutoRefreshInterval(v int64) *ApplyDataFlowAutoRefreshRequest {
	s.AutoRefreshInterval = &v
	return s
}

func (s *ApplyDataFlowAutoRefreshRequest) SetAutoRefreshPolicy(v string) *ApplyDataFlowAutoRefreshRequest {
	s.AutoRefreshPolicy = &v
	return s
}

func (s *ApplyDataFlowAutoRefreshRequest) SetAutoRefreshs(v []*ApplyDataFlowAutoRefreshRequestAutoRefreshs) *ApplyDataFlowAutoRefreshRequest {
	s.AutoRefreshs = v
	return s
}

func (s *ApplyDataFlowAutoRefreshRequest) SetClientToken(v string) *ApplyDataFlowAutoRefreshRequest {
	s.ClientToken = &v
	return s
}

func (s *ApplyDataFlowAutoRefreshRequest) SetDataFlowId(v string) *ApplyDataFlowAutoRefreshRequest {
	s.DataFlowId = &v
	return s
}

func (s *ApplyDataFlowAutoRefreshRequest) SetDryRun(v bool) *ApplyDataFlowAutoRefreshRequest {
	s.DryRun = &v
	return s
}

func (s *ApplyDataFlowAutoRefreshRequest) SetFileSystemId(v string) *ApplyDataFlowAutoRefreshRequest {
	s.FileSystemId = &v
	return s
}

func (s *ApplyDataFlowAutoRefreshRequest) Validate() error {
	return dara.Validate(s)
}

type ApplyDataFlowAutoRefreshRequestAutoRefreshs struct {
	// The automatic update directory. CPFS automatically checks whether the source data only in the directory is updated and imports the updated data.
	//
	// Limits:
	//
	// 	- The directory must be 2 to 1,024 characters in length.
	//
	// 	- The directory must be encoded in UTF-8.
	//
	// 	- The directory must start and end with a forward slash (/).
	//
	// >  The directory must be an existing directory in the CPFS file system and must be in a fileset where the dataflow is enabled.
	//
	// This parameter is required.
	//
	// example:
	//
	// /prefix1/prefix2/
	RefreshPath *string `json:"RefreshPath,omitempty" xml:"RefreshPath,omitempty"`
}

func (s ApplyDataFlowAutoRefreshRequestAutoRefreshs) String() string {
	return dara.Prettify(s)
}

func (s ApplyDataFlowAutoRefreshRequestAutoRefreshs) GoString() string {
	return s.String()
}

func (s *ApplyDataFlowAutoRefreshRequestAutoRefreshs) GetRefreshPath() *string {
	return s.RefreshPath
}

func (s *ApplyDataFlowAutoRefreshRequestAutoRefreshs) SetRefreshPath(v string) *ApplyDataFlowAutoRefreshRequestAutoRefreshs {
	s.RefreshPath = &v
	return s
}

func (s *ApplyDataFlowAutoRefreshRequestAutoRefreshs) Validate() error {
	return dara.Validate(s)
}

type iApplyDataFlowAutoRefreshResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *ApplyDataFlowAutoRefreshResponseBody
	GetRequestId() *string
}

type ApplyDataFlowAutoRefreshResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 98696EF0-1607-4E9D-B01D-F20930B6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ApplyDataFlowAutoRefreshResponseBody) String() string {
	return dara.Prettify(s)
}

func (s ApplyDataFlowAutoRefreshResponseBody) GoString() string {
	return s.String()
}

func (s *ApplyDataFlowAutoRefreshResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *ApplyDataFlowAutoRefreshResponseBody) SetRequestId(v string) *ApplyDataFlowAutoRefreshResponseBody {
	s.RequestId = &v
	return s
}

func (s *ApplyDataFlowAutoRefreshResponseBody) Validate() error {
	return dara.Validate(s)
}

type iApplyDataFlowAutoRefreshResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *ApplyDataFlowAutoRefreshResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *ApplyDataFlowAutoRefreshResponse
	GetStatusCode() *int32
	SetBody(v *ApplyDataFlowAutoRefreshResponseBody) *ApplyDataFlowAutoRefreshResponse
	GetBody() *ApplyDataFlowAutoRefreshResponseBody
}

type ApplyDataFlowAutoRefreshResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ApplyDataFlowAutoRefreshResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ApplyDataFlowAutoRefreshResponse) String() string {
	return dara.Prettify(s)
}

func (s ApplyDataFlowAutoRefreshResponse) GoString() string {
	return s.String()
}

func (s *ApplyDataFlowAutoRefreshResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *ApplyDataFlowAutoRefreshResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *ApplyDataFlowAutoRefreshResponse) GetBody() *ApplyDataFlowAutoRefreshResponseBody {
	return s.Body
}

func (s *ApplyDataFlowAutoRefreshResponse) SetHeaders(v map[string]*string) *ApplyDataFlowAutoRefreshResponse {
	s.Headers = v
	return s
}

func (s *ApplyDataFlowAutoRefreshResponse) SetStatusCode(v int32) *ApplyDataFlowAutoRefreshResponse {
	s.StatusCode = &v
	return s
}

func (s *ApplyDataFlowAutoRefreshResponse) SetBody(v *ApplyDataFlowAutoRefreshResponseBody) *ApplyDataFlowAutoRefreshResponse {
	s.Body = v
	return s
}

func (s *ApplyDataFlowAutoRefreshResponse) Validate() error {
	return dara.Validate(s)
}

type iAttachVscMountPointRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *AttachVscMountPointRequest
	GetFileSystemId() *string
	SetMountPointDomain(v string) *AttachVscMountPointRequest
	GetMountPointDomain() *string
	SetVscAttachInfos(v []*AttachVscMountPointRequestVscAttachInfos) *AttachVscMountPointRequest
	GetVscAttachInfos() []*AttachVscMountPointRequestVscAttachInfos
}

type AttachVscMountPointRequest struct {
	// This parameter is required.
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// This parameter is required.
	MountPointDomain *string `json:"MountPointDomain,omitempty" xml:"MountPointDomain,omitempty"`
	// This parameter is required.
	VscAttachInfos []*AttachVscMountPointRequestVscAttachInfos `json:"VscAttachInfos,omitempty" xml:"VscAttachInfos,omitempty" type:"Repeated"`
}

func (s AttachVscMountPointRequest) String() string {
	return dara.Prettify(s)
}

func (s AttachVscMountPointRequest) GoString() string {
	return s.String()
}

func (s *AttachVscMountPointRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *AttachVscMountPointRequest) GetMountPointDomain() *string {
	return s.MountPointDomain
}

func (s *AttachVscMountPointRequest) GetVscAttachInfos() []*AttachVscMountPointRequestVscAttachInfos {
	return s.VscAttachInfos
}

func (s *AttachVscMountPointRequest) SetFileSystemId(v string) *AttachVscMountPointRequest {
	s.FileSystemId = &v
	return s
}

func (s *AttachVscMountPointRequest) SetMountPointDomain(v string) *AttachVscMountPointRequest {
	s.MountPointDomain = &v
	return s
}

func (s *AttachVscMountPointRequest) SetVscAttachInfos(v []*AttachVscMountPointRequestVscAttachInfos) *AttachVscMountPointRequest {
	s.VscAttachInfos = v
	return s
}

func (s *AttachVscMountPointRequest) Validate() error {
	return dara.Validate(s)
}

type AttachVscMountPointRequestVscAttachInfos struct {
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	VscId      *string `json:"VscId,omitempty" xml:"VscId,omitempty"`
	VscType    *string `json:"VscType,omitempty" xml:"VscType,omitempty"`
}

func (s AttachVscMountPointRequestVscAttachInfos) String() string {
	return dara.Prettify(s)
}

func (s AttachVscMountPointRequestVscAttachInfos) GoString() string {
	return s.String()
}

func (s *AttachVscMountPointRequestVscAttachInfos) GetInstanceId() *string {
	return s.InstanceId
}

func (s *AttachVscMountPointRequestVscAttachInfos) GetVscId() *string {
	return s.VscId
}

func (s *AttachVscMountPointRequestVscAttachInfos) GetVscType() *string {
	return s.VscType
}

func (s *AttachVscMountPointRequestVscAttachInfos) SetInstanceId(v string) *AttachVscMountPointRequestVscAttachInfos {
	s.InstanceId = &v
	return s
}

func (s *AttachVscMountPointRequestVscAttachInfos) SetVscId(v string) *AttachVscMountPointRequestVscAttachInfos {
	s.VscId = &v
	return s
}

func (s *AttachVscMountPointRequestVscAttachInfos) SetVscType(v string) *AttachVscMountPointRequestVscAttachInfos {
	s.VscType = &v
	return s
}

func (s *AttachVscMountPointRequestVscAttachInfos) Validate() error {
	return dara.Validate(s)
}

type iAttachVscMountPointResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetAttachInfos(v *AttachVscMountPointResponseBodyAttachInfos) *AttachVscMountPointResponseBody
	GetAttachInfos() *AttachVscMountPointResponseBodyAttachInfos
	SetRequestId(v string) *AttachVscMountPointResponseBody
	GetRequestId() *string
}

type AttachVscMountPointResponseBody struct {
	AttachInfos *AttachVscMountPointResponseBodyAttachInfos `json:"AttachInfos,omitempty" xml:"AttachInfos,omitempty" type:"Struct"`
	RequestId   *string                                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AttachVscMountPointResponseBody) String() string {
	return dara.Prettify(s)
}

func (s AttachVscMountPointResponseBody) GoString() string {
	return s.String()
}

func (s *AttachVscMountPointResponseBody) GetAttachInfos() *AttachVscMountPointResponseBodyAttachInfos {
	return s.AttachInfos
}

func (s *AttachVscMountPointResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *AttachVscMountPointResponseBody) SetAttachInfos(v *AttachVscMountPointResponseBodyAttachInfos) *AttachVscMountPointResponseBody {
	s.AttachInfos = v
	return s
}

func (s *AttachVscMountPointResponseBody) SetRequestId(v string) *AttachVscMountPointResponseBody {
	s.RequestId = &v
	return s
}

func (s *AttachVscMountPointResponseBody) Validate() error {
	return dara.Validate(s)
}

type AttachVscMountPointResponseBodyAttachInfos struct {
	AttachInfo []*AttachVscMountPointResponseBodyAttachInfosAttachInfo `json:"AttachInfo,omitempty" xml:"AttachInfo,omitempty" type:"Repeated"`
}

func (s AttachVscMountPointResponseBodyAttachInfos) String() string {
	return dara.Prettify(s)
}

func (s AttachVscMountPointResponseBodyAttachInfos) GoString() string {
	return s.String()
}

func (s *AttachVscMountPointResponseBodyAttachInfos) GetAttachInfo() []*AttachVscMountPointResponseBodyAttachInfosAttachInfo {
	return s.AttachInfo
}

func (s *AttachVscMountPointResponseBodyAttachInfos) SetAttachInfo(v []*AttachVscMountPointResponseBodyAttachInfosAttachInfo) *AttachVscMountPointResponseBodyAttachInfos {
	s.AttachInfo = v
	return s
}

func (s *AttachVscMountPointResponseBodyAttachInfos) Validate() error {
	return dara.Validate(s)
}

type AttachVscMountPointResponseBodyAttachInfosAttachInfo struct {
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	Status     *string `json:"Status,omitempty" xml:"Status,omitempty"`
	VscId      *string `json:"VscId,omitempty" xml:"VscId,omitempty"`
	VscType    *string `json:"VscType,omitempty" xml:"VscType,omitempty"`
}

func (s AttachVscMountPointResponseBodyAttachInfosAttachInfo) String() string {
	return dara.Prettify(s)
}

func (s AttachVscMountPointResponseBodyAttachInfosAttachInfo) GoString() string {
	return s.String()
}

func (s *AttachVscMountPointResponseBodyAttachInfosAttachInfo) GetInstanceId() *string {
	return s.InstanceId
}

func (s *AttachVscMountPointResponseBodyAttachInfosAttachInfo) GetStatus() *string {
	return s.Status
}

func (s *AttachVscMountPointResponseBodyAttachInfosAttachInfo) GetVscId() *string {
	return s.VscId
}

func (s *AttachVscMountPointResponseBodyAttachInfosAttachInfo) GetVscType() *string {
	return s.VscType
}

func (s *AttachVscMountPointResponseBodyAttachInfosAttachInfo) SetInstanceId(v string) *AttachVscMountPointResponseBodyAttachInfosAttachInfo {
	s.InstanceId = &v
	return s
}

func (s *AttachVscMountPointResponseBodyAttachInfosAttachInfo) SetStatus(v string) *AttachVscMountPointResponseBodyAttachInfosAttachInfo {
	s.Status = &v
	return s
}

func (s *AttachVscMountPointResponseBodyAttachInfosAttachInfo) SetVscId(v string) *AttachVscMountPointResponseBodyAttachInfosAttachInfo {
	s.VscId = &v
	return s
}

func (s *AttachVscMountPointResponseBodyAttachInfosAttachInfo) SetVscType(v string) *AttachVscMountPointResponseBodyAttachInfosAttachInfo {
	s.VscType = &v
	return s
}

func (s *AttachVscMountPointResponseBodyAttachInfosAttachInfo) Validate() error {
	return dara.Validate(s)
}

type iAttachVscMountPointResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *AttachVscMountPointResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *AttachVscMountPointResponse
	GetStatusCode() *int32
	SetBody(v *AttachVscMountPointResponseBody) *AttachVscMountPointResponse
	GetBody() *AttachVscMountPointResponseBody
}

type AttachVscMountPointResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AttachVscMountPointResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AttachVscMountPointResponse) String() string {
	return dara.Prettify(s)
}

func (s AttachVscMountPointResponse) GoString() string {
	return s.String()
}

func (s *AttachVscMountPointResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *AttachVscMountPointResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *AttachVscMountPointResponse) GetBody() *AttachVscMountPointResponseBody {
	return s.Body
}

func (s *AttachVscMountPointResponse) SetHeaders(v map[string]*string) *AttachVscMountPointResponse {
	s.Headers = v
	return s
}

func (s *AttachVscMountPointResponse) SetStatusCode(v int32) *AttachVscMountPointResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachVscMountPointResponse) SetBody(v *AttachVscMountPointResponseBody) *AttachVscMountPointResponse {
	s.Body = v
	return s
}

func (s *AttachVscMountPointResponse) Validate() error {
	return dara.Validate(s)
}

type iAttachVscToFilesystemsRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientToken(v string) *AttachVscToFilesystemsRequest
	GetClientToken() *string
	SetResourceIds(v []*AttachVscToFilesystemsRequestResourceIds) *AttachVscToFilesystemsRequest
	GetResourceIds() []*AttachVscToFilesystemsRequestResourceIds
}

type AttachVscToFilesystemsRequest struct {
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// This parameter is required.
	ResourceIds []*AttachVscToFilesystemsRequestResourceIds `json:"ResourceIds,omitempty" xml:"ResourceIds,omitempty" type:"Repeated"`
}

func (s AttachVscToFilesystemsRequest) String() string {
	return dara.Prettify(s)
}

func (s AttachVscToFilesystemsRequest) GoString() string {
	return s.String()
}

func (s *AttachVscToFilesystemsRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *AttachVscToFilesystemsRequest) GetResourceIds() []*AttachVscToFilesystemsRequestResourceIds {
	return s.ResourceIds
}

func (s *AttachVscToFilesystemsRequest) SetClientToken(v string) *AttachVscToFilesystemsRequest {
	s.ClientToken = &v
	return s
}

func (s *AttachVscToFilesystemsRequest) SetResourceIds(v []*AttachVscToFilesystemsRequestResourceIds) *AttachVscToFilesystemsRequest {
	s.ResourceIds = v
	return s
}

func (s *AttachVscToFilesystemsRequest) Validate() error {
	return dara.Validate(s)
}

type AttachVscToFilesystemsRequestResourceIds struct {
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	VscId        *string `json:"VscId,omitempty" xml:"VscId,omitempty"`
}

func (s AttachVscToFilesystemsRequestResourceIds) String() string {
	return dara.Prettify(s)
}

func (s AttachVscToFilesystemsRequestResourceIds) GoString() string {
	return s.String()
}

func (s *AttachVscToFilesystemsRequestResourceIds) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *AttachVscToFilesystemsRequestResourceIds) GetVscId() *string {
	return s.VscId
}

func (s *AttachVscToFilesystemsRequestResourceIds) SetFileSystemId(v string) *AttachVscToFilesystemsRequestResourceIds {
	s.FileSystemId = &v
	return s
}

func (s *AttachVscToFilesystemsRequestResourceIds) SetVscId(v string) *AttachVscToFilesystemsRequestResourceIds {
	s.VscId = &v
	return s
}

func (s *AttachVscToFilesystemsRequestResourceIds) Validate() error {
	return dara.Validate(s)
}

type iAttachVscToFilesystemsResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *AttachVscToFilesystemsResponseBody
	GetRequestId() *string
}

type AttachVscToFilesystemsResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AttachVscToFilesystemsResponseBody) String() string {
	return dara.Prettify(s)
}

func (s AttachVscToFilesystemsResponseBody) GoString() string {
	return s.String()
}

func (s *AttachVscToFilesystemsResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *AttachVscToFilesystemsResponseBody) SetRequestId(v string) *AttachVscToFilesystemsResponseBody {
	s.RequestId = &v
	return s
}

func (s *AttachVscToFilesystemsResponseBody) Validate() error {
	return dara.Validate(s)
}

type iAttachVscToFilesystemsResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *AttachVscToFilesystemsResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *AttachVscToFilesystemsResponse
	GetStatusCode() *int32
	SetBody(v *AttachVscToFilesystemsResponseBody) *AttachVscToFilesystemsResponse
	GetBody() *AttachVscToFilesystemsResponseBody
}

type AttachVscToFilesystemsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AttachVscToFilesystemsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AttachVscToFilesystemsResponse) String() string {
	return dara.Prettify(s)
}

func (s AttachVscToFilesystemsResponse) GoString() string {
	return s.String()
}

func (s *AttachVscToFilesystemsResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *AttachVscToFilesystemsResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *AttachVscToFilesystemsResponse) GetBody() *AttachVscToFilesystemsResponseBody {
	return s.Body
}

func (s *AttachVscToFilesystemsResponse) SetHeaders(v map[string]*string) *AttachVscToFilesystemsResponse {
	s.Headers = v
	return s
}

func (s *AttachVscToFilesystemsResponse) SetStatusCode(v int32) *AttachVscToFilesystemsResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachVscToFilesystemsResponse) SetBody(v *AttachVscToFilesystemsResponseBody) *AttachVscToFilesystemsResponse {
	s.Body = v
	return s
}

func (s *AttachVscToFilesystemsResponse) Validate() error {
	return dara.Validate(s)
}

type iBindStoragePackageRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *BindStoragePackageRequest
	GetFileSystemId() *string
	SetPackageId(v string) *BindStoragePackageRequest
	GetPackageId() *string
	SetRegionId(v string) *BindStoragePackageRequest
	GetRegionId() *string
}

type BindStoragePackageRequest struct {
	// This parameter is required.
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// This parameter is required.
	PackageId *string `json:"PackageId,omitempty" xml:"PackageId,omitempty"`
	// This parameter is required.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s BindStoragePackageRequest) String() string {
	return dara.Prettify(s)
}

func (s BindStoragePackageRequest) GoString() string {
	return s.String()
}

func (s *BindStoragePackageRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *BindStoragePackageRequest) GetPackageId() *string {
	return s.PackageId
}

func (s *BindStoragePackageRequest) GetRegionId() *string {
	return s.RegionId
}

func (s *BindStoragePackageRequest) SetFileSystemId(v string) *BindStoragePackageRequest {
	s.FileSystemId = &v
	return s
}

func (s *BindStoragePackageRequest) SetPackageId(v string) *BindStoragePackageRequest {
	s.PackageId = &v
	return s
}

func (s *BindStoragePackageRequest) SetRegionId(v string) *BindStoragePackageRequest {
	s.RegionId = &v
	return s
}

func (s *BindStoragePackageRequest) Validate() error {
	return dara.Validate(s)
}

type iBindStoragePackageResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *BindStoragePackageResponseBody
	GetRequestId() *string
}

type BindStoragePackageResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BindStoragePackageResponseBody) String() string {
	return dara.Prettify(s)
}

func (s BindStoragePackageResponseBody) GoString() string {
	return s.String()
}

func (s *BindStoragePackageResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *BindStoragePackageResponseBody) SetRequestId(v string) *BindStoragePackageResponseBody {
	s.RequestId = &v
	return s
}

func (s *BindStoragePackageResponseBody) Validate() error {
	return dara.Validate(s)
}

type iBindStoragePackageResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *BindStoragePackageResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *BindStoragePackageResponse
	GetStatusCode() *int32
	SetBody(v *BindStoragePackageResponseBody) *BindStoragePackageResponse
	GetBody() *BindStoragePackageResponseBody
}

type BindStoragePackageResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *BindStoragePackageResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s BindStoragePackageResponse) String() string {
	return dara.Prettify(s)
}

func (s BindStoragePackageResponse) GoString() string {
	return s.String()
}

func (s *BindStoragePackageResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *BindStoragePackageResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *BindStoragePackageResponse) GetBody() *BindStoragePackageResponseBody {
	return s.Body
}

func (s *BindStoragePackageResponse) SetHeaders(v map[string]*string) *BindStoragePackageResponse {
	s.Headers = v
	return s
}

func (s *BindStoragePackageResponse) SetStatusCode(v int32) *BindStoragePackageResponse {
	s.StatusCode = &v
	return s
}

func (s *BindStoragePackageResponse) SetBody(v *BindStoragePackageResponseBody) *BindStoragePackageResponse {
	s.Body = v
	return s
}

func (s *BindStoragePackageResponse) Validate() error {
	return dara.Validate(s)
}

type iCancelAutoSnapshotPolicyRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemIds(v string) *CancelAutoSnapshotPolicyRequest
	GetFileSystemIds() *string
}

type CancelAutoSnapshotPolicyRequest struct {
	// The IDs of file systems.
	//
	// You can specify a maximum of 100 file system IDs. If you want to remove automatic snapshot policies from multiple file systems, separate the file system IDs with commas (,).
	//
	// This parameter is required.
	//
	// example:
	//
	// extreme-233e6****,extreme-23vbp****,extreme-23vas****
	FileSystemIds *string `json:"FileSystemIds,omitempty" xml:"FileSystemIds,omitempty"`
}

func (s CancelAutoSnapshotPolicyRequest) String() string {
	return dara.Prettify(s)
}

func (s CancelAutoSnapshotPolicyRequest) GoString() string {
	return s.String()
}

func (s *CancelAutoSnapshotPolicyRequest) GetFileSystemIds() *string {
	return s.FileSystemIds
}

func (s *CancelAutoSnapshotPolicyRequest) SetFileSystemIds(v string) *CancelAutoSnapshotPolicyRequest {
	s.FileSystemIds = &v
	return s
}

func (s *CancelAutoSnapshotPolicyRequest) Validate() error {
	return dara.Validate(s)
}

type iCancelAutoSnapshotPolicyResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *CancelAutoSnapshotPolicyResponseBody
	GetRequestId() *string
}

type CancelAutoSnapshotPolicyResponseBody struct {
	// The request ID.
	//
	// Every response returns a unique request ID regardless of whether the request is successful.
	//
	// example:
	//
	// 473469C7-AA6F-4DC5-B3DB-A3DC0DED****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CancelAutoSnapshotPolicyResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CancelAutoSnapshotPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *CancelAutoSnapshotPolicyResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CancelAutoSnapshotPolicyResponseBody) SetRequestId(v string) *CancelAutoSnapshotPolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *CancelAutoSnapshotPolicyResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCancelAutoSnapshotPolicyResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CancelAutoSnapshotPolicyResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CancelAutoSnapshotPolicyResponse
	GetStatusCode() *int32
	SetBody(v *CancelAutoSnapshotPolicyResponseBody) *CancelAutoSnapshotPolicyResponse
	GetBody() *CancelAutoSnapshotPolicyResponseBody
}

type CancelAutoSnapshotPolicyResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CancelAutoSnapshotPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CancelAutoSnapshotPolicyResponse) String() string {
	return dara.Prettify(s)
}

func (s CancelAutoSnapshotPolicyResponse) GoString() string {
	return s.String()
}

func (s *CancelAutoSnapshotPolicyResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CancelAutoSnapshotPolicyResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CancelAutoSnapshotPolicyResponse) GetBody() *CancelAutoSnapshotPolicyResponseBody {
	return s.Body
}

func (s *CancelAutoSnapshotPolicyResponse) SetHeaders(v map[string]*string) *CancelAutoSnapshotPolicyResponse {
	s.Headers = v
	return s
}

func (s *CancelAutoSnapshotPolicyResponse) SetStatusCode(v int32) *CancelAutoSnapshotPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *CancelAutoSnapshotPolicyResponse) SetBody(v *CancelAutoSnapshotPolicyResponseBody) *CancelAutoSnapshotPolicyResponse {
	s.Body = v
	return s
}

func (s *CancelAutoSnapshotPolicyResponse) Validate() error {
	return dara.Validate(s)
}

type iCancelDataFlowAutoRefreshRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientToken(v string) *CancelDataFlowAutoRefreshRequest
	GetClientToken() *string
	SetDataFlowId(v string) *CancelDataFlowAutoRefreshRequest
	GetDataFlowId() *string
	SetDryRun(v bool) *CancelDataFlowAutoRefreshRequest
	GetDryRun() *bool
	SetFileSystemId(v string) *CancelDataFlowAutoRefreshRequest
	GetFileSystemId() *string
	SetRefreshPath(v string) *CancelDataFlowAutoRefreshRequest
	GetRefreshPath() *string
}

type CancelDataFlowAutoRefreshRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// >  If you do not specify this parameter, the system automatically uses the request ID as the client token. The value of RequestId may be different for each API request.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-42665544****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The dataflow ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// df-194433a5be31****
	DataFlowId *string `json:"DataFlowId,omitempty" xml:"DataFlowId,omitempty"`
	// Specifies whether to perform a dry run.
	//
	// During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no file system is created and no fee is incurred.
	//
	// Valid values:
	//
	// 	- true: performs a dry run. The system checks the request format, service limits, prerequisites, and whether the required parameters are specified. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the DataFlowld parameter.
	//
	// 	- false (default): performs a dry run and sends the request. If the request passes the dry run, a file system is created.
	//
	// example:
	//
	// false
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// cpfs-099394bd928c****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The directory for which you want to cancel AutoRefresh configurations.
	//
	// Limits:
	//
	// 	- The directory must be 2 to 1,024 characters in length.
	//
	// 	- The directory must be encoded in UTF-8.
	//
	// 	- The directory must start and end with a forward slash (/).
	//
	// >  The directory must be an existing directory in the CPFS file system and must be in a fileset where the dataflow is enabled.
	//
	// This parameter is required.
	//
	// example:
	//
	// /prefix1/prefix2/
	RefreshPath *string `json:"RefreshPath,omitempty" xml:"RefreshPath,omitempty"`
}

func (s CancelDataFlowAutoRefreshRequest) String() string {
	return dara.Prettify(s)
}

func (s CancelDataFlowAutoRefreshRequest) GoString() string {
	return s.String()
}

func (s *CancelDataFlowAutoRefreshRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *CancelDataFlowAutoRefreshRequest) GetDataFlowId() *string {
	return s.DataFlowId
}

func (s *CancelDataFlowAutoRefreshRequest) GetDryRun() *bool {
	return s.DryRun
}

func (s *CancelDataFlowAutoRefreshRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *CancelDataFlowAutoRefreshRequest) GetRefreshPath() *string {
	return s.RefreshPath
}

func (s *CancelDataFlowAutoRefreshRequest) SetClientToken(v string) *CancelDataFlowAutoRefreshRequest {
	s.ClientToken = &v
	return s
}

func (s *CancelDataFlowAutoRefreshRequest) SetDataFlowId(v string) *CancelDataFlowAutoRefreshRequest {
	s.DataFlowId = &v
	return s
}

func (s *CancelDataFlowAutoRefreshRequest) SetDryRun(v bool) *CancelDataFlowAutoRefreshRequest {
	s.DryRun = &v
	return s
}

func (s *CancelDataFlowAutoRefreshRequest) SetFileSystemId(v string) *CancelDataFlowAutoRefreshRequest {
	s.FileSystemId = &v
	return s
}

func (s *CancelDataFlowAutoRefreshRequest) SetRefreshPath(v string) *CancelDataFlowAutoRefreshRequest {
	s.RefreshPath = &v
	return s
}

func (s *CancelDataFlowAutoRefreshRequest) Validate() error {
	return dara.Validate(s)
}

type iCancelDataFlowAutoRefreshResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *CancelDataFlowAutoRefreshResponseBody
	GetRequestId() *string
}

type CancelDataFlowAutoRefreshResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 98696EF0-1607-4E9D-B01D-F20930B6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CancelDataFlowAutoRefreshResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CancelDataFlowAutoRefreshResponseBody) GoString() string {
	return s.String()
}

func (s *CancelDataFlowAutoRefreshResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CancelDataFlowAutoRefreshResponseBody) SetRequestId(v string) *CancelDataFlowAutoRefreshResponseBody {
	s.RequestId = &v
	return s
}

func (s *CancelDataFlowAutoRefreshResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCancelDataFlowAutoRefreshResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CancelDataFlowAutoRefreshResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CancelDataFlowAutoRefreshResponse
	GetStatusCode() *int32
	SetBody(v *CancelDataFlowAutoRefreshResponseBody) *CancelDataFlowAutoRefreshResponse
	GetBody() *CancelDataFlowAutoRefreshResponseBody
}

type CancelDataFlowAutoRefreshResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CancelDataFlowAutoRefreshResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CancelDataFlowAutoRefreshResponse) String() string {
	return dara.Prettify(s)
}

func (s CancelDataFlowAutoRefreshResponse) GoString() string {
	return s.String()
}

func (s *CancelDataFlowAutoRefreshResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CancelDataFlowAutoRefreshResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CancelDataFlowAutoRefreshResponse) GetBody() *CancelDataFlowAutoRefreshResponseBody {
	return s.Body
}

func (s *CancelDataFlowAutoRefreshResponse) SetHeaders(v map[string]*string) *CancelDataFlowAutoRefreshResponse {
	s.Headers = v
	return s
}

func (s *CancelDataFlowAutoRefreshResponse) SetStatusCode(v int32) *CancelDataFlowAutoRefreshResponse {
	s.StatusCode = &v
	return s
}

func (s *CancelDataFlowAutoRefreshResponse) SetBody(v *CancelDataFlowAutoRefreshResponseBody) *CancelDataFlowAutoRefreshResponse {
	s.Body = v
	return s
}

func (s *CancelDataFlowAutoRefreshResponse) Validate() error {
	return dara.Validate(s)
}

type iCancelDataFlowSubTaskRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientToken(v string) *CancelDataFlowSubTaskRequest
	GetClientToken() *string
	SetDataFlowId(v string) *CancelDataFlowSubTaskRequest
	GetDataFlowId() *string
	SetDataFlowSubTaskId(v string) *CancelDataFlowSubTaskRequest
	GetDataFlowSubTaskId() *string
	SetDataFlowTaskId(v string) *CancelDataFlowSubTaskRequest
	GetDataFlowTaskId() *string
	SetDryRun(v bool) *CancelDataFlowSubTaskRequest
	GetDryRun() *bool
	SetFileSystemId(v string) *CancelDataFlowSubTaskRequest
	GetFileSystemId() *string
}

type CancelDataFlowSubTaskRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// >  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-42665544****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the data flow.
	//
	// This parameter is required.
	//
	// example:
	//
	// df-194433a5be31****
	DataFlowId *string `json:"DataFlowId,omitempty" xml:"DataFlowId,omitempty"`
	// The ID of the data streaming task.
	//
	// This parameter is required.
	//
	// example:
	//
	// subTaskId-370kyfmyknxcyzw****
	DataFlowSubTaskId *string `json:"DataFlowSubTaskId,omitempty" xml:"DataFlowSubTaskId,omitempty"`
	// The ID of the data flow task.
	//
	// This parameter is required.
	//
	// example:
	//
	// task-38aa8e890f45****
	DataFlowTaskId *string `json:"DataFlowTaskId,omitempty" xml:"DataFlowTaskId,omitempty"`
	// Specifies whether to perform a dry run.
	//
	// During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no data streaming task is created and no fee is incurred.
	//
	// Valid values:
	//
	// 	- true: performs a dry run. The system checks the required parameters, request syntax, service limits, and available File Storage NAS (NAS) resources. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned.
	//
	// 	- false (default): performs a dry run and sends the request. If the request passes the dry run, a data streaming task is created.
	//
	// example:
	//
	// false
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// bmcpfs-370lx1ev9ss27o0****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
}

func (s CancelDataFlowSubTaskRequest) String() string {
	return dara.Prettify(s)
}

func (s CancelDataFlowSubTaskRequest) GoString() string {
	return s.String()
}

func (s *CancelDataFlowSubTaskRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *CancelDataFlowSubTaskRequest) GetDataFlowId() *string {
	return s.DataFlowId
}

func (s *CancelDataFlowSubTaskRequest) GetDataFlowSubTaskId() *string {
	return s.DataFlowSubTaskId
}

func (s *CancelDataFlowSubTaskRequest) GetDataFlowTaskId() *string {
	return s.DataFlowTaskId
}

func (s *CancelDataFlowSubTaskRequest) GetDryRun() *bool {
	return s.DryRun
}

func (s *CancelDataFlowSubTaskRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *CancelDataFlowSubTaskRequest) SetClientToken(v string) *CancelDataFlowSubTaskRequest {
	s.ClientToken = &v
	return s
}

func (s *CancelDataFlowSubTaskRequest) SetDataFlowId(v string) *CancelDataFlowSubTaskRequest {
	s.DataFlowId = &v
	return s
}

func (s *CancelDataFlowSubTaskRequest) SetDataFlowSubTaskId(v string) *CancelDataFlowSubTaskRequest {
	s.DataFlowSubTaskId = &v
	return s
}

func (s *CancelDataFlowSubTaskRequest) SetDataFlowTaskId(v string) *CancelDataFlowSubTaskRequest {
	s.DataFlowTaskId = &v
	return s
}

func (s *CancelDataFlowSubTaskRequest) SetDryRun(v bool) *CancelDataFlowSubTaskRequest {
	s.DryRun = &v
	return s
}

func (s *CancelDataFlowSubTaskRequest) SetFileSystemId(v string) *CancelDataFlowSubTaskRequest {
	s.FileSystemId = &v
	return s
}

func (s *CancelDataFlowSubTaskRequest) Validate() error {
	return dara.Validate(s)
}

type iCancelDataFlowSubTaskResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *CancelDataFlowSubTaskResponseBody
	GetRequestId() *string
}

type CancelDataFlowSubTaskResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 473469C7-AA6F-4DC5-B3DB-A3DC0DE3****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CancelDataFlowSubTaskResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CancelDataFlowSubTaskResponseBody) GoString() string {
	return s.String()
}

func (s *CancelDataFlowSubTaskResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CancelDataFlowSubTaskResponseBody) SetRequestId(v string) *CancelDataFlowSubTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *CancelDataFlowSubTaskResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCancelDataFlowSubTaskResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CancelDataFlowSubTaskResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CancelDataFlowSubTaskResponse
	GetStatusCode() *int32
	SetBody(v *CancelDataFlowSubTaskResponseBody) *CancelDataFlowSubTaskResponse
	GetBody() *CancelDataFlowSubTaskResponseBody
}

type CancelDataFlowSubTaskResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CancelDataFlowSubTaskResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CancelDataFlowSubTaskResponse) String() string {
	return dara.Prettify(s)
}

func (s CancelDataFlowSubTaskResponse) GoString() string {
	return s.String()
}

func (s *CancelDataFlowSubTaskResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CancelDataFlowSubTaskResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CancelDataFlowSubTaskResponse) GetBody() *CancelDataFlowSubTaskResponseBody {
	return s.Body
}

func (s *CancelDataFlowSubTaskResponse) SetHeaders(v map[string]*string) *CancelDataFlowSubTaskResponse {
	s.Headers = v
	return s
}

func (s *CancelDataFlowSubTaskResponse) SetStatusCode(v int32) *CancelDataFlowSubTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *CancelDataFlowSubTaskResponse) SetBody(v *CancelDataFlowSubTaskResponseBody) *CancelDataFlowSubTaskResponse {
	s.Body = v
	return s
}

func (s *CancelDataFlowSubTaskResponse) Validate() error {
	return dara.Validate(s)
}

type iCancelDataFlowTaskRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientToken(v string) *CancelDataFlowTaskRequest
	GetClientToken() *string
	SetDataFlowId(v string) *CancelDataFlowTaskRequest
	GetDataFlowId() *string
	SetDryRun(v bool) *CancelDataFlowTaskRequest
	GetDryRun() *bool
	SetFileSystemId(v string) *CancelDataFlowTaskRequest
	GetFileSystemId() *string
	SetTaskId(v string) *CancelDataFlowTaskRequest
	GetTaskId() *string
}

type CancelDataFlowTaskRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// >  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-42665544****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The dataflow ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// df-194433a5be31****
	DataFlowId *string `json:"DataFlowId,omitempty" xml:"DataFlowId,omitempty"`
	// Specifies whether to perform only a dry run, without performing the actual request.
	//
	// During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. The dry run does not cancel the specified dataflow task or incur fees.
	//
	// Valid values:
	//
	// 	- true: performs only a dry run. The system checks the required parameters, request syntax, service limits, and available NAS resources. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned.
	//
	// 	- false (default): performs a dry run and sends the request. If the request passes the dry run, the specified dataflow task is canceled.
	//
	// example:
	//
	// false
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the file system.
	//
	// 	- The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-125487\\*\\*\\*\\*.
	//
	// 	- The IDs of CPFS for LINGJUN file systems must start with `bmcpfs-`. Example: bmcpfs-0015\\*\\*\\*\\*.
	//
	// >  CPFS is not supported on the international site.
	//
	// This parameter is required.
	//
	// example:
	//
	// cpfs-099394bd928c****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The ID of the dataflow task.
	//
	// This parameter is required.
	//
	// example:
	//
	// task-38aa8e890f45****
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s CancelDataFlowTaskRequest) String() string {
	return dara.Prettify(s)
}

func (s CancelDataFlowTaskRequest) GoString() string {
	return s.String()
}

func (s *CancelDataFlowTaskRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *CancelDataFlowTaskRequest) GetDataFlowId() *string {
	return s.DataFlowId
}

func (s *CancelDataFlowTaskRequest) GetDryRun() *bool {
	return s.DryRun
}

func (s *CancelDataFlowTaskRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *CancelDataFlowTaskRequest) GetTaskId() *string {
	return s.TaskId
}

func (s *CancelDataFlowTaskRequest) SetClientToken(v string) *CancelDataFlowTaskRequest {
	s.ClientToken = &v
	return s
}

func (s *CancelDataFlowTaskRequest) SetDataFlowId(v string) *CancelDataFlowTaskRequest {
	s.DataFlowId = &v
	return s
}

func (s *CancelDataFlowTaskRequest) SetDryRun(v bool) *CancelDataFlowTaskRequest {
	s.DryRun = &v
	return s
}

func (s *CancelDataFlowTaskRequest) SetFileSystemId(v string) *CancelDataFlowTaskRequest {
	s.FileSystemId = &v
	return s
}

func (s *CancelDataFlowTaskRequest) SetTaskId(v string) *CancelDataFlowTaskRequest {
	s.TaskId = &v
	return s
}

func (s *CancelDataFlowTaskRequest) Validate() error {
	return dara.Validate(s)
}

type iCancelDataFlowTaskResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *CancelDataFlowTaskResponseBody
	GetRequestId() *string
}

type CancelDataFlowTaskResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 2D69A58F-345C-4FDE-88E4-BF518948****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CancelDataFlowTaskResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CancelDataFlowTaskResponseBody) GoString() string {
	return s.String()
}

func (s *CancelDataFlowTaskResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CancelDataFlowTaskResponseBody) SetRequestId(v string) *CancelDataFlowTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *CancelDataFlowTaskResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCancelDataFlowTaskResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CancelDataFlowTaskResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CancelDataFlowTaskResponse
	GetStatusCode() *int32
	SetBody(v *CancelDataFlowTaskResponseBody) *CancelDataFlowTaskResponse
	GetBody() *CancelDataFlowTaskResponseBody
}

type CancelDataFlowTaskResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CancelDataFlowTaskResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CancelDataFlowTaskResponse) String() string {
	return dara.Prettify(s)
}

func (s CancelDataFlowTaskResponse) GoString() string {
	return s.String()
}

func (s *CancelDataFlowTaskResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CancelDataFlowTaskResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CancelDataFlowTaskResponse) GetBody() *CancelDataFlowTaskResponseBody {
	return s.Body
}

func (s *CancelDataFlowTaskResponse) SetHeaders(v map[string]*string) *CancelDataFlowTaskResponse {
	s.Headers = v
	return s
}

func (s *CancelDataFlowTaskResponse) SetStatusCode(v int32) *CancelDataFlowTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *CancelDataFlowTaskResponse) SetBody(v *CancelDataFlowTaskResponseBody) *CancelDataFlowTaskResponse {
	s.Body = v
	return s
}

func (s *CancelDataFlowTaskResponse) Validate() error {
	return dara.Validate(s)
}

type iCancelDirQuotaRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *CancelDirQuotaRequest
	GetFileSystemId() *string
	SetPath(v string) *CancelDirQuotaRequest
	GetPath() *string
	SetUserId(v string) *CancelDirQuotaRequest
	GetUserId() *string
	SetUserType(v string) *CancelDirQuotaRequest
	GetUserType() *string
}

type CancelDirQuotaRequest struct {
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1ca404****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The absolute path of a directory.
	//
	// This parameter is required.
	//
	// example:
	//
	// /data/sub1
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The UID or GID of a user for whom you want to cancel the directory quota.
	//
	// This parameter is required and valid only if the UserType parameter is set to Uid or Gid.
	//
	// Examples:
	//
	// 	- If you want to cancel a quota for a user whose UID is 500, set the UserType parameter to Uid and set the UserId parameter to 500.
	//
	// 	- If you want to cancel a quota for a group whose GID is 100, set the UserType parameter to Gid and set the UserId parameter to 100.
	//
	// example:
	//
	// 500
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The type of the user.
	//
	// Valid values:
	//
	// 	- Uid: user ID
	//
	// 	- Gid: user group ID
	//
	// 	- AllUsers: all users
	//
	// This parameter is required.
	//
	// example:
	//
	// Uid
	UserType *string `json:"UserType,omitempty" xml:"UserType,omitempty"`
}

func (s CancelDirQuotaRequest) String() string {
	return dara.Prettify(s)
}

func (s CancelDirQuotaRequest) GoString() string {
	return s.String()
}

func (s *CancelDirQuotaRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *CancelDirQuotaRequest) GetPath() *string {
	return s.Path
}

func (s *CancelDirQuotaRequest) GetUserId() *string {
	return s.UserId
}

func (s *CancelDirQuotaRequest) GetUserType() *string {
	return s.UserType
}

func (s *CancelDirQuotaRequest) SetFileSystemId(v string) *CancelDirQuotaRequest {
	s.FileSystemId = &v
	return s
}

func (s *CancelDirQuotaRequest) SetPath(v string) *CancelDirQuotaRequest {
	s.Path = &v
	return s
}

func (s *CancelDirQuotaRequest) SetUserId(v string) *CancelDirQuotaRequest {
	s.UserId = &v
	return s
}

func (s *CancelDirQuotaRequest) SetUserType(v string) *CancelDirQuotaRequest {
	s.UserType = &v
	return s
}

func (s *CancelDirQuotaRequest) Validate() error {
	return dara.Validate(s)
}

type iCancelDirQuotaResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *CancelDirQuotaResponseBody
	GetRequestId() *string
	SetSuccess(v bool) *CancelDirQuotaResponseBody
	GetSuccess() *bool
}

type CancelDirQuotaResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 5BC5CB97-9F28-42FE-84A4-0CD0DF42****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	//
	// Valid values:
	//
	// 	- true
	//
	// 	- false
	//
	// example:
	//
	// true
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CancelDirQuotaResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CancelDirQuotaResponseBody) GoString() string {
	return s.String()
}

func (s *CancelDirQuotaResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CancelDirQuotaResponseBody) GetSuccess() *bool {
	return s.Success
}

func (s *CancelDirQuotaResponseBody) SetRequestId(v string) *CancelDirQuotaResponseBody {
	s.RequestId = &v
	return s
}

func (s *CancelDirQuotaResponseBody) SetSuccess(v bool) *CancelDirQuotaResponseBody {
	s.Success = &v
	return s
}

func (s *CancelDirQuotaResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCancelDirQuotaResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CancelDirQuotaResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CancelDirQuotaResponse
	GetStatusCode() *int32
	SetBody(v *CancelDirQuotaResponseBody) *CancelDirQuotaResponse
	GetBody() *CancelDirQuotaResponseBody
}

type CancelDirQuotaResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CancelDirQuotaResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CancelDirQuotaResponse) String() string {
	return dara.Prettify(s)
}

func (s CancelDirQuotaResponse) GoString() string {
	return s.String()
}

func (s *CancelDirQuotaResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CancelDirQuotaResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CancelDirQuotaResponse) GetBody() *CancelDirQuotaResponseBody {
	return s.Body
}

func (s *CancelDirQuotaResponse) SetHeaders(v map[string]*string) *CancelDirQuotaResponse {
	s.Headers = v
	return s
}

func (s *CancelDirQuotaResponse) SetStatusCode(v int32) *CancelDirQuotaResponse {
	s.StatusCode = &v
	return s
}

func (s *CancelDirQuotaResponse) SetBody(v *CancelDirQuotaResponseBody) *CancelDirQuotaResponse {
	s.Body = v
	return s
}

func (s *CancelDirQuotaResponse) Validate() error {
	return dara.Validate(s)
}

type iCancelFilesetQuotaRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientToken(v string) *CancelFilesetQuotaRequest
	GetClientToken() *string
	SetDryRun(v bool) *CancelFilesetQuotaRequest
	GetDryRun() *bool
	SetFileSystemId(v string) *CancelFilesetQuotaRequest
	GetFileSystemId() *string
	SetFsetId(v string) *CancelFilesetQuotaRequest
	GetFsetId() *string
}

type CancelFilesetQuotaRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// >  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-42665544****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run.
	//
	// During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no fileset quota is canceled and no fee is incurred.
	//
	// Valid values:
	//
	// 	- true: performs a dry run. The system checks the required parameters, request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the DataFlowld parameter.
	//
	// 	- false (default): performs a dry run and sends the request. If the request passes the dry run, the fileset quota is canceled.
	//
	// example:
	//
	// false
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the CPFS for LINGJUN file system. The IDs of CPFS for LINGJUN file systems must start with `bmcpfs-`. Example: bmcpfs-290w65p03ok64ya\\*\\*\\*\\*.
	//
	// This parameter is required.
	//
	// example:
	//
	// bmcpfs-290w65p03ok64ya****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The fileset ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// fset-1902718ea0ae****
	FsetId *string `json:"FsetId,omitempty" xml:"FsetId,omitempty"`
}

func (s CancelFilesetQuotaRequest) String() string {
	return dara.Prettify(s)
}

func (s CancelFilesetQuotaRequest) GoString() string {
	return s.String()
}

func (s *CancelFilesetQuotaRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *CancelFilesetQuotaRequest) GetDryRun() *bool {
	return s.DryRun
}

func (s *CancelFilesetQuotaRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *CancelFilesetQuotaRequest) GetFsetId() *string {
	return s.FsetId
}

func (s *CancelFilesetQuotaRequest) SetClientToken(v string) *CancelFilesetQuotaRequest {
	s.ClientToken = &v
	return s
}

func (s *CancelFilesetQuotaRequest) SetDryRun(v bool) *CancelFilesetQuotaRequest {
	s.DryRun = &v
	return s
}

func (s *CancelFilesetQuotaRequest) SetFileSystemId(v string) *CancelFilesetQuotaRequest {
	s.FileSystemId = &v
	return s
}

func (s *CancelFilesetQuotaRequest) SetFsetId(v string) *CancelFilesetQuotaRequest {
	s.FsetId = &v
	return s
}

func (s *CancelFilesetQuotaRequest) Validate() error {
	return dara.Validate(s)
}

type iCancelFilesetQuotaResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *CancelFilesetQuotaResponseBody
	GetRequestId() *string
}

type CancelFilesetQuotaResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 98696EF0-1607-4E9D-B01D-F20930B6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CancelFilesetQuotaResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CancelFilesetQuotaResponseBody) GoString() string {
	return s.String()
}

func (s *CancelFilesetQuotaResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CancelFilesetQuotaResponseBody) SetRequestId(v string) *CancelFilesetQuotaResponseBody {
	s.RequestId = &v
	return s
}

func (s *CancelFilesetQuotaResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCancelFilesetQuotaResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CancelFilesetQuotaResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CancelFilesetQuotaResponse
	GetStatusCode() *int32
	SetBody(v *CancelFilesetQuotaResponseBody) *CancelFilesetQuotaResponse
	GetBody() *CancelFilesetQuotaResponseBody
}

type CancelFilesetQuotaResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CancelFilesetQuotaResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CancelFilesetQuotaResponse) String() string {
	return dara.Prettify(s)
}

func (s CancelFilesetQuotaResponse) GoString() string {
	return s.String()
}

func (s *CancelFilesetQuotaResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CancelFilesetQuotaResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CancelFilesetQuotaResponse) GetBody() *CancelFilesetQuotaResponseBody {
	return s.Body
}

func (s *CancelFilesetQuotaResponse) SetHeaders(v map[string]*string) *CancelFilesetQuotaResponse {
	s.Headers = v
	return s
}

func (s *CancelFilesetQuotaResponse) SetStatusCode(v int32) *CancelFilesetQuotaResponse {
	s.StatusCode = &v
	return s
}

func (s *CancelFilesetQuotaResponse) SetBody(v *CancelFilesetQuotaResponseBody) *CancelFilesetQuotaResponse {
	s.Body = v
	return s
}

func (s *CancelFilesetQuotaResponse) Validate() error {
	return dara.Validate(s)
}

type iCancelLifecycleRetrieveJobRequest interface {
	dara.Model
	String() string
	GoString() string
	SetJobId(v string) *CancelLifecycleRetrieveJobRequest
	GetJobId() *string
}

type CancelLifecycleRetrieveJobRequest struct {
	// The ID of the data retrieval task.
	//
	// This parameter is required.
	//
	// example:
	//
	// lrj-nfstest-ia-160****853-hshvw
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
}

func (s CancelLifecycleRetrieveJobRequest) String() string {
	return dara.Prettify(s)
}

func (s CancelLifecycleRetrieveJobRequest) GoString() string {
	return s.String()
}

func (s *CancelLifecycleRetrieveJobRequest) GetJobId() *string {
	return s.JobId
}

func (s *CancelLifecycleRetrieveJobRequest) SetJobId(v string) *CancelLifecycleRetrieveJobRequest {
	s.JobId = &v
	return s
}

func (s *CancelLifecycleRetrieveJobRequest) Validate() error {
	return dara.Validate(s)
}

type iCancelLifecycleRetrieveJobResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *CancelLifecycleRetrieveJobResponseBody
	GetRequestId() *string
}

type CancelLifecycleRetrieveJobResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// BC7C825C-5F65-4B56-BEF6-98C56C7C****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CancelLifecycleRetrieveJobResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CancelLifecycleRetrieveJobResponseBody) GoString() string {
	return s.String()
}

func (s *CancelLifecycleRetrieveJobResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CancelLifecycleRetrieveJobResponseBody) SetRequestId(v string) *CancelLifecycleRetrieveJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *CancelLifecycleRetrieveJobResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCancelLifecycleRetrieveJobResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CancelLifecycleRetrieveJobResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CancelLifecycleRetrieveJobResponse
	GetStatusCode() *int32
	SetBody(v *CancelLifecycleRetrieveJobResponseBody) *CancelLifecycleRetrieveJobResponse
	GetBody() *CancelLifecycleRetrieveJobResponseBody
}

type CancelLifecycleRetrieveJobResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CancelLifecycleRetrieveJobResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CancelLifecycleRetrieveJobResponse) String() string {
	return dara.Prettify(s)
}

func (s CancelLifecycleRetrieveJobResponse) GoString() string {
	return s.String()
}

func (s *CancelLifecycleRetrieveJobResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CancelLifecycleRetrieveJobResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CancelLifecycleRetrieveJobResponse) GetBody() *CancelLifecycleRetrieveJobResponseBody {
	return s.Body
}

func (s *CancelLifecycleRetrieveJobResponse) SetHeaders(v map[string]*string) *CancelLifecycleRetrieveJobResponse {
	s.Headers = v
	return s
}

func (s *CancelLifecycleRetrieveJobResponse) SetStatusCode(v int32) *CancelLifecycleRetrieveJobResponse {
	s.StatusCode = &v
	return s
}

func (s *CancelLifecycleRetrieveJobResponse) SetBody(v *CancelLifecycleRetrieveJobResponseBody) *CancelLifecycleRetrieveJobResponse {
	s.Body = v
	return s
}

func (s *CancelLifecycleRetrieveJobResponse) Validate() error {
	return dara.Validate(s)
}

type iCancelRecycleBinJobRequest interface {
	dara.Model
	String() string
	GoString() string
	SetJobId(v string) *CancelRecycleBinJobRequest
	GetJobId() *string
}

type CancelRecycleBinJobRequest struct {
	// The job ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// rb-15****ed-r-1625****2441
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
}

func (s CancelRecycleBinJobRequest) String() string {
	return dara.Prettify(s)
}

func (s CancelRecycleBinJobRequest) GoString() string {
	return s.String()
}

func (s *CancelRecycleBinJobRequest) GetJobId() *string {
	return s.JobId
}

func (s *CancelRecycleBinJobRequest) SetJobId(v string) *CancelRecycleBinJobRequest {
	s.JobId = &v
	return s
}

func (s *CancelRecycleBinJobRequest) Validate() error {
	return dara.Validate(s)
}

type iCancelRecycleBinJobResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *CancelRecycleBinJobResponseBody
	GetRequestId() *string
}

type CancelRecycleBinJobResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 98696EF0-1607-4E9D-B01D-F20930B6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CancelRecycleBinJobResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CancelRecycleBinJobResponseBody) GoString() string {
	return s.String()
}

func (s *CancelRecycleBinJobResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CancelRecycleBinJobResponseBody) SetRequestId(v string) *CancelRecycleBinJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *CancelRecycleBinJobResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCancelRecycleBinJobResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CancelRecycleBinJobResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CancelRecycleBinJobResponse
	GetStatusCode() *int32
	SetBody(v *CancelRecycleBinJobResponseBody) *CancelRecycleBinJobResponse
	GetBody() *CancelRecycleBinJobResponseBody
}

type CancelRecycleBinJobResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CancelRecycleBinJobResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CancelRecycleBinJobResponse) String() string {
	return dara.Prettify(s)
}

func (s CancelRecycleBinJobResponse) GoString() string {
	return s.String()
}

func (s *CancelRecycleBinJobResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CancelRecycleBinJobResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CancelRecycleBinJobResponse) GetBody() *CancelRecycleBinJobResponseBody {
	return s.Body
}

func (s *CancelRecycleBinJobResponse) SetHeaders(v map[string]*string) *CancelRecycleBinJobResponse {
	s.Headers = v
	return s
}

func (s *CancelRecycleBinJobResponse) SetStatusCode(v int32) *CancelRecycleBinJobResponse {
	s.StatusCode = &v
	return s
}

func (s *CancelRecycleBinJobResponse) SetBody(v *CancelRecycleBinJobResponseBody) *CancelRecycleBinJobResponse {
	s.Body = v
	return s
}

func (s *CancelRecycleBinJobResponse) Validate() error {
	return dara.Validate(s)
}

type iChangeResourceGroupRequest interface {
	dara.Model
	String() string
	GoString() string
	SetNewResourceGroupId(v string) *ChangeResourceGroupRequest
	GetNewResourceGroupId() *string
	SetRegionId(v string) *ChangeResourceGroupRequest
	GetRegionId() *string
	SetResourceId(v string) *ChangeResourceGroupRequest
	GetResourceId() *string
	SetResourceType(v string) *ChangeResourceGroupRequest
	GetResourceType() *string
}

type ChangeResourceGroupRequest struct {
	// The ID of the new resource group.
	//
	// You can log on to the [Resource Management console](https://resourcemanager.console.aliyun.com/resource-groups?) to view resource group IDs.
	//
	// This parameter is required.
	//
	// example:
	//
	// rg-acfmwavnfdf****
	NewResourceGroupId *string `json:"NewResourceGroupId,omitempty" xml:"NewResourceGroupId,omitempty"`
	// The region ID of the zone.
	//
	// You can call the [DescribeRegions](https://help.aliyun.com/document_detail/2412111.html) operation to query the latest region list.
	//
	// example:
	//
	// cn-hangzhou
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// 31a8e4****
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The resource type.
	//
	// Set the value to filesystem.
	//
	// This parameter is required.
	//
	// example:
	//
	// filesystem
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s ChangeResourceGroupRequest) String() string {
	return dara.Prettify(s)
}

func (s ChangeResourceGroupRequest) GoString() string {
	return s.String()
}

func (s *ChangeResourceGroupRequest) GetNewResourceGroupId() *string {
	return s.NewResourceGroupId
}

func (s *ChangeResourceGroupRequest) GetRegionId() *string {
	return s.RegionId
}

func (s *ChangeResourceGroupRequest) GetResourceId() *string {
	return s.ResourceId
}

func (s *ChangeResourceGroupRequest) GetResourceType() *string {
	return s.ResourceType
}

func (s *ChangeResourceGroupRequest) SetNewResourceGroupId(v string) *ChangeResourceGroupRequest {
	s.NewResourceGroupId = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetRegionId(v string) *ChangeResourceGroupRequest {
	s.RegionId = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetResourceId(v string) *ChangeResourceGroupRequest {
	s.ResourceId = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetResourceType(v string) *ChangeResourceGroupRequest {
	s.ResourceType = &v
	return s
}

func (s *ChangeResourceGroupRequest) Validate() error {
	return dara.Validate(s)
}

type iChangeResourceGroupResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *ChangeResourceGroupResponseBody
	GetRequestId() *string
}

type ChangeResourceGroupResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// BC7C825C-5F65-4B56-BEF6-98C56C7C****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ChangeResourceGroupResponseBody) String() string {
	return dara.Prettify(s)
}

func (s ChangeResourceGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ChangeResourceGroupResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *ChangeResourceGroupResponseBody) SetRequestId(v string) *ChangeResourceGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *ChangeResourceGroupResponseBody) Validate() error {
	return dara.Validate(s)
}

type iChangeResourceGroupResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *ChangeResourceGroupResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *ChangeResourceGroupResponse
	GetStatusCode() *int32
	SetBody(v *ChangeResourceGroupResponseBody) *ChangeResourceGroupResponse
	GetBody() *ChangeResourceGroupResponseBody
}

type ChangeResourceGroupResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ChangeResourceGroupResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ChangeResourceGroupResponse) String() string {
	return dara.Prettify(s)
}

func (s ChangeResourceGroupResponse) GoString() string {
	return s.String()
}

func (s *ChangeResourceGroupResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *ChangeResourceGroupResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *ChangeResourceGroupResponse) GetBody() *ChangeResourceGroupResponseBody {
	return s.Body
}

func (s *ChangeResourceGroupResponse) SetHeaders(v map[string]*string) *ChangeResourceGroupResponse {
	s.Headers = v
	return s
}

func (s *ChangeResourceGroupResponse) SetStatusCode(v int32) *ChangeResourceGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ChangeResourceGroupResponse) SetBody(v *ChangeResourceGroupResponseBody) *ChangeResourceGroupResponse {
	s.Body = v
	return s
}

func (s *ChangeResourceGroupResponse) Validate() error {
	return dara.Validate(s)
}

type iCreateAccessGroupRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAccessGroupName(v string) *CreateAccessGroupRequest
	GetAccessGroupName() *string
	SetAccessGroupType(v string) *CreateAccessGroupRequest
	GetAccessGroupType() *string
	SetDescription(v string) *CreateAccessGroupRequest
	GetDescription() *string
	SetFileSystemType(v string) *CreateAccessGroupRequest
	GetFileSystemType() *string
}

type CreateAccessGroupRequest struct {
	// The name of the permission group.
	//
	// Limits:
	//
	// 	- The name must be 3 to 64 characters in length.
	//
	// 	- The name must start with a letter and can contain letters, digits, underscores (_), and hyphens (-).
	//
	// 	- The name must be different from the name of the default permission group.
	//
	// The default permission group for virtual private clouds (VPCs) is named DEFAULT_VPC_GROUP_NAME.
	//
	// This parameter is required.
	//
	// example:
	//
	// vpc-test
	AccessGroupName *string `json:"AccessGroupName,omitempty" xml:"AccessGroupName,omitempty"`
	// The network type of the permission group. Valid value: **Vpc**.
	//
	// This parameter is required.
	//
	// example:
	//
	// Vpc
	AccessGroupType *string `json:"AccessGroupType,omitempty" xml:"AccessGroupType,omitempty"`
	// The description of the permission group.
	//
	// Limits:
	//
	// 	- By default, the description of a permission group is the same as the name of the permission group. The description must be 2 to 128 characters in length.
	//
	// 	- The name must start with a letter and cannot start with `http://` or `https://`.
	//
	// 	- The description can contain digits, colons (:), underscores (_), and hyphens (-).
	//
	// example:
	//
	// vpctestaccessgroup
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The type of the file system.
	//
	// Valid values:
	//
	// 	- standard (default): General-purpose NAS file system
	//
	// 	- extreme: Extreme NAS file system
	//
	// example:
	//
	// standard
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
}

func (s CreateAccessGroupRequest) String() string {
	return dara.Prettify(s)
}

func (s CreateAccessGroupRequest) GoString() string {
	return s.String()
}

func (s *CreateAccessGroupRequest) GetAccessGroupName() *string {
	return s.AccessGroupName
}

func (s *CreateAccessGroupRequest) GetAccessGroupType() *string {
	return s.AccessGroupType
}

func (s *CreateAccessGroupRequest) GetDescription() *string {
	return s.Description
}

func (s *CreateAccessGroupRequest) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *CreateAccessGroupRequest) SetAccessGroupName(v string) *CreateAccessGroupRequest {
	s.AccessGroupName = &v
	return s
}

func (s *CreateAccessGroupRequest) SetAccessGroupType(v string) *CreateAccessGroupRequest {
	s.AccessGroupType = &v
	return s
}

func (s *CreateAccessGroupRequest) SetDescription(v string) *CreateAccessGroupRequest {
	s.Description = &v
	return s
}

func (s *CreateAccessGroupRequest) SetFileSystemType(v string) *CreateAccessGroupRequest {
	s.FileSystemType = &v
	return s
}

func (s *CreateAccessGroupRequest) Validate() error {
	return dara.Validate(s)
}

type iCreateAccessGroupResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetAccessGroupName(v string) *CreateAccessGroupResponseBody
	GetAccessGroupName() *string
	SetRequestId(v string) *CreateAccessGroupResponseBody
	GetRequestId() *string
}

type CreateAccessGroupResponseBody struct {
	// The name of the permission group.
	//
	// example:
	//
	// vpc-test
	AccessGroupName *string `json:"AccessGroupName,omitempty" xml:"AccessGroupName,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 55C5FFD6-BF99-41BD-9C66-FFF39189F4F8
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateAccessGroupResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CreateAccessGroupResponseBody) GoString() string {
	return s.String()
}

func (s *CreateAccessGroupResponseBody) GetAccessGroupName() *string {
	return s.AccessGroupName
}

func (s *CreateAccessGroupResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CreateAccessGroupResponseBody) SetAccessGroupName(v string) *CreateAccessGroupResponseBody {
	s.AccessGroupName = &v
	return s
}

func (s *CreateAccessGroupResponseBody) SetRequestId(v string) *CreateAccessGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateAccessGroupResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCreateAccessGroupResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CreateAccessGroupResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CreateAccessGroupResponse
	GetStatusCode() *int32
	SetBody(v *CreateAccessGroupResponseBody) *CreateAccessGroupResponse
	GetBody() *CreateAccessGroupResponseBody
}

type CreateAccessGroupResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateAccessGroupResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateAccessGroupResponse) String() string {
	return dara.Prettify(s)
}

func (s CreateAccessGroupResponse) GoString() string {
	return s.String()
}

func (s *CreateAccessGroupResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CreateAccessGroupResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CreateAccessGroupResponse) GetBody() *CreateAccessGroupResponseBody {
	return s.Body
}

func (s *CreateAccessGroupResponse) SetHeaders(v map[string]*string) *CreateAccessGroupResponse {
	s.Headers = v
	return s
}

func (s *CreateAccessGroupResponse) SetStatusCode(v int32) *CreateAccessGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateAccessGroupResponse) SetBody(v *CreateAccessGroupResponseBody) *CreateAccessGroupResponse {
	s.Body = v
	return s
}

func (s *CreateAccessGroupResponse) Validate() error {
	return dara.Validate(s)
}

type iCreateAccessPointRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAccessGroup(v string) *CreateAccessPointRequest
	GetAccessGroup() *string
	SetAccessPointName(v string) *CreateAccessPointRequest
	GetAccessPointName() *string
	SetEnabledRam(v bool) *CreateAccessPointRequest
	GetEnabledRam() *bool
	SetFileSystemId(v string) *CreateAccessPointRequest
	GetFileSystemId() *string
	SetOwnerGroupId(v int32) *CreateAccessPointRequest
	GetOwnerGroupId() *int32
	SetOwnerUserId(v int32) *CreateAccessPointRequest
	GetOwnerUserId() *int32
	SetPermission(v string) *CreateAccessPointRequest
	GetPermission() *string
	SetPosixGroupId(v int32) *CreateAccessPointRequest
	GetPosixGroupId() *int32
	SetPosixSecondaryGroupIds(v string) *CreateAccessPointRequest
	GetPosixSecondaryGroupIds() *string
	SetPosixUserId(v int32) *CreateAccessPointRequest
	GetPosixUserId() *int32
	SetProtocolType(v string) *CreateAccessPointRequest
	GetProtocolType() *string
	SetRootDirectory(v string) *CreateAccessPointRequest
	GetRootDirectory() *string
	SetVpcId(v string) *CreateAccessPointRequest
	GetVpcId() *string
	SetVswId(v string) *CreateAccessPointRequest
	GetVswId() *string
}

type CreateAccessPointRequest struct {
	// The name of the permission group.
	//
	// This parameter is required for a General-purpose File Storage NAS (NAS) file system.
	//
	// The default permission group for virtual private clouds (VPCs) is named DEFAULT_VPC_GROUP_NAME.
	//
	// This parameter is required.
	//
	// example:
	//
	// DEFAULT_VPC_GROUP_NAME
	AccessGroup *string `json:"AccessGroup,omitempty" xml:"AccessGroup,omitempty"`
	// The name of the access point.
	//
	// example:
	//
	// test
	AccessPointName *string `json:"AccessPointName,omitempty" xml:"AccessPointName,omitempty"`
	// Specifies whether to enable the RAM policy. Valid values:
	//
	// 	- true: The RAM policy is enabled.
	//
	// 	- false (default): The RAM policy is disabled.
	//
	// >  After the RAM policy is enabled for access points, no RAM user is allowed to use access points to mount and access data by default. To use access points to mount and access data as a RAM user, you must grant the related access permissions to the RAM user. If the RAM policy is disabled, access points can be anonymously mounted. For more information about how to configure permissions on access points, see [Configure a policy for the access point](https://help.aliyun.com/document_detail/2545998.html).
	//
	// example:
	//
	// false
	EnabledRam *bool `json:"EnabledRam,omitempty" xml:"EnabledRam,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 31a8e4****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The ID of the owner group.
	//
	// This parameter is required if the RootDirectory directory does not exist.
	//
	// example:
	//
	// 1
	OwnerGroupId *int32 `json:"OwnerGroupId,omitempty" xml:"OwnerGroupId,omitempty"`
	// The owner ID.
	//
	// This parameter is required if the RootDirectory directory does not exist.
	//
	// example:
	//
	// 1
	OwnerUserId *int32 `json:"OwnerUserId,omitempty" xml:"OwnerUserId,omitempty"`
	// The Portable Operating System Interface for UNIX (POSIX) permission. Default value: 0777.
	//
	// This field takes effect only if you specify the OwnerUserId and OwnerGroupId parameters.
	//
	// example:
	//
	// 0777
	Permission *string `json:"Permission,omitempty" xml:"Permission,omitempty"`
	// The ID of the POSIX user group.
	//
	// example:
	//
	// 123
	PosixGroupId *int32 `json:"PosixGroupId,omitempty" xml:"PosixGroupId,omitempty"`
	// The secondary user group. Separate multiple user group IDs with commas (,).
	//
	// example:
	//
	// 123,345
	PosixSecondaryGroupIds *string `json:"PosixSecondaryGroupIds,omitempty" xml:"PosixSecondaryGroupIds,omitempty"`
	// The ID of the POSIX user.
	//
	// example:
	//
	// 123
	PosixUserId  *int32  `json:"PosixUserId,omitempty" xml:"PosixUserId,omitempty"`
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The root directory of the access point. The default value is /. If the directory does not exist, you must also specify the OwnerUserId and OwnerGroupId parameters.
	//
	// example:
	//
	// /
	RootDirectory *string `json:"RootDirectory,omitempty" xml:"RootDirectory,omitempty"`
	// The VPC ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// vpc-2zesj9afh3y518k9o****
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The vSwitch ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// vsw-2zevmwkwyztjuoffg****
	VswId *string `json:"VswId,omitempty" xml:"VswId,omitempty"`
}

func (s CreateAccessPointRequest) String() string {
	return dara.Prettify(s)
}

func (s CreateAccessPointRequest) GoString() string {
	return s.String()
}

func (s *CreateAccessPointRequest) GetAccessGroup() *string {
	return s.AccessGroup
}

func (s *CreateAccessPointRequest) GetAccessPointName() *string {
	return s.AccessPointName
}

func (s *CreateAccessPointRequest) GetEnabledRam() *bool {
	return s.EnabledRam
}

func (s *CreateAccessPointRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *CreateAccessPointRequest) GetOwnerGroupId() *int32 {
	return s.OwnerGroupId
}

func (s *CreateAccessPointRequest) GetOwnerUserId() *int32 {
	return s.OwnerUserId
}

func (s *CreateAccessPointRequest) GetPermission() *string {
	return s.Permission
}

func (s *CreateAccessPointRequest) GetPosixGroupId() *int32 {
	return s.PosixGroupId
}

func (s *CreateAccessPointRequest) GetPosixSecondaryGroupIds() *string {
	return s.PosixSecondaryGroupIds
}

func (s *CreateAccessPointRequest) GetPosixUserId() *int32 {
	return s.PosixUserId
}

func (s *CreateAccessPointRequest) GetProtocolType() *string {
	return s.ProtocolType
}

func (s *CreateAccessPointRequest) GetRootDirectory() *string {
	return s.RootDirectory
}

func (s *CreateAccessPointRequest) GetVpcId() *string {
	return s.VpcId
}

func (s *CreateAccessPointRequest) GetVswId() *string {
	return s.VswId
}

func (s *CreateAccessPointRequest) SetAccessGroup(v string) *CreateAccessPointRequest {
	s.AccessGroup = &v
	return s
}

func (s *CreateAccessPointRequest) SetAccessPointName(v string) *CreateAccessPointRequest {
	s.AccessPointName = &v
	return s
}

func (s *CreateAccessPointRequest) SetEnabledRam(v bool) *CreateAccessPointRequest {
	s.EnabledRam = &v
	return s
}

func (s *CreateAccessPointRequest) SetFileSystemId(v string) *CreateAccessPointRequest {
	s.FileSystemId = &v
	return s
}

func (s *CreateAccessPointRequest) SetOwnerGroupId(v int32) *CreateAccessPointRequest {
	s.OwnerGroupId = &v
	return s
}

func (s *CreateAccessPointRequest) SetOwnerUserId(v int32) *CreateAccessPointRequest {
	s.OwnerUserId = &v
	return s
}

func (s *CreateAccessPointRequest) SetPermission(v string) *CreateAccessPointRequest {
	s.Permission = &v
	return s
}

func (s *CreateAccessPointRequest) SetPosixGroupId(v int32) *CreateAccessPointRequest {
	s.PosixGroupId = &v
	return s
}

func (s *CreateAccessPointRequest) SetPosixSecondaryGroupIds(v string) *CreateAccessPointRequest {
	s.PosixSecondaryGroupIds = &v
	return s
}

func (s *CreateAccessPointRequest) SetPosixUserId(v int32) *CreateAccessPointRequest {
	s.PosixUserId = &v
	return s
}

func (s *CreateAccessPointRequest) SetProtocolType(v string) *CreateAccessPointRequest {
	s.ProtocolType = &v
	return s
}

func (s *CreateAccessPointRequest) SetRootDirectory(v string) *CreateAccessPointRequest {
	s.RootDirectory = &v
	return s
}

func (s *CreateAccessPointRequest) SetVpcId(v string) *CreateAccessPointRequest {
	s.VpcId = &v
	return s
}

func (s *CreateAccessPointRequest) SetVswId(v string) *CreateAccessPointRequest {
	s.VswId = &v
	return s
}

func (s *CreateAccessPointRequest) Validate() error {
	return dara.Validate(s)
}

type iCreateAccessPointResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetAccessPoint(v *CreateAccessPointResponseBodyAccessPoint) *CreateAccessPointResponseBody
	GetAccessPoint() *CreateAccessPointResponseBodyAccessPoint
	SetRequestId(v string) *CreateAccessPointResponseBody
	GetRequestId() *string
}

type CreateAccessPointResponseBody struct {
	// The access point.
	AccessPoint *CreateAccessPointResponseBodyAccessPoint `json:"AccessPoint,omitempty" xml:"AccessPoint,omitempty" type:"Struct"`
	// The request ID.
	//
	// example:
	//
	// 98696EF0-1607-4E9D-B01D-F20930B6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateAccessPointResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CreateAccessPointResponseBody) GoString() string {
	return s.String()
}

func (s *CreateAccessPointResponseBody) GetAccessPoint() *CreateAccessPointResponseBodyAccessPoint {
	return s.AccessPoint
}

func (s *CreateAccessPointResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CreateAccessPointResponseBody) SetAccessPoint(v *CreateAccessPointResponseBodyAccessPoint) *CreateAccessPointResponseBody {
	s.AccessPoint = v
	return s
}

func (s *CreateAccessPointResponseBody) SetRequestId(v string) *CreateAccessPointResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateAccessPointResponseBody) Validate() error {
	return dara.Validate(s)
}

type CreateAccessPointResponseBodyAccessPoint struct {
	// The domain name of the access point.
	//
	// example:
	//
	// ap-ie15ydanoz.001014****-w****.cn-hangzhou.nas.aliyuncs.com
	AccessPointDomain *string `json:"AccessPointDomain,omitempty" xml:"AccessPointDomain,omitempty"`
	// The ID of the access point.
	//
	// example:
	//
	// ap-ie15yd****
	AccessPointId *string `json:"AccessPointId,omitempty" xml:"AccessPointId,omitempty"`
}

func (s CreateAccessPointResponseBodyAccessPoint) String() string {
	return dara.Prettify(s)
}

func (s CreateAccessPointResponseBodyAccessPoint) GoString() string {
	return s.String()
}

func (s *CreateAccessPointResponseBodyAccessPoint) GetAccessPointDomain() *string {
	return s.AccessPointDomain
}

func (s *CreateAccessPointResponseBodyAccessPoint) GetAccessPointId() *string {
	return s.AccessPointId
}

func (s *CreateAccessPointResponseBodyAccessPoint) SetAccessPointDomain(v string) *CreateAccessPointResponseBodyAccessPoint {
	s.AccessPointDomain = &v
	return s
}

func (s *CreateAccessPointResponseBodyAccessPoint) SetAccessPointId(v string) *CreateAccessPointResponseBodyAccessPoint {
	s.AccessPointId = &v
	return s
}

func (s *CreateAccessPointResponseBodyAccessPoint) Validate() error {
	return dara.Validate(s)
}

type iCreateAccessPointResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CreateAccessPointResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CreateAccessPointResponse
	GetStatusCode() *int32
	SetBody(v *CreateAccessPointResponseBody) *CreateAccessPointResponse
	GetBody() *CreateAccessPointResponseBody
}

type CreateAccessPointResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateAccessPointResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateAccessPointResponse) String() string {
	return dara.Prettify(s)
}

func (s CreateAccessPointResponse) GoString() string {
	return s.String()
}

func (s *CreateAccessPointResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CreateAccessPointResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CreateAccessPointResponse) GetBody() *CreateAccessPointResponseBody {
	return s.Body
}

func (s *CreateAccessPointResponse) SetHeaders(v map[string]*string) *CreateAccessPointResponse {
	s.Headers = v
	return s
}

func (s *CreateAccessPointResponse) SetStatusCode(v int32) *CreateAccessPointResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateAccessPointResponse) SetBody(v *CreateAccessPointResponseBody) *CreateAccessPointResponse {
	s.Body = v
	return s
}

func (s *CreateAccessPointResponse) Validate() error {
	return dara.Validate(s)
}

type iCreateAccessRuleRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAccessGroupName(v string) *CreateAccessRuleRequest
	GetAccessGroupName() *string
	SetFileSystemType(v string) *CreateAccessRuleRequest
	GetFileSystemType() *string
	SetIpv6SourceCidrIp(v string) *CreateAccessRuleRequest
	GetIpv6SourceCidrIp() *string
	SetPriority(v int32) *CreateAccessRuleRequest
	GetPriority() *int32
	SetRWAccessType(v string) *CreateAccessRuleRequest
	GetRWAccessType() *string
	SetSourceCidrIp(v string) *CreateAccessRuleRequest
	GetSourceCidrIp() *string
	SetUserAccessType(v string) *CreateAccessRuleRequest
	GetUserAccessType() *string
}

type CreateAccessRuleRequest struct {
	// The name of the permission group.
	//
	// This parameter is required.
	//
	// example:
	//
	// vpc-test
	AccessGroupName *string `json:"AccessGroupName,omitempty" xml:"AccessGroupName,omitempty"`
	// The type of the file system.
	//
	// Valid values:
	//
	// 	- standard (default): General-purpose NAS file system
	//
	// 	- extreme: Extreme NAS file system
	//
	// example:
	//
	// standard
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
	// The IPv6 address or CIDR block of the authorized object.
	//
	// You must set this parameter to an IPv6 address or CIDR block.
	//
	// > 	- Only Extreme NAS file systems that reside in the Chinese mainland support IPv6. If you specify this parameter, you must enable IPv6 for the file system.
	//
	// >	- Only permission groups that reside in virtual private clouds (VPCs) support IPv6.
	//
	// >	- You cannot specify an IPv4 address and an IPv6 address at the same time.
	//
	// example:
	//
	// 2001:250:6000::***
	Ipv6SourceCidrIp *string `json:"Ipv6SourceCidrIp,omitempty" xml:"Ipv6SourceCidrIp,omitempty"`
	// The priority of the rule.
	//
	// The rule with the highest priority takes effect if multiple rules are attached to the authorized object.
	//
	// Valid values: 1 to 100. The value 1 indicates the highest priority.
	//
	// example:
	//
	// 1
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The access permissions of the authorized object on the file system.
	//
	// Valid values:
	//
	// 	- RDWR (default): the read and write permissions
	//
	// 	- RDONLY: the read-only permissions
	//
	// example:
	//
	// RDWR
	RWAccessType *string `json:"RWAccessType,omitempty" xml:"RWAccessType,omitempty"`
	// The IP address or CIDR block of the authorized object.
	//
	// You must set this parameter to an IP address or CIDR block.
	//
	// > If the permission group resides in the classic network, you must set this parameter to an IP address.
	//
	// example:
	//
	// 192.0.2.0/16
	SourceCidrIp *string `json:"SourceCidrIp,omitempty" xml:"SourceCidrIp,omitempty"`
	// The access permissions for different types of users in the authorized object.
	//
	// Valid values:
	//
	// 	- no_squash (default): grants root users the permissions to access the file system.
	//
	// 	- root_squash: grants root users the least permissions as the nobody user.
	//
	// 	- all_squash: grants all users the least permissions as the nobody user.
	//
	// The nobody user has the least permissions in Linux and can access only the public content of the file system. This ensures the security of the file system.
	//
	// example:
	//
	// no_squash
	UserAccessType *string `json:"UserAccessType,omitempty" xml:"UserAccessType,omitempty"`
}

func (s CreateAccessRuleRequest) String() string {
	return dara.Prettify(s)
}

func (s CreateAccessRuleRequest) GoString() string {
	return s.String()
}

func (s *CreateAccessRuleRequest) GetAccessGroupName() *string {
	return s.AccessGroupName
}

func (s *CreateAccessRuleRequest) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *CreateAccessRuleRequest) GetIpv6SourceCidrIp() *string {
	return s.Ipv6SourceCidrIp
}

func (s *CreateAccessRuleRequest) GetPriority() *int32 {
	return s.Priority
}

func (s *CreateAccessRuleRequest) GetRWAccessType() *string {
	return s.RWAccessType
}

func (s *CreateAccessRuleRequest) GetSourceCidrIp() *string {
	return s.SourceCidrIp
}

func (s *CreateAccessRuleRequest) GetUserAccessType() *string {
	return s.UserAccessType
}

func (s *CreateAccessRuleRequest) SetAccessGroupName(v string) *CreateAccessRuleRequest {
	s.AccessGroupName = &v
	return s
}

func (s *CreateAccessRuleRequest) SetFileSystemType(v string) *CreateAccessRuleRequest {
	s.FileSystemType = &v
	return s
}

func (s *CreateAccessRuleRequest) SetIpv6SourceCidrIp(v string) *CreateAccessRuleRequest {
	s.Ipv6SourceCidrIp = &v
	return s
}

func (s *CreateAccessRuleRequest) SetPriority(v int32) *CreateAccessRuleRequest {
	s.Priority = &v
	return s
}

func (s *CreateAccessRuleRequest) SetRWAccessType(v string) *CreateAccessRuleRequest {
	s.RWAccessType = &v
	return s
}

func (s *CreateAccessRuleRequest) SetSourceCidrIp(v string) *CreateAccessRuleRequest {
	s.SourceCidrIp = &v
	return s
}

func (s *CreateAccessRuleRequest) SetUserAccessType(v string) *CreateAccessRuleRequest {
	s.UserAccessType = &v
	return s
}

func (s *CreateAccessRuleRequest) Validate() error {
	return dara.Validate(s)
}

type iCreateAccessRuleResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetAccessRuleId(v string) *CreateAccessRuleResponseBody
	GetAccessRuleId() *string
	SetRequestId(v string) *CreateAccessRuleResponseBody
	GetRequestId() *string
}

type CreateAccessRuleResponseBody struct {
	// The rule ID.
	//
	// example:
	//
	// 1
	AccessRuleId *string `json:"AccessRuleId,omitempty" xml:"AccessRuleId,omitempty"`
	// The request ID.
	//
	// example:
	//
	// A323836B-5BC6-45A6-8048-60675C23****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateAccessRuleResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CreateAccessRuleResponseBody) GoString() string {
	return s.String()
}

func (s *CreateAccessRuleResponseBody) GetAccessRuleId() *string {
	return s.AccessRuleId
}

func (s *CreateAccessRuleResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CreateAccessRuleResponseBody) SetAccessRuleId(v string) *CreateAccessRuleResponseBody {
	s.AccessRuleId = &v
	return s
}

func (s *CreateAccessRuleResponseBody) SetRequestId(v string) *CreateAccessRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateAccessRuleResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCreateAccessRuleResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CreateAccessRuleResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CreateAccessRuleResponse
	GetStatusCode() *int32
	SetBody(v *CreateAccessRuleResponseBody) *CreateAccessRuleResponse
	GetBody() *CreateAccessRuleResponseBody
}

type CreateAccessRuleResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateAccessRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateAccessRuleResponse) String() string {
	return dara.Prettify(s)
}

func (s CreateAccessRuleResponse) GoString() string {
	return s.String()
}

func (s *CreateAccessRuleResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CreateAccessRuleResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CreateAccessRuleResponse) GetBody() *CreateAccessRuleResponseBody {
	return s.Body
}

func (s *CreateAccessRuleResponse) SetHeaders(v map[string]*string) *CreateAccessRuleResponse {
	s.Headers = v
	return s
}

func (s *CreateAccessRuleResponse) SetStatusCode(v int32) *CreateAccessRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateAccessRuleResponse) SetBody(v *CreateAccessRuleResponseBody) *CreateAccessRuleResponse {
	s.Body = v
	return s
}

func (s *CreateAccessRuleResponse) Validate() error {
	return dara.Validate(s)
}

type iCreateAutoSnapshotPolicyRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAutoSnapshotPolicyName(v string) *CreateAutoSnapshotPolicyRequest
	GetAutoSnapshotPolicyName() *string
	SetFileSystemType(v string) *CreateAutoSnapshotPolicyRequest
	GetFileSystemType() *string
	SetRepeatWeekdays(v string) *CreateAutoSnapshotPolicyRequest
	GetRepeatWeekdays() *string
	SetRetentionDays(v int32) *CreateAutoSnapshotPolicyRequest
	GetRetentionDays() *int32
	SetTimePoints(v string) *CreateAutoSnapshotPolicyRequest
	GetTimePoints() *string
}

type CreateAutoSnapshotPolicyRequest struct {
	// The name of the automatic snapshot policy.
	//
	// Limits:
	//
	// 	- The name must be 2 to 128 characters in length.
	//
	// 	- The name must start with a letter.
	//
	// 	- The name can contain digits, colons (:), underscores (_), and hyphens (-). It cannot start with `http://` or `https://`.
	//
	// 	- This parameter is empty by default.
	//
	// example:
	//
	// FinanceJoshua
	AutoSnapshotPolicyName *string `json:"AutoSnapshotPolicyName,omitempty" xml:"AutoSnapshotPolicyName,omitempty"`
	// The type of the file system.
	//
	// Valid value: extreme, which indicates Extreme NAS file systems.
	//
	// This parameter is required.
	//
	// example:
	//
	// extreme
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
	// The days of a week on which to create automatic snapshots.
	//
	// Cycle: week.
	//
	// Valid values: 1 to 7. The values from 1 to 7 indicate the seven days in a week from Monday to Sunday.
	//
	// If you want to create multiple auto snapshots within a week, you can specify multiple days from Monday to Sunday and separate the days with commas (,). You can specify a maximum of seven days.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1,2,3
	RepeatWeekdays *string `json:"RepeatWeekdays,omitempty" xml:"RepeatWeekdays,omitempty"`
	// The retention period of auto snapshots.
	//
	// Unit: days.
	//
	// Valid values:
	//
	// 	- \\-1 (default). Auto snapshots are permanently retained. After the number of auto snapshots exceeds the upper limit, the earliest auto snapshot is automatically deleted.
	//
	// 	- 1 to 65536: Auto snapshots are retained for the specified days. After the retention period of auto snapshots expires, the auto snapshots are automatically deleted.
	//
	// example:
	//
	// 30
	RetentionDays *int32 `json:"RetentionDays,omitempty" xml:"RetentionDays,omitempty"`
	// The points in time at which auto snapshots were created.
	//
	// Unit: hours.
	//
	// Valid values: 0 to 23. The values from 0 to 23 indicate a total of 24 hours from 00:00 to 23:00. For example, the value 1 indicates 01:00.
	//
	// If you want to create multiple auto snapshots within a day, you can specify multiple points in time and separate the points in time with commas (,). You can specify a maximum of 24 points in time.
	//
	// This parameter is required.
	//
	// example:
	//
	// 0,1,…23
	TimePoints *string `json:"TimePoints,omitempty" xml:"TimePoints,omitempty"`
}

func (s CreateAutoSnapshotPolicyRequest) String() string {
	return dara.Prettify(s)
}

func (s CreateAutoSnapshotPolicyRequest) GoString() string {
	return s.String()
}

func (s *CreateAutoSnapshotPolicyRequest) GetAutoSnapshotPolicyName() *string {
	return s.AutoSnapshotPolicyName
}

func (s *CreateAutoSnapshotPolicyRequest) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *CreateAutoSnapshotPolicyRequest) GetRepeatWeekdays() *string {
	return s.RepeatWeekdays
}

func (s *CreateAutoSnapshotPolicyRequest) GetRetentionDays() *int32 {
	return s.RetentionDays
}

func (s *CreateAutoSnapshotPolicyRequest) GetTimePoints() *string {
	return s.TimePoints
}

func (s *CreateAutoSnapshotPolicyRequest) SetAutoSnapshotPolicyName(v string) *CreateAutoSnapshotPolicyRequest {
	s.AutoSnapshotPolicyName = &v
	return s
}

func (s *CreateAutoSnapshotPolicyRequest) SetFileSystemType(v string) *CreateAutoSnapshotPolicyRequest {
	s.FileSystemType = &v
	return s
}

func (s *CreateAutoSnapshotPolicyRequest) SetRepeatWeekdays(v string) *CreateAutoSnapshotPolicyRequest {
	s.RepeatWeekdays = &v
	return s
}

func (s *CreateAutoSnapshotPolicyRequest) SetRetentionDays(v int32) *CreateAutoSnapshotPolicyRequest {
	s.RetentionDays = &v
	return s
}

func (s *CreateAutoSnapshotPolicyRequest) SetTimePoints(v string) *CreateAutoSnapshotPolicyRequest {
	s.TimePoints = &v
	return s
}

func (s *CreateAutoSnapshotPolicyRequest) Validate() error {
	return dara.Validate(s)
}

type iCreateAutoSnapshotPolicyResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetAutoSnapshotPolicyId(v string) *CreateAutoSnapshotPolicyResponseBody
	GetAutoSnapshotPolicyId() *string
	SetRequestId(v string) *CreateAutoSnapshotPolicyResponseBody
	GetRequestId() *string
}

type CreateAutoSnapshotPolicyResponseBody struct {
	// The ID of the automatic snapshot policy.
	//
	// example:
	//
	// sp-extreme-233e6****
	AutoSnapshotPolicyId *string `json:"AutoSnapshotPolicyId,omitempty" xml:"AutoSnapshotPolicyId,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 473469C7-AA6F-4DC5-B3DB-A3DC0DE3****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateAutoSnapshotPolicyResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CreateAutoSnapshotPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *CreateAutoSnapshotPolicyResponseBody) GetAutoSnapshotPolicyId() *string {
	return s.AutoSnapshotPolicyId
}

func (s *CreateAutoSnapshotPolicyResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CreateAutoSnapshotPolicyResponseBody) SetAutoSnapshotPolicyId(v string) *CreateAutoSnapshotPolicyResponseBody {
	s.AutoSnapshotPolicyId = &v
	return s
}

func (s *CreateAutoSnapshotPolicyResponseBody) SetRequestId(v string) *CreateAutoSnapshotPolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateAutoSnapshotPolicyResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCreateAutoSnapshotPolicyResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CreateAutoSnapshotPolicyResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CreateAutoSnapshotPolicyResponse
	GetStatusCode() *int32
	SetBody(v *CreateAutoSnapshotPolicyResponseBody) *CreateAutoSnapshotPolicyResponse
	GetBody() *CreateAutoSnapshotPolicyResponseBody
}

type CreateAutoSnapshotPolicyResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateAutoSnapshotPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateAutoSnapshotPolicyResponse) String() string {
	return dara.Prettify(s)
}

func (s CreateAutoSnapshotPolicyResponse) GoString() string {
	return s.String()
}

func (s *CreateAutoSnapshotPolicyResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CreateAutoSnapshotPolicyResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CreateAutoSnapshotPolicyResponse) GetBody() *CreateAutoSnapshotPolicyResponseBody {
	return s.Body
}

func (s *CreateAutoSnapshotPolicyResponse) SetHeaders(v map[string]*string) *CreateAutoSnapshotPolicyResponse {
	s.Headers = v
	return s
}

func (s *CreateAutoSnapshotPolicyResponse) SetStatusCode(v int32) *CreateAutoSnapshotPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateAutoSnapshotPolicyResponse) SetBody(v *CreateAutoSnapshotPolicyResponseBody) *CreateAutoSnapshotPolicyResponse {
	s.Body = v
	return s
}

func (s *CreateAutoSnapshotPolicyResponse) Validate() error {
	return dara.Validate(s)
}

type iCreateDataFlowRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAutoRefreshInterval(v int64) *CreateDataFlowRequest
	GetAutoRefreshInterval() *int64
	SetAutoRefreshPolicy(v string) *CreateDataFlowRequest
	GetAutoRefreshPolicy() *string
	SetAutoRefreshs(v []*CreateDataFlowRequestAutoRefreshs) *CreateDataFlowRequest
	GetAutoRefreshs() []*CreateDataFlowRequestAutoRefreshs
	SetClientToken(v string) *CreateDataFlowRequest
	GetClientToken() *string
	SetDescription(v string) *CreateDataFlowRequest
	GetDescription() *string
	SetDryRun(v bool) *CreateDataFlowRequest
	GetDryRun() *bool
	SetFileSystemId(v string) *CreateDataFlowRequest
	GetFileSystemId() *string
	SetFileSystemPath(v string) *CreateDataFlowRequest
	GetFileSystemPath() *string
	SetFsetId(v string) *CreateDataFlowRequest
	GetFsetId() *string
	SetSourceSecurityType(v string) *CreateDataFlowRequest
	GetSourceSecurityType() *string
	SetSourceStorage(v string) *CreateDataFlowRequest
	GetSourceStorage() *string
	SetSourceStoragePath(v string) *CreateDataFlowRequest
	GetSourceStoragePath() *string
	SetThroughput(v int64) *CreateDataFlowRequest
	GetThroughput() *int64
}

type CreateDataFlowRequest struct {
	// The automatic update interval. CPFS checks whether data is updated in the directory at the interval specified by this parameter. If data is updated, CPFS starts an automatic update task. Unit: minutes.
	//
	// Valid values: 10 to 525600. Default value: 10.
	//
	// >  This parameter takes effect only for CPFS file systems.
	//
	// example:
	//
	// 10
	AutoRefreshInterval *int64 `json:"AutoRefreshInterval,omitempty" xml:"AutoRefreshInterval,omitempty"`
	// The automatic update policy. The updated data in the source storage is imported into the CPFS file system based on the policy.
	//
	// 	- None (default): Updated data in the source storage is not automatically imported into the CPFS file system. You can run a data flow task to import the updated data from the source storage.
	//
	// 	- ImportChanged: Updated data in the source storage is automatically imported into the CPFS file system.
	//
	// >  This parameter takes effect only for CPFS file systems.
	//
	// example:
	//
	// None
	AutoRefreshPolicy *string `json:"AutoRefreshPolicy,omitempty" xml:"AutoRefreshPolicy,omitempty"`
	// The automatic update configurations.
	//
	// >  This parameter takes effect only for CPFS file systems.
	//
	// if can be null:
	// false
	AutoRefreshs []*CreateDataFlowRequestAutoRefreshs `json:"AutoRefreshs,omitempty" xml:"AutoRefreshs,omitempty" type:"Repeated"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// >  If you do not specify this parameter, the system automatically uses the request ID as the client token. The value of RequestId may be different for each API request.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-42665544****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the dataflow.
	//
	// Limits:
	//
	// 	- The description must be 2 to 128 characters in length.
	//
	// 	- The description must start with a letter but cannot start with `http://` or `https://`.
	//
	// 	- The description can contain letters, digits, colons (:), underscores (_), and hyphens (-).
	//
	// example:
	//
	// Bucket01 DataFlow
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to perform a dry run.
	//
	// During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no file system is created and no fee is incurred.
	//
	// Valid values:
	//
	// 	- true: performs a dry run. The system checks the required parameters, request syntax, limits, and available NAS resources. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the FileSystemId parameter.
	//
	// 	- false (default): performs a dry run and sends the request. If the request passes the dry run, a file system is created.
	//
	// example:
	//
	// false
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the file system.
	//
	// 	- The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-125487\\*\\*\\*\\*.
	//
	// 	- The IDs of CPFS for LINGJUN file systems must start with `bmcpfs-`. Example: bmcpfs-0015\\*\\*\\*\\*.
	//
	// >  CPFS is not supported on the international site.
	//
	// This parameter is required.
	//
	// example:
	//
	// cpfs-099394bd928c****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The directory in the CPFS for LINGJUN file system. Limits:
	//
	// 	- The directory must start and end with a forward slash (/).
	//
	// 	- The directory must be an existing directory in the CPFS for LINGJUN file system.
	//
	// 	- The directory must be 1 to 1023 characters in length.
	//
	// 	- The directory must be encoded in UTF-8.
	//
	// >  This parameter is required for CPFS for LINGJUN file systems.
	//
	// example:
	//
	// /path/
	FileSystemPath *string `json:"FileSystemPath,omitempty" xml:"FileSystemPath,omitempty"`
	// The fileset ID.
	//
	// >  This parameter is required for CPFS file systems.
	//
	// example:
	//
	// fset-1902718ea0ae****
	FsetId *string `json:"FsetId,omitempty" xml:"FsetId,omitempty"`
	// The type of security mechanism for the source storage. This parameter must be specified if the source storage is accessed with a security mechanism. Valid values:
	//
	// 	- None (default): The source storage can be accessed without a security mechanism.
	//
	// 	- SSL: The source storage must be accessed with an SSL certificate.
	//
	// if can be null:
	// false
	//
	// example:
	//
	// SSL
	SourceSecurityType *string `json:"SourceSecurityType,omitempty" xml:"SourceSecurityType,omitempty"`
	// The access path of the source storage. Format: `<storage type>://[<account id>:]<path>`.
	//
	// Parameters:
	//
	// 	- storage type: Only OSS is supported.
	//
	// 	- account id (optional): the UID of the account of the source storage. This parameter is required when you use OSS buckets across accounts.
	//
	// 	- path: the name of the OSS bucket. Limits:
	//
	//     	- The name can contain only lowercase letters, digits, and hyphens (-). The name must start and end with a lowercase letter or digit.
	//
	//     	- The name can be up to 128 characters in length.
	//
	//     	- The name must be encoded in UTF-8.
	//
	// > 	- The OSS bucket must be an existing bucket in the region.
	//
	// > 	- Only CPFS for LINGJUN V2.6.0 and later support the account id parameter.
	//
	// This parameter is required.
	//
	// example:
	//
	// oss://bucket1
	SourceStorage *string `json:"SourceStorage,omitempty" xml:"SourceStorage,omitempty"`
	// The access path in the bucket of the source storage. Limits:
	//
	// 	- The path must start and end with a forward slash (/).
	//
	// 	- The path is case-sensitive.
	//
	// 	- The path must be 1 to 1023 characters in length.
	//
	// 	- The path must be encoded in UTF-8.
	//
	// >  This parameter is required for CPFS for LINGJUN file systems.
	//
	// example:
	//
	// /prefix/
	SourceStoragePath *string `json:"SourceStoragePath,omitempty" xml:"SourceStoragePath,omitempty"`
	// The maximum data flow throughput. Unit: MB/s. Valid values:
	//
	// 	- 600
	//
	// 	- 1200
	//
	// 	- 1500
	//
	// >  The data flow throughput must be less than the I/O throughput of the file system. This parameter is required for CPFS file systems.
	//
	// example:
	//
	// 600
	Throughput *int64 `json:"Throughput,omitempty" xml:"Throughput,omitempty"`
}

func (s CreateDataFlowRequest) String() string {
	return dara.Prettify(s)
}

func (s CreateDataFlowRequest) GoString() string {
	return s.String()
}

func (s *CreateDataFlowRequest) GetAutoRefreshInterval() *int64 {
	return s.AutoRefreshInterval
}

func (s *CreateDataFlowRequest) GetAutoRefreshPolicy() *string {
	return s.AutoRefreshPolicy
}

func (s *CreateDataFlowRequest) GetAutoRefreshs() []*CreateDataFlowRequestAutoRefreshs {
	return s.AutoRefreshs
}

func (s *CreateDataFlowRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *CreateDataFlowRequest) GetDescription() *string {
	return s.Description
}

func (s *CreateDataFlowRequest) GetDryRun() *bool {
	return s.DryRun
}

func (s *CreateDataFlowRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *CreateDataFlowRequest) GetFileSystemPath() *string {
	return s.FileSystemPath
}

func (s *CreateDataFlowRequest) GetFsetId() *string {
	return s.FsetId
}

func (s *CreateDataFlowRequest) GetSourceSecurityType() *string {
	return s.SourceSecurityType
}

func (s *CreateDataFlowRequest) GetSourceStorage() *string {
	return s.SourceStorage
}

func (s *CreateDataFlowRequest) GetSourceStoragePath() *string {
	return s.SourceStoragePath
}

func (s *CreateDataFlowRequest) GetThroughput() *int64 {
	return s.Throughput
}

func (s *CreateDataFlowRequest) SetAutoRefreshInterval(v int64) *CreateDataFlowRequest {
	s.AutoRefreshInterval = &v
	return s
}

func (s *CreateDataFlowRequest) SetAutoRefreshPolicy(v string) *CreateDataFlowRequest {
	s.AutoRefreshPolicy = &v
	return s
}

func (s *CreateDataFlowRequest) SetAutoRefreshs(v []*CreateDataFlowRequestAutoRefreshs) *CreateDataFlowRequest {
	s.AutoRefreshs = v
	return s
}

func (s *CreateDataFlowRequest) SetClientToken(v string) *CreateDataFlowRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateDataFlowRequest) SetDescription(v string) *CreateDataFlowRequest {
	s.Description = &v
	return s
}

func (s *CreateDataFlowRequest) SetDryRun(v bool) *CreateDataFlowRequest {
	s.DryRun = &v
	return s
}

func (s *CreateDataFlowRequest) SetFileSystemId(v string) *CreateDataFlowRequest {
	s.FileSystemId = &v
	return s
}

func (s *CreateDataFlowRequest) SetFileSystemPath(v string) *CreateDataFlowRequest {
	s.FileSystemPath = &v
	return s
}

func (s *CreateDataFlowRequest) SetFsetId(v string) *CreateDataFlowRequest {
	s.FsetId = &v
	return s
}

func (s *CreateDataFlowRequest) SetSourceSecurityType(v string) *CreateDataFlowRequest {
	s.SourceSecurityType = &v
	return s
}

func (s *CreateDataFlowRequest) SetSourceStorage(v string) *CreateDataFlowRequest {
	s.SourceStorage = &v
	return s
}

func (s *CreateDataFlowRequest) SetSourceStoragePath(v string) *CreateDataFlowRequest {
	s.SourceStoragePath = &v
	return s
}

func (s *CreateDataFlowRequest) SetThroughput(v int64) *CreateDataFlowRequest {
	s.Throughput = &v
	return s
}

func (s *CreateDataFlowRequest) Validate() error {
	return dara.Validate(s)
}

type CreateDataFlowRequestAutoRefreshs struct {
	// The automatic update directory. CPFS registers the data update event in the source storage, and automatically checks whether the source data in the directory is updated and imports the updated data.
	//
	// This parameter is empty by default. Updated data in the source storage is not automatically imported into the CPFS file system. You must import the updated data by running a manual task.
	//
	// Limits:
	//
	// 	- The directory must be 2 to 1,024 characters in length.
	//
	// 	- The directory must be encoded in UTF-8.
	//
	// 	- The directory must start and end with a forward slash (/).
	//
	// 	- The directory must be an existing directory in the CPFS file system and must be in a fileset where the data flow is enabled.
	//
	// if can be null:
	// true
	//
	// example:
	//
	// /prefix1/prefix2/
	RefreshPath *string `json:"RefreshPath,omitempty" xml:"RefreshPath,omitempty"`
}

func (s CreateDataFlowRequestAutoRefreshs) String() string {
	return dara.Prettify(s)
}

func (s CreateDataFlowRequestAutoRefreshs) GoString() string {
	return s.String()
}

func (s *CreateDataFlowRequestAutoRefreshs) GetRefreshPath() *string {
	return s.RefreshPath
}

func (s *CreateDataFlowRequestAutoRefreshs) SetRefreshPath(v string) *CreateDataFlowRequestAutoRefreshs {
	s.RefreshPath = &v
	return s
}

func (s *CreateDataFlowRequestAutoRefreshs) Validate() error {
	return dara.Validate(s)
}

type iCreateDataFlowResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetDataFlowId(v string) *CreateDataFlowResponseBody
	GetDataFlowId() *string
	SetRequestId(v string) *CreateDataFlowResponseBody
	GetRequestId() *string
}

type CreateDataFlowResponseBody struct {
	// The dataflow ID.
	//
	// example:
	//
	// df-194433a5be31****
	DataFlowId *string `json:"DataFlowId,omitempty" xml:"DataFlowId,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 473469C7-AA6F-4DC5-B3DB-A3DC0D****3E
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateDataFlowResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CreateDataFlowResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDataFlowResponseBody) GetDataFlowId() *string {
	return s.DataFlowId
}

func (s *CreateDataFlowResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CreateDataFlowResponseBody) SetDataFlowId(v string) *CreateDataFlowResponseBody {
	s.DataFlowId = &v
	return s
}

func (s *CreateDataFlowResponseBody) SetRequestId(v string) *CreateDataFlowResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDataFlowResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCreateDataFlowResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CreateDataFlowResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CreateDataFlowResponse
	GetStatusCode() *int32
	SetBody(v *CreateDataFlowResponseBody) *CreateDataFlowResponse
	GetBody() *CreateDataFlowResponseBody
}

type CreateDataFlowResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateDataFlowResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateDataFlowResponse) String() string {
	return dara.Prettify(s)
}

func (s CreateDataFlowResponse) GoString() string {
	return s.String()
}

func (s *CreateDataFlowResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CreateDataFlowResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CreateDataFlowResponse) GetBody() *CreateDataFlowResponseBody {
	return s.Body
}

func (s *CreateDataFlowResponse) SetHeaders(v map[string]*string) *CreateDataFlowResponse {
	s.Headers = v
	return s
}

func (s *CreateDataFlowResponse) SetStatusCode(v int32) *CreateDataFlowResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDataFlowResponse) SetBody(v *CreateDataFlowResponseBody) *CreateDataFlowResponse {
	s.Body = v
	return s
}

func (s *CreateDataFlowResponse) Validate() error {
	return dara.Validate(s)
}

type iCreateDataFlowSubTaskRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientToken(v string) *CreateDataFlowSubTaskRequest
	GetClientToken() *string
	SetCondition(v *CreateDataFlowSubTaskRequestCondition) *CreateDataFlowSubTaskRequest
	GetCondition() *CreateDataFlowSubTaskRequestCondition
	SetDataFlowId(v string) *CreateDataFlowSubTaskRequest
	GetDataFlowId() *string
	SetDataFlowTaskId(v string) *CreateDataFlowSubTaskRequest
	GetDataFlowTaskId() *string
	SetDryRun(v bool) *CreateDataFlowSubTaskRequest
	GetDryRun() *bool
	SetDstFilePath(v string) *CreateDataFlowSubTaskRequest
	GetDstFilePath() *string
	SetFileSystemId(v string) *CreateDataFlowSubTaskRequest
	GetFileSystemId() *string
	SetSrcFilePath(v string) *CreateDataFlowSubTaskRequest
	GetSrcFilePath() *string
}

type CreateDataFlowSubTaskRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// >  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-42665544****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The check conditions. The check must be passed after the following conditions are specified.
	Condition *CreateDataFlowSubTaskRequestCondition `json:"Condition,omitempty" xml:"Condition,omitempty" type:"Struct"`
	// The ID of the data flow.
	//
	// This parameter is required.
	//
	// example:
	//
	// df-194433a5be31****
	DataFlowId *string `json:"DataFlowId,omitempty" xml:"DataFlowId,omitempty"`
	// The ID of the data flow task.
	//
	// >  Only the IDs of data streaming tasks are supported.
	//
	// This parameter is required.
	//
	// example:
	//
	// task-38aa8e890f45****
	DataFlowTaskId *string `json:"DataFlowTaskId,omitempty" xml:"DataFlowTaskId,omitempty"`
	// Specifies whether to perform a dry run.
	//
	// During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no data streaming subtask is created and no fee is incurred.
	//
	// Valid values:
	//
	// 	- true: performs a dry run. The system checks the required parameters, request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the DataFlowSubTaskId parameter.
	//
	// 	- false (default): performs a dry run and sends the request. If the request passes the dry run, a data streaming subtask is created.
	//
	// example:
	//
	// false
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The path of the destination file. Limits:
	//
	// 	- The path must be 1 to 1,023 characters in length.
	//
	// 	- The path must be encoded in UTF-8.
	//
	// 	- The path must start with a forward slash (/).
	//
	// 	- The path must end with the file name.
	//
	// This parameter is required.
	//
	// example:
	//
	// /mnt/file.png
	DstFilePath *string `json:"DstFilePath,omitempty" xml:"DstFilePath,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// bmcpfs-370lx1ev9ss27o0****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The path of the source file. Limits:
	//
	// 	- The path must be 1 to 1,023 characters in length.
	//
	// 	- The path must be encoded in UTF-8.
	//
	// 	- The path must start with a forward slash (/).
	//
	// 	- The path must end with the file name.
	//
	// This parameter is required.
	//
	// example:
	//
	// /test/file.png
	SrcFilePath *string `json:"SrcFilePath,omitempty" xml:"SrcFilePath,omitempty"`
}

func (s CreateDataFlowSubTaskRequest) String() string {
	return dara.Prettify(s)
}

func (s CreateDataFlowSubTaskRequest) GoString() string {
	return s.String()
}

func (s *CreateDataFlowSubTaskRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *CreateDataFlowSubTaskRequest) GetCondition() *CreateDataFlowSubTaskRequestCondition {
	return s.Condition
}

func (s *CreateDataFlowSubTaskRequest) GetDataFlowId() *string {
	return s.DataFlowId
}

func (s *CreateDataFlowSubTaskRequest) GetDataFlowTaskId() *string {
	return s.DataFlowTaskId
}

func (s *CreateDataFlowSubTaskRequest) GetDryRun() *bool {
	return s.DryRun
}

func (s *CreateDataFlowSubTaskRequest) GetDstFilePath() *string {
	return s.DstFilePath
}

func (s *CreateDataFlowSubTaskRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *CreateDataFlowSubTaskRequest) GetSrcFilePath() *string {
	return s.SrcFilePath
}

func (s *CreateDataFlowSubTaskRequest) SetClientToken(v string) *CreateDataFlowSubTaskRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateDataFlowSubTaskRequest) SetCondition(v *CreateDataFlowSubTaskRequestCondition) *CreateDataFlowSubTaskRequest {
	s.Condition = v
	return s
}

func (s *CreateDataFlowSubTaskRequest) SetDataFlowId(v string) *CreateDataFlowSubTaskRequest {
	s.DataFlowId = &v
	return s
}

func (s *CreateDataFlowSubTaskRequest) SetDataFlowTaskId(v string) *CreateDataFlowSubTaskRequest {
	s.DataFlowTaskId = &v
	return s
}

func (s *CreateDataFlowSubTaskRequest) SetDryRun(v bool) *CreateDataFlowSubTaskRequest {
	s.DryRun = &v
	return s
}

func (s *CreateDataFlowSubTaskRequest) SetDstFilePath(v string) *CreateDataFlowSubTaskRequest {
	s.DstFilePath = &v
	return s
}

func (s *CreateDataFlowSubTaskRequest) SetFileSystemId(v string) *CreateDataFlowSubTaskRequest {
	s.FileSystemId = &v
	return s
}

func (s *CreateDataFlowSubTaskRequest) SetSrcFilePath(v string) *CreateDataFlowSubTaskRequest {
	s.SrcFilePath = &v
	return s
}

func (s *CreateDataFlowSubTaskRequest) Validate() error {
	return dara.Validate(s)
}

type CreateDataFlowSubTaskRequestCondition struct {
	// The modification time. The value must be a UNIX timestamp. Unit: ns.
	//
	// example:
	//
	// 1725897600000000000
	ModifyTime *int64 `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// The file size. Unit: bytes.
	//
	// example:
	//
	// 68
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
}

func (s CreateDataFlowSubTaskRequestCondition) String() string {
	return dara.Prettify(s)
}

func (s CreateDataFlowSubTaskRequestCondition) GoString() string {
	return s.String()
}

func (s *CreateDataFlowSubTaskRequestCondition) GetModifyTime() *int64 {
	return s.ModifyTime
}

func (s *CreateDataFlowSubTaskRequestCondition) GetSize() *int64 {
	return s.Size
}

func (s *CreateDataFlowSubTaskRequestCondition) SetModifyTime(v int64) *CreateDataFlowSubTaskRequestCondition {
	s.ModifyTime = &v
	return s
}

func (s *CreateDataFlowSubTaskRequestCondition) SetSize(v int64) *CreateDataFlowSubTaskRequestCondition {
	s.Size = &v
	return s
}

func (s *CreateDataFlowSubTaskRequestCondition) Validate() error {
	return dara.Validate(s)
}

type iCreateDataFlowSubTaskResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetDataFlowSubTaskId(v string) *CreateDataFlowSubTaskResponseBody
	GetDataFlowSubTaskId() *string
	SetRequestId(v string) *CreateDataFlowSubTaskResponseBody
	GetRequestId() *string
}

type CreateDataFlowSubTaskResponseBody struct {
	// The ID of the data streaming task.
	//
	// example:
	//
	// subTaskId-370kyfmyknxcyzw****
	DataFlowSubTaskId *string `json:"DataFlowSubTaskId,omitempty" xml:"DataFlowSubTaskId,omitempty"`
	// The request ID.
	//
	// example:
	//
	// A70BEE5D-76D3-49FB-B58F-1F398211A5C3
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateDataFlowSubTaskResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CreateDataFlowSubTaskResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDataFlowSubTaskResponseBody) GetDataFlowSubTaskId() *string {
	return s.DataFlowSubTaskId
}

func (s *CreateDataFlowSubTaskResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CreateDataFlowSubTaskResponseBody) SetDataFlowSubTaskId(v string) *CreateDataFlowSubTaskResponseBody {
	s.DataFlowSubTaskId = &v
	return s
}

func (s *CreateDataFlowSubTaskResponseBody) SetRequestId(v string) *CreateDataFlowSubTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDataFlowSubTaskResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCreateDataFlowSubTaskResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CreateDataFlowSubTaskResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CreateDataFlowSubTaskResponse
	GetStatusCode() *int32
	SetBody(v *CreateDataFlowSubTaskResponseBody) *CreateDataFlowSubTaskResponse
	GetBody() *CreateDataFlowSubTaskResponseBody
}

type CreateDataFlowSubTaskResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateDataFlowSubTaskResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateDataFlowSubTaskResponse) String() string {
	return dara.Prettify(s)
}

func (s CreateDataFlowSubTaskResponse) GoString() string {
	return s.String()
}

func (s *CreateDataFlowSubTaskResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CreateDataFlowSubTaskResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CreateDataFlowSubTaskResponse) GetBody() *CreateDataFlowSubTaskResponseBody {
	return s.Body
}

func (s *CreateDataFlowSubTaskResponse) SetHeaders(v map[string]*string) *CreateDataFlowSubTaskResponse {
	s.Headers = v
	return s
}

func (s *CreateDataFlowSubTaskResponse) SetStatusCode(v int32) *CreateDataFlowSubTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDataFlowSubTaskResponse) SetBody(v *CreateDataFlowSubTaskResponseBody) *CreateDataFlowSubTaskResponse {
	s.Body = v
	return s
}

func (s *CreateDataFlowSubTaskResponse) Validate() error {
	return dara.Validate(s)
}

type iCreateDataFlowTaskRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientToken(v string) *CreateDataFlowTaskRequest
	GetClientToken() *string
	SetConflictPolicy(v string) *CreateDataFlowTaskRequest
	GetConflictPolicy() *string
	SetCreateDirIfNotExist(v bool) *CreateDataFlowTaskRequest
	GetCreateDirIfNotExist() *bool
	SetDataFlowId(v string) *CreateDataFlowTaskRequest
	GetDataFlowId() *string
	SetDataType(v string) *CreateDataFlowTaskRequest
	GetDataType() *string
	SetDirectory(v string) *CreateDataFlowTaskRequest
	GetDirectory() *string
	SetDryRun(v bool) *CreateDataFlowTaskRequest
	GetDryRun() *bool
	SetDstDirectory(v string) *CreateDataFlowTaskRequest
	GetDstDirectory() *string
	SetEntryList(v string) *CreateDataFlowTaskRequest
	GetEntryList() *string
	SetFileSystemId(v string) *CreateDataFlowTaskRequest
	GetFileSystemId() *string
	SetSrcTaskId(v string) *CreateDataFlowTaskRequest
	GetSrcTaskId() *string
	SetTaskAction(v string) *CreateDataFlowTaskRequest
	GetTaskAction() *string
	SetTransferFileListPath(v string) *CreateDataFlowTaskRequest
	GetTransferFileListPath() *string
}

type CreateDataFlowTaskRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// >  If you do not specify this parameter, the system automatically uses the request ID as the client token. The value of RequestId may be different for each API request.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-42665544****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The conflict policy for files with the same name. Valid values:
	//
	// 	- SKIP_THE_FILE: skips files with the same name.
	//
	// 	- KEEP_LATEST: compares the update time and keeps the latest version.
	//
	// 	- OVERWRITE_EXISTING: forcibly overwrites the existing file.
	//
	// >  This parameter is required for CPFS for LINGJUN file systems.
	//
	// example:
	//
	// SKIP_THE_FILE
	ConflictPolicy *string `json:"ConflictPolicy,omitempty" xml:"ConflictPolicy,omitempty"`
	// Specifies whether to automatically create a directory if no directory exists. Valid values:
	//
	// 	- true: automatically creates a directory.
	//
	// 	- false (default): does not automatically create a directory.
	//
	// > - This parameter is required if the TaskAction parameter is set to Import.
	//
	// > - Only CPFS for LINGJUN V2.6.0 and later support this parameter.
	//
	// example:
	//
	// false
	CreateDirIfNotExist *bool `json:"CreateDirIfNotExist,omitempty" xml:"CreateDirIfNotExist,omitempty"`
	// The dataflow ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// df-194433a5be31****
	DataFlowId *string `json:"DataFlowId,omitempty" xml:"DataFlowId,omitempty"`
	// The type of data on which operations are performed by the dataflow task.
	//
	// Valid values:
	//
	// 	- Metadata: the metadata of a file, including the timestamp, ownership, and permission information of the file. If you select Metadata, only the metadata of the file is imported. You can only query the file. When you access the file data, the file is loaded from the source storage as required.
	//
	// 	- Data: the data blocks of a file.
	//
	// 	- MetaAndData: the metadata and data blocks of the file.
	//
	// example:
	//
	// Metadata
	DataType *string `json:"DataType,omitempty" xml:"DataType,omitempty"`
	// The source directory of the data.
	//
	// Limits:
	//
	// 	- The directory must be 1 to 1,023 characters in length.
	//
	// 	- The directory must be encoded in UTF-8.
	//
	// 	- The directory must start and end with a forward slash (/).
	//
	// 	- Only one directory can be listed at a time.
	//
	// 	- If the TaskAction parameter is set to Export, the directory must be a relative path within the FileSystemPath.
	//
	// 	- If the TaskAction parameter is set to Import, the directory must be a relative path within the SourceStoragePath.
	//
	// 	- If the TaskAction parameter is set to StreamExport, the directory must be a relative path within the FileSystemPath.
	//
	// 	- If the TaskAction parameter is set to StreamImport, the directory must be a relative path within the SourceStoragePath.
	//
	// >  Only CPFS for LINGJUN V2.6.0 and later support StreamImport and StreamExport.
	//
	// example:
	//
	// /path_in_cpfs/
	Directory *string `json:"Directory,omitempty" xml:"Directory,omitempty"`
	// Specifies whether to perform a dry run.
	//
	// During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no data flow task is created and no fee is incurred.
	//
	// Valid values:
	//
	// 	- true: performs a dry run. The system checks the required parameters, request syntax, service limits, and available File Storage NAS (NAS) resources. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the TaskId parameter.
	//
	// 	- false (default): performs a dry run and sends the request. If the request passes the dry run, a data flow task is created.
	//
	// example:
	//
	// false
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The directory mapped to the data flow task. Limits:
	//
	// 	- The directory must start and end with a forward slash (/). The directory cannot be /../.
	//
	// 	- The directory must be 1 to 1,023 characters in length.
	//
	// 	- The directory must be encoded in UTF-8.
	//
	// 	- Only one directory can be listed at a time.
	//
	// 	- If the TaskAction parameter is set to Export, the directory must be a relative path within the SourceStoragePath.
	//
	// 	- If the TaskAction parameter is set to Import, the directory must be a relative path within the FileSystemPath.
	//
	// 	- If the TaskAction parameter is set to StreamExport, the directory must be a relative path within the SourceStoragePath.
	//
	// 	- If the TaskAction parameter is set to StreamImport, the directory must be a relative path within the FileSystemPath.
	//
	// >  Only CPFS for LINGJUN V2.6.0 and later support StreamImport and StreamExport.
	//
	// example:
	//
	// /path_in_cpfs/
	DstDirectory *string `json:"DstDirectory,omitempty" xml:"DstDirectory,omitempty"`
	// The list of files that are executed by the data flow task.
	//
	// Limits:
	//
	// 	- The list must be encoded in UTF-8.
	//
	// 	- The total length of the file list cannot exceed 64 KB.
	//
	// 	- The file list is in JSON format.
	//
	// 	- The path of a single file must be 1 to 1,023 characters in length and must start with a forward slash (/).
	//
	// 	- If the TaskAction parameter is set to Import, each element in the list represents an OSS object name.
	//
	// 	- If the TaskAction parameter is set to Export, each element in the list represents a CPFS file path.
	//
	// example:
	//
	// ["/path_in_cpfs/file1", "/path_in_cpfs/file2"]
	EntryList *string `json:"EntryList,omitempty" xml:"EntryList,omitempty"`
	// The ID of the file system.
	//
	// 	- The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-125487\\*\\*\\*\\*.
	//
	// 	- The IDs of CPFS for LINGJUN file systems must start with `bmcpfs-`. Example: bmcpfs-0015\\*\\*\\*\\*.
	//
	// >  CPFS is not supported on the international site.
	//
	// This parameter is required.
	//
	// example:
	//
	// bmcpfs-290w65p03ok64ya****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// If you specify SrcTaskId, the configurations of the TaskAction, DataType, and EntryList parameters are copied from the desired dataflow task. You do not need to specify them.
	//
	// example:
	//
	// task-27aa8e890f45****
	SrcTaskId *string `json:"SrcTaskId,omitempty" xml:"SrcTaskId,omitempty"`
	// The type of the data flow task.
	//
	// Valid values:
	//
	// 	- Import: imports data stored in the source storage to a CPFS file system.
	//
	// 	- Export: exports specified data from a CPFS file system to the source storage.
	//
	// 	- StreamImport: batch imports the specified data from the source storage to a CPFS file system.
	//
	// 	- StreamExport: batch exports specified data from a CPFS file system to the source storage.
	//
	// >  Only CPFS for LINGJUN V2.6.0 and later support StreamImport and StreamExport.
	//
	// example:
	//
	// Import
	TaskAction           *string `json:"TaskAction,omitempty" xml:"TaskAction,omitempty"`
	TransferFileListPath *string `json:"TransferFileListPath,omitempty" xml:"TransferFileListPath,omitempty"`
}

func (s CreateDataFlowTaskRequest) String() string {
	return dara.Prettify(s)
}

func (s CreateDataFlowTaskRequest) GoString() string {
	return s.String()
}

func (s *CreateDataFlowTaskRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *CreateDataFlowTaskRequest) GetConflictPolicy() *string {
	return s.ConflictPolicy
}

func (s *CreateDataFlowTaskRequest) GetCreateDirIfNotExist() *bool {
	return s.CreateDirIfNotExist
}

func (s *CreateDataFlowTaskRequest) GetDataFlowId() *string {
	return s.DataFlowId
}

func (s *CreateDataFlowTaskRequest) GetDataType() *string {
	return s.DataType
}

func (s *CreateDataFlowTaskRequest) GetDirectory() *string {
	return s.Directory
}

func (s *CreateDataFlowTaskRequest) GetDryRun() *bool {
	return s.DryRun
}

func (s *CreateDataFlowTaskRequest) GetDstDirectory() *string {
	return s.DstDirectory
}

func (s *CreateDataFlowTaskRequest) GetEntryList() *string {
	return s.EntryList
}

func (s *CreateDataFlowTaskRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *CreateDataFlowTaskRequest) GetSrcTaskId() *string {
	return s.SrcTaskId
}

func (s *CreateDataFlowTaskRequest) GetTaskAction() *string {
	return s.TaskAction
}

func (s *CreateDataFlowTaskRequest) GetTransferFileListPath() *string {
	return s.TransferFileListPath
}

func (s *CreateDataFlowTaskRequest) SetClientToken(v string) *CreateDataFlowTaskRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateDataFlowTaskRequest) SetConflictPolicy(v string) *CreateDataFlowTaskRequest {
	s.ConflictPolicy = &v
	return s
}

func (s *CreateDataFlowTaskRequest) SetCreateDirIfNotExist(v bool) *CreateDataFlowTaskRequest {
	s.CreateDirIfNotExist = &v
	return s
}

func (s *CreateDataFlowTaskRequest) SetDataFlowId(v string) *CreateDataFlowTaskRequest {
	s.DataFlowId = &v
	return s
}

func (s *CreateDataFlowTaskRequest) SetDataType(v string) *CreateDataFlowTaskRequest {
	s.DataType = &v
	return s
}

func (s *CreateDataFlowTaskRequest) SetDirectory(v string) *CreateDataFlowTaskRequest {
	s.Directory = &v
	return s
}

func (s *CreateDataFlowTaskRequest) SetDryRun(v bool) *CreateDataFlowTaskRequest {
	s.DryRun = &v
	return s
}

func (s *CreateDataFlowTaskRequest) SetDstDirectory(v string) *CreateDataFlowTaskRequest {
	s.DstDirectory = &v
	return s
}

func (s *CreateDataFlowTaskRequest) SetEntryList(v string) *CreateDataFlowTaskRequest {
	s.EntryList = &v
	return s
}

func (s *CreateDataFlowTaskRequest) SetFileSystemId(v string) *CreateDataFlowTaskRequest {
	s.FileSystemId = &v
	return s
}

func (s *CreateDataFlowTaskRequest) SetSrcTaskId(v string) *CreateDataFlowTaskRequest {
	s.SrcTaskId = &v
	return s
}

func (s *CreateDataFlowTaskRequest) SetTaskAction(v string) *CreateDataFlowTaskRequest {
	s.TaskAction = &v
	return s
}

func (s *CreateDataFlowTaskRequest) SetTransferFileListPath(v string) *CreateDataFlowTaskRequest {
	s.TransferFileListPath = &v
	return s
}

func (s *CreateDataFlowTaskRequest) Validate() error {
	return dara.Validate(s)
}

type iCreateDataFlowTaskResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *CreateDataFlowTaskResponseBody
	GetRequestId() *string
	SetTaskId(v string) *CreateDataFlowTaskResponseBody
	GetTaskId() *string
}

type CreateDataFlowTaskResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 2D69A58F-345C-4FDE-88E4-BF518948****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the dataflow task.
	//
	// example:
	//
	// task-38aa8e890f45****
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s CreateDataFlowTaskResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CreateDataFlowTaskResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDataFlowTaskResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CreateDataFlowTaskResponseBody) GetTaskId() *string {
	return s.TaskId
}

func (s *CreateDataFlowTaskResponseBody) SetRequestId(v string) *CreateDataFlowTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDataFlowTaskResponseBody) SetTaskId(v string) *CreateDataFlowTaskResponseBody {
	s.TaskId = &v
	return s
}

func (s *CreateDataFlowTaskResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCreateDataFlowTaskResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CreateDataFlowTaskResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CreateDataFlowTaskResponse
	GetStatusCode() *int32
	SetBody(v *CreateDataFlowTaskResponseBody) *CreateDataFlowTaskResponse
	GetBody() *CreateDataFlowTaskResponseBody
}

type CreateDataFlowTaskResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateDataFlowTaskResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateDataFlowTaskResponse) String() string {
	return dara.Prettify(s)
}

func (s CreateDataFlowTaskResponse) GoString() string {
	return s.String()
}

func (s *CreateDataFlowTaskResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CreateDataFlowTaskResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CreateDataFlowTaskResponse) GetBody() *CreateDataFlowTaskResponseBody {
	return s.Body
}

func (s *CreateDataFlowTaskResponse) SetHeaders(v map[string]*string) *CreateDataFlowTaskResponse {
	s.Headers = v
	return s
}

func (s *CreateDataFlowTaskResponse) SetStatusCode(v int32) *CreateDataFlowTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDataFlowTaskResponse) SetBody(v *CreateDataFlowTaskResponseBody) *CreateDataFlowTaskResponse {
	s.Body = v
	return s
}

func (s *CreateDataFlowTaskResponse) Validate() error {
	return dara.Validate(s)
}

type iCreateDirRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *CreateDirRequest
	GetFileSystemId() *string
	SetOwnerGroupId(v int32) *CreateDirRequest
	GetOwnerGroupId() *int32
	SetOwnerUserId(v int32) *CreateDirRequest
	GetOwnerUserId() *int32
	SetPermission(v string) *CreateDirRequest
	GetPermission() *string
	SetRecursion(v bool) *CreateDirRequest
	GetRecursion() *bool
	SetRootDirectory(v string) *CreateDirRequest
	GetRootDirectory() *string
}

type CreateDirRequest struct {
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 31a8e4****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The ID of the owner group for the directory. Valid values: 0 to 4294967295.
	//
	// This parameter is required.
	//
	// example:
	//
	// 123
	OwnerGroupId *int32 `json:"OwnerGroupId,omitempty" xml:"OwnerGroupId,omitempty"`
	// The owner ID for the directory. Valid values: 0 to 4294967295.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1
	OwnerUserId *int32 `json:"OwnerUserId,omitempty" xml:"OwnerUserId,omitempty"`
	// The Portable Operating System Interface (POSIX) permissions applied to the root directory. The value is a valid octal number, such as 0755.
	//
	// This parameter is required.
	//
	// example:
	//
	// 0755
	Permission *string `json:"Permission,omitempty" xml:"Permission,omitempty"`
	// Specifies whether to create a multi-level directory. Valid values:
	//
	// 	- true (default): If no multi-level directory exists, directories are created level by level.
	//
	// 	- false: Only the last level of directory is created. An error message is returned because the parent directory does not exist.
	//
	// example:
	//
	// true
	Recursion *bool `json:"Recursion,omitempty" xml:"Recursion,omitempty"`
	// The directory name.
	//
	// 	- The directory must start with a forward slash (/).
	//
	// 	- The directory can contain digits and letters.
	//
	// 	- The directory can contain underscores (_), hyphens (-), and periods (.).
	//
	// 	- The directory cannot contain symbolic links, such as the current directory (.), the upper-level directory (..), and other symbolic links.
	//
	// > 	- If the root directory does not exist, configure the information for directory creation. The system then automatically creates the specified root directory based on your settings.
	//
	// > 	- If the root directory exists, you do not need to configure the information for directory creation. The configurations for directory creation are ignored even if you configure the information.
	//
	// This parameter is required.
	//
	// example:
	//
	// test
	RootDirectory *string `json:"RootDirectory,omitempty" xml:"RootDirectory,omitempty"`
}

func (s CreateDirRequest) String() string {
	return dara.Prettify(s)
}

func (s CreateDirRequest) GoString() string {
	return s.String()
}

func (s *CreateDirRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *CreateDirRequest) GetOwnerGroupId() *int32 {
	return s.OwnerGroupId
}

func (s *CreateDirRequest) GetOwnerUserId() *int32 {
	return s.OwnerUserId
}

func (s *CreateDirRequest) GetPermission() *string {
	return s.Permission
}

func (s *CreateDirRequest) GetRecursion() *bool {
	return s.Recursion
}

func (s *CreateDirRequest) GetRootDirectory() *string {
	return s.RootDirectory
}

func (s *CreateDirRequest) SetFileSystemId(v string) *CreateDirRequest {
	s.FileSystemId = &v
	return s
}

func (s *CreateDirRequest) SetOwnerGroupId(v int32) *CreateDirRequest {
	s.OwnerGroupId = &v
	return s
}

func (s *CreateDirRequest) SetOwnerUserId(v int32) *CreateDirRequest {
	s.OwnerUserId = &v
	return s
}

func (s *CreateDirRequest) SetPermission(v string) *CreateDirRequest {
	s.Permission = &v
	return s
}

func (s *CreateDirRequest) SetRecursion(v bool) *CreateDirRequest {
	s.Recursion = &v
	return s
}

func (s *CreateDirRequest) SetRootDirectory(v string) *CreateDirRequest {
	s.RootDirectory = &v
	return s
}

func (s *CreateDirRequest) Validate() error {
	return dara.Validate(s)
}

type iCreateDirResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *CreateDirResponseBody
	GetRequestId() *string
}

type CreateDirResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// BC7C825C-5F65-4B56-BEF6-98C56C7C****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateDirResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CreateDirResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDirResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CreateDirResponseBody) SetRequestId(v string) *CreateDirResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDirResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCreateDirResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CreateDirResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CreateDirResponse
	GetStatusCode() *int32
	SetBody(v *CreateDirResponseBody) *CreateDirResponse
	GetBody() *CreateDirResponseBody
}

type CreateDirResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateDirResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateDirResponse) String() string {
	return dara.Prettify(s)
}

func (s CreateDirResponse) GoString() string {
	return s.String()
}

func (s *CreateDirResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CreateDirResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CreateDirResponse) GetBody() *CreateDirResponseBody {
	return s.Body
}

func (s *CreateDirResponse) SetHeaders(v map[string]*string) *CreateDirResponse {
	s.Headers = v
	return s
}

func (s *CreateDirResponse) SetStatusCode(v int32) *CreateDirResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDirResponse) SetBody(v *CreateDirResponseBody) *CreateDirResponse {
	s.Body = v
	return s
}

func (s *CreateDirResponse) Validate() error {
	return dara.Validate(s)
}

type iCreateFileRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *CreateFileRequest
	GetFileSystemId() *string
	SetOwner(v string) *CreateFileRequest
	GetOwner() *string
	SetOwnerAccessInheritable(v bool) *CreateFileRequest
	GetOwnerAccessInheritable() *bool
	SetPath(v string) *CreateFileRequest
	GetPath() *string
	SetType(v string) *CreateFileRequest
	GetType() *string
}

type CreateFileRequest struct {
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1ca404****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The ID of the portable account. The ID must be a 16-digit string. The string can contain digits and lowercase letters.
	//
	// example:
	//
	// 378cc7630f26****
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// Specifies whether to share the directory. Valid values:
	//
	// 	- false (default): does not share the directory.
	//
	// 	- true: shares the directory.
	//
	// > 	- This parameter takes effect only if the Type parameter is set to Directory and the Owner parameter is not empty.
	//
	// > 	- The permissions on a directory can be inherited by the owner. The owner has read and write permissions on the subdirectories and subfiles created in the directory, even if they are created by others.
	//
	// example:
	//
	// false
	OwnerAccessInheritable *bool `json:"OwnerAccessInheritable,omitempty" xml:"OwnerAccessInheritable,omitempty"`
	// The absolute path of the directory or file. The path must start and end with a forward slash (/) and must be 2 to 1024 characters in length.
	//
	// This parameter is required.
	//
	// example:
	//
	// /test/
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The type of the object. Valid values:
	//
	// 	- File
	//
	// 	- Directory
	//
	// This parameter is required.
	//
	// example:
	//
	// File
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateFileRequest) String() string {
	return dara.Prettify(s)
}

func (s CreateFileRequest) GoString() string {
	return s.String()
}

func (s *CreateFileRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *CreateFileRequest) GetOwner() *string {
	return s.Owner
}

func (s *CreateFileRequest) GetOwnerAccessInheritable() *bool {
	return s.OwnerAccessInheritable
}

func (s *CreateFileRequest) GetPath() *string {
	return s.Path
}

func (s *CreateFileRequest) GetType() *string {
	return s.Type
}

func (s *CreateFileRequest) SetFileSystemId(v string) *CreateFileRequest {
	s.FileSystemId = &v
	return s
}

func (s *CreateFileRequest) SetOwner(v string) *CreateFileRequest {
	s.Owner = &v
	return s
}

func (s *CreateFileRequest) SetOwnerAccessInheritable(v bool) *CreateFileRequest {
	s.OwnerAccessInheritable = &v
	return s
}

func (s *CreateFileRequest) SetPath(v string) *CreateFileRequest {
	s.Path = &v
	return s
}

func (s *CreateFileRequest) SetType(v string) *CreateFileRequest {
	s.Type = &v
	return s
}

func (s *CreateFileRequest) Validate() error {
	return dara.Validate(s)
}

type iCreateFileResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *CreateFileResponseBody
	GetRequestId() *string
}

type CreateFileResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 2D69A58F-345C-4FDE-88E4-BF518948****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateFileResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CreateFileResponseBody) GoString() string {
	return s.String()
}

func (s *CreateFileResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CreateFileResponseBody) SetRequestId(v string) *CreateFileResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateFileResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCreateFileResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CreateFileResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CreateFileResponse
	GetStatusCode() *int32
	SetBody(v *CreateFileResponseBody) *CreateFileResponse
	GetBody() *CreateFileResponseBody
}

type CreateFileResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateFileResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateFileResponse) String() string {
	return dara.Prettify(s)
}

func (s CreateFileResponse) GoString() string {
	return s.String()
}

func (s *CreateFileResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CreateFileResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CreateFileResponse) GetBody() *CreateFileResponseBody {
	return s.Body
}

func (s *CreateFileResponse) SetHeaders(v map[string]*string) *CreateFileResponse {
	s.Headers = v
	return s
}

func (s *CreateFileResponse) SetStatusCode(v int32) *CreateFileResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateFileResponse) SetBody(v *CreateFileResponseBody) *CreateFileResponse {
	s.Body = v
	return s
}

func (s *CreateFileResponse) Validate() error {
	return dara.Validate(s)
}

type iCreateFileSystemRequest interface {
	dara.Model
	String() string
	GoString() string
	SetBandwidth(v int64) *CreateFileSystemRequest
	GetBandwidth() *int64
	SetCapacity(v int64) *CreateFileSystemRequest
	GetCapacity() *int64
	SetChargeType(v string) *CreateFileSystemRequest
	GetChargeType() *string
	SetClientToken(v string) *CreateFileSystemRequest
	GetClientToken() *string
	SetDescription(v string) *CreateFileSystemRequest
	GetDescription() *string
	SetDryRun(v bool) *CreateFileSystemRequest
	GetDryRun() *bool
	SetDuration(v int32) *CreateFileSystemRequest
	GetDuration() *int32
	SetEncryptType(v int32) *CreateFileSystemRequest
	GetEncryptType() *int32
	SetFileSystemType(v string) *CreateFileSystemRequest
	GetFileSystemType() *string
	SetKmsKeyId(v string) *CreateFileSystemRequest
	GetKmsKeyId() *string
	SetProtocolType(v string) *CreateFileSystemRequest
	GetProtocolType() *string
	SetResourceGroupId(v string) *CreateFileSystemRequest
	GetResourceGroupId() *string
	SetSnapshotId(v string) *CreateFileSystemRequest
	GetSnapshotId() *string
	SetStorageType(v string) *CreateFileSystemRequest
	GetStorageType() *string
	SetTag(v []*CreateFileSystemRequestTag) *CreateFileSystemRequest
	GetTag() []*CreateFileSystemRequestTag
	SetVSwitchId(v string) *CreateFileSystemRequest
	GetVSwitchId() *string
	SetVpcId(v string) *CreateFileSystemRequest
	GetVpcId() *string
	SetZoneId(v string) *CreateFileSystemRequest
	GetZoneId() *string
}

type CreateFileSystemRequest struct {
	// The maximum throughput of the file system.
	//
	// Unit: MB/s.
	//
	// Specify a value based on the specifications on the buy page.
	//
	// example:
	//
	// 150
	Bandwidth *int64 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The capacity of the file system. Unit: GiB.
	//
	// This parameter is valid and required if the FileSystemType parameter is set to extreme.
	//
	// Specify a value based on the specifications on the following buy page:
	//
	// [Extreme NAS file system (Pay-as-you-go)](https://common-buy-intl.alibabacloud.com/?commodityCode=nas_extpost_public_intl#/buy)
	//
	// example:
	//
	// 100
	Capacity *int64 `json:"Capacity,omitempty" xml:"Capacity,omitempty"`
	// The billing method.
	//
	// Valid values:
	//
	// 	- PayAsYouGo (default): pay-as-you-go
	//
	// 	- Subscription: subscription
	//
	// example:
	//
	// PayAsYouGo
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// > If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-42665544****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the file system.
	//
	// Limits:
	//
	// 	- The description must be 2 to 128 characters in length.
	//
	// 	- The description must start with a letter and cannot start with `http://` or `https://`.
	//
	// 	- The description can contain letters, digits, colons (:), underscores (_), and hyphens (-).
	//
	// example:
	//
	// test
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to perform a dry run.
	//
	// During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no file system is created and no fee is incurred.
	//
	// Valid values:
	//
	// 	- true: performs a dry run. The system checks the required parameters, request syntax, limits, and available NAS resources. If the request fails the dry run, an error message is returned. If the request passes the precheck, the HTTP status code 200 is returned. No value is returned for the FileSystemId parameter.
	//
	// 	- false (default): performs a dry run and sends the request. If the request passes the dry run, a file system is created.
	//
	// example:
	//
	// true
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The subscription duration.
	//
	// This parameter is valid and required only if the ChargeType parameter is set to Subscription. Unit: months.
	//
	// If you do not renew a subscription file system when the file system expires, the file system is automatically released.
	//
	// example:
	//
	// 1
	Duration *int32 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// Specifies whether to encrypt data in the file system.
	//
	// You can use the keys that are managed by Key Management Service (KMS) to encrypt data in a file system. When you read and write the encrypted data, the data is automatically decrypted.
	//
	// Valid values:
	//
	// 	- 0 (default): The data in the file system is not encrypted.
	//
	// 	- 1: A NAS-managed key is used to encrypt the data in the file system. This value is valid only if the FileSystemType parameter is set to standard or extreme.
	//
	// 	- 2: A KMS-managed key is used to encrypt the data in the file system. This value is valid only if the FileSystemType parameter is set to standard or extreme.
	//
	// >  	- Extreme NAS file system: All regions support KMS-managed keys.
	//
	// > 	- General-purpose NAS file system: KMS-managed keys are supported in the following regions: China (Chengdu), China (Qingdao), China (Hohhot), China (Ulanqab), China (Heyuan), China (Hangzhou), China (Shanghai), China (Beijing), China (Zhangjiakou), China (Shenzhen), China (Guangzhou), China (Hong Kong), Japan (Tokyo), Philippines (Manila), Thailand (Bangkok), Malaysia (Kuala Lumpur), US (Silicon Valley), Indonesia (Jakarta), UK (London), Singapore, US (Virginia), Germany (Frankfurt),  and China East 1 Finance.
	//
	// example:
	//
	// 1
	EncryptType *int32 `json:"EncryptType,omitempty" xml:"EncryptType,omitempty"`
	// The type of the file system.
	//
	// Valid values:
	//
	// 	- standard (default): General-purpose NAS file system
	//
	// 	- extreme: Extreme NAS file system
	//
	// 	- cpfs: Cloud Parallel File Storage (CPFS) file system
	//
	// > CPFS file systems are available only on the China site (aliyun.com).
	//
	// example:
	//
	// standard
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
	// The ID of the KMS-managed key.
	//
	// This parameter is required only if the EncryptType parameter is set to 2.
	//
	// example:
	//
	// 3c0b3885-2adf-483d-8a65-5e280689****
	KmsKeyId *string `json:"KmsKeyId,omitempty" xml:"KmsKeyId,omitempty"`
	// The protocol type.
	//
	// 	- If the FileSystemType parameter is set to standard, you can set the ProtocolType parameter to NFS or SMB.
	//
	// 	- If the FileSystemType parameter is set to extreme, you can set the ProtocolType parameter to NFS.
	//
	// This parameter is required.
	//
	// example:
	//
	// NFS
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The resource group ID.
	//
	// You can log on to the [Resource Management console](https://resourcemanager.console.aliyun.com/resource-groups?) to view resource group IDs.
	//
	// example:
	//
	// rg-acfmwavnfdf****
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The snapshot ID.
	//
	// This parameter is available only for Extreme NAS file systems.
	//
	// > You can create a file system from a snapshot. In this case, the version of the file system is the same as that of the source file system. For example, the source file system of the snapshot uses version 1. To create a file system of version 2, you can create File System A from the snapshot and create File System B of version 2. You can then copy the data and migrate your business from File System A to File System B.
	//
	// example:
	//
	// s-xxx
	SnapshotId *string `json:"SnapshotId,omitempty" xml:"SnapshotId,omitempty"`
	// The storage class.
	//
	// 	- If the FileSystemType parameter is set to standard, you can set the StorageType parameter to Performance, Capacity, or Premium.
	//
	// 	- If the FileSystemType parameter is set to extreme, you can set the StorageType parameter to standard or advance.
	//
	// This parameter is required.
	//
	// example:
	//
	// Performance
	StorageType *string                       `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
	Tag         []*CreateFileSystemRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the vSwitch.
	//
	// This parameter is reserved and does not take effect. You do not need to configure this parameter.
	//
	// example:
	//
	// vsw-2ze37k6jh8ums2fw2****
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the virtual private cloud (VPC).
	//
	// This parameter is reserved and does not take effect. You do not need to configure this parameter.
	//
	// example:
	//
	// vpc-bp1cbv1ljve4j5hlw****
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The zone ID.
	//
	// Each region has multiple isolated locations known as zones. Each zone has its own independent power supply and networks.
	//
	// This parameter is not required if the FileSystemType parameter is set to standard. By default, a random zone is selected based on the protocol type and storage type.
	//
	// This parameter is required if the FileSystemType parameter is set to extreme.
	//
	// > 	- An Elastic Compute Service (ECS) instance and a NAS file system that reside in different zones of the same region can access each other.
	//
	// >	- We recommend that you select the zone where the ECS instance resides. This prevents cross-zone latency between the file system and the ECS instance.
	//
	// example:
	//
	// cn-hangzhou-b
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s CreateFileSystemRequest) String() string {
	return dara.Prettify(s)
}

func (s CreateFileSystemRequest) GoString() string {
	return s.String()
}

func (s *CreateFileSystemRequest) GetBandwidth() *int64 {
	return s.Bandwidth
}

func (s *CreateFileSystemRequest) GetCapacity() *int64 {
	return s.Capacity
}

func (s *CreateFileSystemRequest) GetChargeType() *string {
	return s.ChargeType
}

func (s *CreateFileSystemRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *CreateFileSystemRequest) GetDescription() *string {
	return s.Description
}

func (s *CreateFileSystemRequest) GetDryRun() *bool {
	return s.DryRun
}

func (s *CreateFileSystemRequest) GetDuration() *int32 {
	return s.Duration
}

func (s *CreateFileSystemRequest) GetEncryptType() *int32 {
	return s.EncryptType
}

func (s *CreateFileSystemRequest) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *CreateFileSystemRequest) GetKmsKeyId() *string {
	return s.KmsKeyId
}

func (s *CreateFileSystemRequest) GetProtocolType() *string {
	return s.ProtocolType
}

func (s *CreateFileSystemRequest) GetResourceGroupId() *string {
	return s.ResourceGroupId
}

func (s *CreateFileSystemRequest) GetSnapshotId() *string {
	return s.SnapshotId
}

func (s *CreateFileSystemRequest) GetStorageType() *string {
	return s.StorageType
}

func (s *CreateFileSystemRequest) GetTag() []*CreateFileSystemRequestTag {
	return s.Tag
}

func (s *CreateFileSystemRequest) GetVSwitchId() *string {
	return s.VSwitchId
}

func (s *CreateFileSystemRequest) GetVpcId() *string {
	return s.VpcId
}

func (s *CreateFileSystemRequest) GetZoneId() *string {
	return s.ZoneId
}

func (s *CreateFileSystemRequest) SetBandwidth(v int64) *CreateFileSystemRequest {
	s.Bandwidth = &v
	return s
}

func (s *CreateFileSystemRequest) SetCapacity(v int64) *CreateFileSystemRequest {
	s.Capacity = &v
	return s
}

func (s *CreateFileSystemRequest) SetChargeType(v string) *CreateFileSystemRequest {
	s.ChargeType = &v
	return s
}

func (s *CreateFileSystemRequest) SetClientToken(v string) *CreateFileSystemRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateFileSystemRequest) SetDescription(v string) *CreateFileSystemRequest {
	s.Description = &v
	return s
}

func (s *CreateFileSystemRequest) SetDryRun(v bool) *CreateFileSystemRequest {
	s.DryRun = &v
	return s
}

func (s *CreateFileSystemRequest) SetDuration(v int32) *CreateFileSystemRequest {
	s.Duration = &v
	return s
}

func (s *CreateFileSystemRequest) SetEncryptType(v int32) *CreateFileSystemRequest {
	s.EncryptType = &v
	return s
}

func (s *CreateFileSystemRequest) SetFileSystemType(v string) *CreateFileSystemRequest {
	s.FileSystemType = &v
	return s
}

func (s *CreateFileSystemRequest) SetKmsKeyId(v string) *CreateFileSystemRequest {
	s.KmsKeyId = &v
	return s
}

func (s *CreateFileSystemRequest) SetProtocolType(v string) *CreateFileSystemRequest {
	s.ProtocolType = &v
	return s
}

func (s *CreateFileSystemRequest) SetResourceGroupId(v string) *CreateFileSystemRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateFileSystemRequest) SetSnapshotId(v string) *CreateFileSystemRequest {
	s.SnapshotId = &v
	return s
}

func (s *CreateFileSystemRequest) SetStorageType(v string) *CreateFileSystemRequest {
	s.StorageType = &v
	return s
}

func (s *CreateFileSystemRequest) SetTag(v []*CreateFileSystemRequestTag) *CreateFileSystemRequest {
	s.Tag = v
	return s
}

func (s *CreateFileSystemRequest) SetVSwitchId(v string) *CreateFileSystemRequest {
	s.VSwitchId = &v
	return s
}

func (s *CreateFileSystemRequest) SetVpcId(v string) *CreateFileSystemRequest {
	s.VpcId = &v
	return s
}

func (s *CreateFileSystemRequest) SetZoneId(v string) *CreateFileSystemRequest {
	s.ZoneId = &v
	return s
}

func (s *CreateFileSystemRequest) Validate() error {
	return dara.Validate(s)
}

type CreateFileSystemRequestTag struct {
	// if can be null:
	// false
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// if can be null:
	// false
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateFileSystemRequestTag) String() string {
	return dara.Prettify(s)
}

func (s CreateFileSystemRequestTag) GoString() string {
	return s.String()
}

func (s *CreateFileSystemRequestTag) GetKey() *string {
	return s.Key
}

func (s *CreateFileSystemRequestTag) GetValue() *string {
	return s.Value
}

func (s *CreateFileSystemRequestTag) SetKey(v string) *CreateFileSystemRequestTag {
	s.Key = &v
	return s
}

func (s *CreateFileSystemRequestTag) SetValue(v string) *CreateFileSystemRequestTag {
	s.Value = &v
	return s
}

func (s *CreateFileSystemRequestTag) Validate() error {
	return dara.Validate(s)
}

type iCreateFileSystemResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *CreateFileSystemResponseBody
	GetFileSystemId() *string
	SetRequestId(v string) *CreateFileSystemResponseBody
	GetRequestId() *string
}

type CreateFileSystemResponseBody struct {
	// The ID of the file system that is created.
	//
	// example:
	//
	// 1ca404****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 98696EF0-1607-4E9D-B01D-F20930B6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateFileSystemResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CreateFileSystemResponseBody) GoString() string {
	return s.String()
}

func (s *CreateFileSystemResponseBody) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *CreateFileSystemResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CreateFileSystemResponseBody) SetFileSystemId(v string) *CreateFileSystemResponseBody {
	s.FileSystemId = &v
	return s
}

func (s *CreateFileSystemResponseBody) SetRequestId(v string) *CreateFileSystemResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateFileSystemResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCreateFileSystemResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CreateFileSystemResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CreateFileSystemResponse
	GetStatusCode() *int32
	SetBody(v *CreateFileSystemResponseBody) *CreateFileSystemResponse
	GetBody() *CreateFileSystemResponseBody
}

type CreateFileSystemResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateFileSystemResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateFileSystemResponse) String() string {
	return dara.Prettify(s)
}

func (s CreateFileSystemResponse) GoString() string {
	return s.String()
}

func (s *CreateFileSystemResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CreateFileSystemResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CreateFileSystemResponse) GetBody() *CreateFileSystemResponseBody {
	return s.Body
}

func (s *CreateFileSystemResponse) SetHeaders(v map[string]*string) *CreateFileSystemResponse {
	s.Headers = v
	return s
}

func (s *CreateFileSystemResponse) SetStatusCode(v int32) *CreateFileSystemResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateFileSystemResponse) SetBody(v *CreateFileSystemResponseBody) *CreateFileSystemResponse {
	s.Body = v
	return s
}

func (s *CreateFileSystemResponse) Validate() error {
	return dara.Validate(s)
}

type iCreateFilesetRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientToken(v string) *CreateFilesetRequest
	GetClientToken() *string
	SetDeletionProtection(v bool) *CreateFilesetRequest
	GetDeletionProtection() *bool
	SetDescription(v string) *CreateFilesetRequest
	GetDescription() *string
	SetDryRun(v bool) *CreateFilesetRequest
	GetDryRun() *bool
	SetFileSystemId(v string) *CreateFilesetRequest
	GetFileSystemId() *string
	SetFileSystemPath(v string) *CreateFilesetRequest
	GetFileSystemPath() *string
	SetQuota(v *CreateFilesetRequestQuota) *CreateFilesetRequest
	GetQuota() *CreateFilesetRequestQuota
}

type CreateFilesetRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// >  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-42665544****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to enable deletion protection to allow you to release the fileset by using the console or by calling the [DeleteFileset](https://help.aliyun.com/document_detail/2838077.html) operation.
	//
	// 	- true: enables release protection.
	//
	// 	- false (default): disables release protection.
	//
	// >  This parameter can protect filesets only against manual releases, but not against automatic releases.
	//
	// example:
	//
	// false
	DeletionProtection *bool `json:"DeletionProtection,omitempty" xml:"DeletionProtection,omitempty"`
	// The description of the fileset.
	//
	// 	- The description must be 2 to 128 characters in length.
	//
	// 	- The description must start with a letter but cannot start with http:// or https://.
	//
	// 	- The description can contain letters, digits, colons (:), underscores (_), and hyphens (-).
	//
	// example:
	//
	// test
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to perform a dry run.
	//
	// During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no fileset is created and no fee is incurred.
	//
	// Valid values:
	//
	// 	- true: performs a dry run. The system checks the required parameters, request syntax, service limits, and available Apsara File Storage NAS (NAS) resources. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the FsetId parameter.
	//
	// 	- false (default): performs a dry run and sends the request. If the request passes the dry run, a fileset is created.
	//
	// example:
	//
	// false
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the file system.
	//
	// 	- The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-099394bd928c\\*\\*\\*\\*.
	//
	// 	- The IDs of CPFS for LINGJUN file systems must start with `bmcpfs-`. Example: bmcpfs-290w65p03ok64ya\\*\\*\\*\\*.
	//
	// >  CPFS is not supported on the international site.
	//
	// This parameter is required.
	//
	// example:
	//
	// bmcpfs-290w65p03ok64ya****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The absolute path of the fileset.
	//
	// 	- The path must be 2 to 1024 characters in length.
	//
	// 	- The path must start and end with a forward slash (/).
	//
	// 	- The fileset path must be a new path and cannot be an existing path. Fileset paths cannot be renamed and cannot be symbolic links.
	//
	// 	- The maximum depth supported by a fileset path is eight levels. The depth of the root directory / is 0 levels. For example, the fileset path /test/aaa/ccc/ has three levels.
	//
	// 	- If the fileset path is a multi-level path, the parent directory must be an existing directory.
	//
	// 	- Nested filesets are not supported. If a fileset is specified as a parent directory, its subdirectory cannot be a fileset. A fileset path supports only one quota.
	//
	// This parameter is required.
	//
	// example:
	//
	// /test/
	FileSystemPath *string `json:"FileSystemPath,omitempty" xml:"FileSystemPath,omitempty"`
	// The quota information.
	//
	// >  Only CPFS for LINGJUN V2.7.0 and later support this parameter.
	Quota *CreateFilesetRequestQuota `json:"Quota,omitempty" xml:"Quota,omitempty" type:"Struct"`
}

func (s CreateFilesetRequest) String() string {
	return dara.Prettify(s)
}

func (s CreateFilesetRequest) GoString() string {
	return s.String()
}

func (s *CreateFilesetRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *CreateFilesetRequest) GetDeletionProtection() *bool {
	return s.DeletionProtection
}

func (s *CreateFilesetRequest) GetDescription() *string {
	return s.Description
}

func (s *CreateFilesetRequest) GetDryRun() *bool {
	return s.DryRun
}

func (s *CreateFilesetRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *CreateFilesetRequest) GetFileSystemPath() *string {
	return s.FileSystemPath
}

func (s *CreateFilesetRequest) GetQuota() *CreateFilesetRequestQuota {
	return s.Quota
}

func (s *CreateFilesetRequest) SetClientToken(v string) *CreateFilesetRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateFilesetRequest) SetDeletionProtection(v bool) *CreateFilesetRequest {
	s.DeletionProtection = &v
	return s
}

func (s *CreateFilesetRequest) SetDescription(v string) *CreateFilesetRequest {
	s.Description = &v
	return s
}

func (s *CreateFilesetRequest) SetDryRun(v bool) *CreateFilesetRequest {
	s.DryRun = &v
	return s
}

func (s *CreateFilesetRequest) SetFileSystemId(v string) *CreateFilesetRequest {
	s.FileSystemId = &v
	return s
}

func (s *CreateFilesetRequest) SetFileSystemPath(v string) *CreateFilesetRequest {
	s.FileSystemPath = &v
	return s
}

func (s *CreateFilesetRequest) SetQuota(v *CreateFilesetRequestQuota) *CreateFilesetRequest {
	s.Quota = v
	return s
}

func (s *CreateFilesetRequest) Validate() error {
	return dara.Validate(s)
}

type CreateFilesetRequestQuota struct {
	// The number of files of the quota. Valid values:
	//
	// 	- Minimum value: 100000.
	//
	// 	- Maximum value: 10000000000.
	//
	// example:
	//
	// 10000
	FileCountLimit *int64 `json:"FileCountLimit,omitempty" xml:"FileCountLimit,omitempty"`
	// The total capacity of the quota. Unit: bytes.
	//
	// Valid values:
	//
	// 	- Minimum value: 10737418240 (10 GiB).
	//
	// 	- Maximum value: 1073741824000 (1024000 GiB).
	//
	// 	- Step size: 1073741824 (1 GiB).
	//
	// example:
	//
	// 10737418240
	SizeLimit *int64 `json:"SizeLimit,omitempty" xml:"SizeLimit,omitempty"`
}

func (s CreateFilesetRequestQuota) String() string {
	return dara.Prettify(s)
}

func (s CreateFilesetRequestQuota) GoString() string {
	return s.String()
}

func (s *CreateFilesetRequestQuota) GetFileCountLimit() *int64 {
	return s.FileCountLimit
}

func (s *CreateFilesetRequestQuota) GetSizeLimit() *int64 {
	return s.SizeLimit
}

func (s *CreateFilesetRequestQuota) SetFileCountLimit(v int64) *CreateFilesetRequestQuota {
	s.FileCountLimit = &v
	return s
}

func (s *CreateFilesetRequestQuota) SetSizeLimit(v int64) *CreateFilesetRequestQuota {
	s.SizeLimit = &v
	return s
}

func (s *CreateFilesetRequestQuota) Validate() error {
	return dara.Validate(s)
}

type iCreateFilesetResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetFsetId(v string) *CreateFilesetResponseBody
	GetFsetId() *string
	SetRequestId(v string) *CreateFilesetResponseBody
	GetRequestId() *string
}

type CreateFilesetResponseBody struct {
	// The fileset ID.
	//
	// example:
	//
	// fset-1902718ea0ae****
	FsetId *string `json:"FsetId,omitempty" xml:"FsetId,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 98696EF0-1607-4E9D-B01D-F20930B6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateFilesetResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CreateFilesetResponseBody) GoString() string {
	return s.String()
}

func (s *CreateFilesetResponseBody) GetFsetId() *string {
	return s.FsetId
}

func (s *CreateFilesetResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CreateFilesetResponseBody) SetFsetId(v string) *CreateFilesetResponseBody {
	s.FsetId = &v
	return s
}

func (s *CreateFilesetResponseBody) SetRequestId(v string) *CreateFilesetResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateFilesetResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCreateFilesetResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CreateFilesetResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CreateFilesetResponse
	GetStatusCode() *int32
	SetBody(v *CreateFilesetResponseBody) *CreateFilesetResponse
	GetBody() *CreateFilesetResponseBody
}

type CreateFilesetResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateFilesetResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateFilesetResponse) String() string {
	return dara.Prettify(s)
}

func (s CreateFilesetResponse) GoString() string {
	return s.String()
}

func (s *CreateFilesetResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CreateFilesetResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CreateFilesetResponse) GetBody() *CreateFilesetResponseBody {
	return s.Body
}

func (s *CreateFilesetResponse) SetHeaders(v map[string]*string) *CreateFilesetResponse {
	s.Headers = v
	return s
}

func (s *CreateFilesetResponse) SetStatusCode(v int32) *CreateFilesetResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateFilesetResponse) SetBody(v *CreateFilesetResponseBody) *CreateFilesetResponse {
	s.Body = v
	return s
}

func (s *CreateFilesetResponse) Validate() error {
	return dara.Validate(s)
}

type iCreateLDAPConfigRequest interface {
	dara.Model
	String() string
	GoString() string
	SetBindDN(v string) *CreateLDAPConfigRequest
	GetBindDN() *string
	SetFileSystemId(v string) *CreateLDAPConfigRequest
	GetFileSystemId() *string
	SetSearchBase(v string) *CreateLDAPConfigRequest
	GetSearchBase() *string
	SetURI(v string) *CreateLDAPConfigRequest
	GetURI() *string
}

type CreateLDAPConfigRequest struct {
	// An LDAP entry.
	//
	// example:
	//
	// cn=alibaba,dc=com
	BindDN *string `json:"BindDN,omitempty" xml:"BindDN,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 109c04****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// An LDAP search base.
	//
	// This parameter is required.
	//
	// example:
	//
	// dc=example
	SearchBase *string `json:"SearchBase,omitempty" xml:"SearchBase,omitempty"`
	// An LDAP URI.
	//
	// This parameter is required.
	//
	// example:
	//
	// ldap://ldap.example.example
	URI *string `json:"URI,omitempty" xml:"URI,omitempty"`
}

func (s CreateLDAPConfigRequest) String() string {
	return dara.Prettify(s)
}

func (s CreateLDAPConfigRequest) GoString() string {
	return s.String()
}

func (s *CreateLDAPConfigRequest) GetBindDN() *string {
	return s.BindDN
}

func (s *CreateLDAPConfigRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *CreateLDAPConfigRequest) GetSearchBase() *string {
	return s.SearchBase
}

func (s *CreateLDAPConfigRequest) GetURI() *string {
	return s.URI
}

func (s *CreateLDAPConfigRequest) SetBindDN(v string) *CreateLDAPConfigRequest {
	s.BindDN = &v
	return s
}

func (s *CreateLDAPConfigRequest) SetFileSystemId(v string) *CreateLDAPConfigRequest {
	s.FileSystemId = &v
	return s
}

func (s *CreateLDAPConfigRequest) SetSearchBase(v string) *CreateLDAPConfigRequest {
	s.SearchBase = &v
	return s
}

func (s *CreateLDAPConfigRequest) SetURI(v string) *CreateLDAPConfigRequest {
	s.URI = &v
	return s
}

func (s *CreateLDAPConfigRequest) Validate() error {
	return dara.Validate(s)
}

type iCreateLDAPConfigResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *CreateLDAPConfigResponseBody
	GetRequestId() *string
}

type CreateLDAPConfigResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 5B4511A7-C99E-4071-AA8C-32E2529D****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateLDAPConfigResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CreateLDAPConfigResponseBody) GoString() string {
	return s.String()
}

func (s *CreateLDAPConfigResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CreateLDAPConfigResponseBody) SetRequestId(v string) *CreateLDAPConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateLDAPConfigResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCreateLDAPConfigResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CreateLDAPConfigResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CreateLDAPConfigResponse
	GetStatusCode() *int32
	SetBody(v *CreateLDAPConfigResponseBody) *CreateLDAPConfigResponse
	GetBody() *CreateLDAPConfigResponseBody
}

type CreateLDAPConfigResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateLDAPConfigResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateLDAPConfigResponse) String() string {
	return dara.Prettify(s)
}

func (s CreateLDAPConfigResponse) GoString() string {
	return s.String()
}

func (s *CreateLDAPConfigResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CreateLDAPConfigResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CreateLDAPConfigResponse) GetBody() *CreateLDAPConfigResponseBody {
	return s.Body
}

func (s *CreateLDAPConfigResponse) SetHeaders(v map[string]*string) *CreateLDAPConfigResponse {
	s.Headers = v
	return s
}

func (s *CreateLDAPConfigResponse) SetStatusCode(v int32) *CreateLDAPConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateLDAPConfigResponse) SetBody(v *CreateLDAPConfigResponseBody) *CreateLDAPConfigResponse {
	s.Body = v
	return s
}

func (s *CreateLDAPConfigResponse) Validate() error {
	return dara.Validate(s)
}

type iCreateLifecyclePolicyRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *CreateLifecyclePolicyRequest
	GetFileSystemId() *string
	SetFsetIds(v []*string) *CreateLifecyclePolicyRequest
	GetFsetIds() []*string
	SetLifecyclePolicyName(v string) *CreateLifecyclePolicyRequest
	GetLifecyclePolicyName() *string
	SetLifecycleRuleInactiveDays(v int32) *CreateLifecyclePolicyRequest
	GetLifecycleRuleInactiveDays() *int32
	SetLifecycleRuleName(v string) *CreateLifecyclePolicyRequest
	GetLifecycleRuleName() *string
	SetLifecycleRuleType(v string) *CreateLifecyclePolicyRequest
	GetLifecycleRuleType() *string
	SetPath(v string) *CreateLifecyclePolicyRequest
	GetPath() *string
	SetPaths(v []*string) *CreateLifecyclePolicyRequest
	GetPaths() []*string
	SetStorageType(v string) *CreateLifecyclePolicyRequest
	GetStorageType() *string
}

type CreateLifecyclePolicyRequest struct {
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 31a8e4****
	FileSystemId *string   `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	FsetIds      []*string `json:"FsetIds,omitempty" xml:"FsetIds,omitempty" type:"Repeated"`
	// The name of the lifecycle policy. The name must be 3 to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-). The name must start with a letter.
	//
	// This parameter is required.
	//
	// example:
	//
	// lifecyclepolicy_01
	LifecyclePolicyName *string `json:"LifecyclePolicyName,omitempty" xml:"LifecyclePolicyName,omitempty"`
	// if can be null:
	// true
	LifecycleRuleInactiveDays *int32 `json:"LifecycleRuleInactiveDays,omitempty" xml:"LifecycleRuleInactiveDays,omitempty"`
	// The management rule that is associated with the lifecycle policy.
	//
	// Valid values:
	//
	// 	- DEFAULT_ATIME_14: Files that are not accessed in the last 14 days are dumped to the IA storage medium.
	//
	// 	- DEFAULT_ATIME_30: Files that are not accessed in the last 30 days are dumped to the IA storage medium.
	//
	// 	- DEFAULT_ATIME_60: Files that are not accessed in the last 60 days are dumped to the IA storage medium.
	//
	// 	- DEFAULT_ATIME_90: Files that are not accessed in the last 90 days are dumped to the IA storage medium.
	//
	// example:
	//
	// DEFAULT_ATIME_14
	LifecycleRuleName *string `json:"LifecycleRuleName,omitempty" xml:"LifecycleRuleName,omitempty"`
	LifecycleRuleType *string `json:"LifecycleRuleType,omitempty" xml:"LifecycleRuleType,omitempty"`
	// The absolute path of the directory that is associated with the lifecycle policy.
	//
	// If you specify this parameter, you can associate the lifecycle policy with only one directory. The path must start with a forward slash (/) and must be a path that exists in the mount target.
	//
	// > We recommend that you specify the Paths.N parameter so that you can associate the lifecycle policy with multiple directories.
	//
	// example:
	//
	// /pathway/to/folder
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The absolute paths of the directories that are associated with the lifecycle policy.
	//
	// If you specify this parameter, you can associate the lifecycle policy with multiple directories. Each path must start with a forward slash (/) and must be a path that exists in the mount target. Valid values of N: 1 to 10.
	//
	// example:
	//
	// "/path1", "/path2"
	Paths []*string `json:"Paths,omitempty" xml:"Paths,omitempty" type:"Repeated"`
	// The storage type of the data that is dumped to the IA storage medium.
	//
	// Default value: InfrequentAccess (IA).
	//
	// This parameter is required.
	//
	// example:
	//
	// InfrequentAccess
	StorageType *string `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
}

func (s CreateLifecyclePolicyRequest) String() string {
	return dara.Prettify(s)
}

func (s CreateLifecyclePolicyRequest) GoString() string {
	return s.String()
}

func (s *CreateLifecyclePolicyRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *CreateLifecyclePolicyRequest) GetFsetIds() []*string {
	return s.FsetIds
}

func (s *CreateLifecyclePolicyRequest) GetLifecyclePolicyName() *string {
	return s.LifecyclePolicyName
}

func (s *CreateLifecyclePolicyRequest) GetLifecycleRuleInactiveDays() *int32 {
	return s.LifecycleRuleInactiveDays
}

func (s *CreateLifecyclePolicyRequest) GetLifecycleRuleName() *string {
	return s.LifecycleRuleName
}

func (s *CreateLifecyclePolicyRequest) GetLifecycleRuleType() *string {
	return s.LifecycleRuleType
}

func (s *CreateLifecyclePolicyRequest) GetPath() *string {
	return s.Path
}

func (s *CreateLifecyclePolicyRequest) GetPaths() []*string {
	return s.Paths
}

func (s *CreateLifecyclePolicyRequest) GetStorageType() *string {
	return s.StorageType
}

func (s *CreateLifecyclePolicyRequest) SetFileSystemId(v string) *CreateLifecyclePolicyRequest {
	s.FileSystemId = &v
	return s
}

func (s *CreateLifecyclePolicyRequest) SetFsetIds(v []*string) *CreateLifecyclePolicyRequest {
	s.FsetIds = v
	return s
}

func (s *CreateLifecyclePolicyRequest) SetLifecyclePolicyName(v string) *CreateLifecyclePolicyRequest {
	s.LifecyclePolicyName = &v
	return s
}

func (s *CreateLifecyclePolicyRequest) SetLifecycleRuleInactiveDays(v int32) *CreateLifecyclePolicyRequest {
	s.LifecycleRuleInactiveDays = &v
	return s
}

func (s *CreateLifecyclePolicyRequest) SetLifecycleRuleName(v string) *CreateLifecyclePolicyRequest {
	s.LifecycleRuleName = &v
	return s
}

func (s *CreateLifecyclePolicyRequest) SetLifecycleRuleType(v string) *CreateLifecyclePolicyRequest {
	s.LifecycleRuleType = &v
	return s
}

func (s *CreateLifecyclePolicyRequest) SetPath(v string) *CreateLifecyclePolicyRequest {
	s.Path = &v
	return s
}

func (s *CreateLifecyclePolicyRequest) SetPaths(v []*string) *CreateLifecyclePolicyRequest {
	s.Paths = v
	return s
}

func (s *CreateLifecyclePolicyRequest) SetStorageType(v string) *CreateLifecyclePolicyRequest {
	s.StorageType = &v
	return s
}

func (s *CreateLifecyclePolicyRequest) Validate() error {
	return dara.Validate(s)
}

type iCreateLifecyclePolicyResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *CreateLifecyclePolicyResponseBody
	GetRequestId() *string
	SetSuccess(v bool) *CreateLifecyclePolicyResponseBody
	GetSuccess() *bool
}

type CreateLifecyclePolicyResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// BC7C825C-5F65-4B56-BEF6-98C56C7C****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	//
	// Valid values:
	//
	// 	- true
	//
	// 	- false
	//
	// example:
	//
	// true
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateLifecyclePolicyResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CreateLifecyclePolicyResponseBody) GoString() string {
	return s.String()
}

func (s *CreateLifecyclePolicyResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CreateLifecyclePolicyResponseBody) GetSuccess() *bool {
	return s.Success
}

func (s *CreateLifecyclePolicyResponseBody) SetRequestId(v string) *CreateLifecyclePolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateLifecyclePolicyResponseBody) SetSuccess(v bool) *CreateLifecyclePolicyResponseBody {
	s.Success = &v
	return s
}

func (s *CreateLifecyclePolicyResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCreateLifecyclePolicyResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CreateLifecyclePolicyResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CreateLifecyclePolicyResponse
	GetStatusCode() *int32
	SetBody(v *CreateLifecyclePolicyResponseBody) *CreateLifecyclePolicyResponse
	GetBody() *CreateLifecyclePolicyResponseBody
}

type CreateLifecyclePolicyResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateLifecyclePolicyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateLifecyclePolicyResponse) String() string {
	return dara.Prettify(s)
}

func (s CreateLifecyclePolicyResponse) GoString() string {
	return s.String()
}

func (s *CreateLifecyclePolicyResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CreateLifecyclePolicyResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CreateLifecyclePolicyResponse) GetBody() *CreateLifecyclePolicyResponseBody {
	return s.Body
}

func (s *CreateLifecyclePolicyResponse) SetHeaders(v map[string]*string) *CreateLifecyclePolicyResponse {
	s.Headers = v
	return s
}

func (s *CreateLifecyclePolicyResponse) SetStatusCode(v int32) *CreateLifecyclePolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateLifecyclePolicyResponse) SetBody(v *CreateLifecyclePolicyResponseBody) *CreateLifecyclePolicyResponse {
	s.Body = v
	return s
}

func (s *CreateLifecyclePolicyResponse) Validate() error {
	return dara.Validate(s)
}

type iCreateLifecycleRetrieveJobRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *CreateLifecycleRetrieveJobRequest
	GetFileSystemId() *string
	SetPaths(v []*string) *CreateLifecycleRetrieveJobRequest
	GetPaths() []*string
	SetStorageType(v string) *CreateLifecycleRetrieveJobRequest
	GetStorageType() *string
}

type CreateLifecycleRetrieveJobRequest struct {
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 31a8e4****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The directories or files that you want to retrieve. You can specify a maximum of 10 paths.
	//
	// This parameter is required.
	//
	// example:
	//
	// Paths.1=/pathway/doc1,Paths.2=/pathway/doc2
	Paths []*string `json:"Paths,omitempty" xml:"Paths,omitempty" type:"Repeated"`
	// The storage class.
	//
	// 	- InfrequentAccess (default): the Infrequent Access (IA) storage class.
	//
	// 	- Archive: the Archive storage class.
	//
	// example:
	//
	// InfrequentAccess
	StorageType *string `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
}

func (s CreateLifecycleRetrieveJobRequest) String() string {
	return dara.Prettify(s)
}

func (s CreateLifecycleRetrieveJobRequest) GoString() string {
	return s.String()
}

func (s *CreateLifecycleRetrieveJobRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *CreateLifecycleRetrieveJobRequest) GetPaths() []*string {
	return s.Paths
}

func (s *CreateLifecycleRetrieveJobRequest) GetStorageType() *string {
	return s.StorageType
}

func (s *CreateLifecycleRetrieveJobRequest) SetFileSystemId(v string) *CreateLifecycleRetrieveJobRequest {
	s.FileSystemId = &v
	return s
}

func (s *CreateLifecycleRetrieveJobRequest) SetPaths(v []*string) *CreateLifecycleRetrieveJobRequest {
	s.Paths = v
	return s
}

func (s *CreateLifecycleRetrieveJobRequest) SetStorageType(v string) *CreateLifecycleRetrieveJobRequest {
	s.StorageType = &v
	return s
}

func (s *CreateLifecycleRetrieveJobRequest) Validate() error {
	return dara.Validate(s)
}

type iCreateLifecycleRetrieveJobResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetJobId(v string) *CreateLifecycleRetrieveJobResponseBody
	GetJobId() *string
	SetRequestId(v string) *CreateLifecycleRetrieveJobResponseBody
	GetRequestId() *string
}

type CreateLifecycleRetrieveJobResponseBody struct {
	// The ID of the data retrieval task.
	//
	// example:
	//
	// lrj-nfstest-ia-160****853-hshvw
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The request ID.
	//
	// example:
	//
	// BC7C825C-5F65-4B56-BEF6-98C56C7C****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateLifecycleRetrieveJobResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CreateLifecycleRetrieveJobResponseBody) GoString() string {
	return s.String()
}

func (s *CreateLifecycleRetrieveJobResponseBody) GetJobId() *string {
	return s.JobId
}

func (s *CreateLifecycleRetrieveJobResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CreateLifecycleRetrieveJobResponseBody) SetJobId(v string) *CreateLifecycleRetrieveJobResponseBody {
	s.JobId = &v
	return s
}

func (s *CreateLifecycleRetrieveJobResponseBody) SetRequestId(v string) *CreateLifecycleRetrieveJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateLifecycleRetrieveJobResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCreateLifecycleRetrieveJobResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CreateLifecycleRetrieveJobResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CreateLifecycleRetrieveJobResponse
	GetStatusCode() *int32
	SetBody(v *CreateLifecycleRetrieveJobResponseBody) *CreateLifecycleRetrieveJobResponse
	GetBody() *CreateLifecycleRetrieveJobResponseBody
}

type CreateLifecycleRetrieveJobResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateLifecycleRetrieveJobResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateLifecycleRetrieveJobResponse) String() string {
	return dara.Prettify(s)
}

func (s CreateLifecycleRetrieveJobResponse) GoString() string {
	return s.String()
}

func (s *CreateLifecycleRetrieveJobResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CreateLifecycleRetrieveJobResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CreateLifecycleRetrieveJobResponse) GetBody() *CreateLifecycleRetrieveJobResponseBody {
	return s.Body
}

func (s *CreateLifecycleRetrieveJobResponse) SetHeaders(v map[string]*string) *CreateLifecycleRetrieveJobResponse {
	s.Headers = v
	return s
}

func (s *CreateLifecycleRetrieveJobResponse) SetStatusCode(v int32) *CreateLifecycleRetrieveJobResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateLifecycleRetrieveJobResponse) SetBody(v *CreateLifecycleRetrieveJobResponseBody) *CreateLifecycleRetrieveJobResponse {
	s.Body = v
	return s
}

func (s *CreateLifecycleRetrieveJobResponse) Validate() error {
	return dara.Validate(s)
}

type iCreateLogAnalysisRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *CreateLogAnalysisRequest
	GetFileSystemId() *string
	SetRegionId(v string) *CreateLogAnalysisRequest
	GetRegionId() *string
}

type CreateLogAnalysisRequest struct {
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 174494xxxx
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The region ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// cn-hangzhou
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s CreateLogAnalysisRequest) String() string {
	return dara.Prettify(s)
}

func (s CreateLogAnalysisRequest) GoString() string {
	return s.String()
}

func (s *CreateLogAnalysisRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *CreateLogAnalysisRequest) GetRegionId() *string {
	return s.RegionId
}

func (s *CreateLogAnalysisRequest) SetFileSystemId(v string) *CreateLogAnalysisRequest {
	s.FileSystemId = &v
	return s
}

func (s *CreateLogAnalysisRequest) SetRegionId(v string) *CreateLogAnalysisRequest {
	s.RegionId = &v
	return s
}

func (s *CreateLogAnalysisRequest) Validate() error {
	return dara.Validate(s)
}

type iCreateLogAnalysisResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *CreateLogAnalysisResponseBody
	GetRequestId() *string
}

type CreateLogAnalysisResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 5B4511A7-C99E-4071-AA8C-32E2529DA963
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateLogAnalysisResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CreateLogAnalysisResponseBody) GoString() string {
	return s.String()
}

func (s *CreateLogAnalysisResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CreateLogAnalysisResponseBody) SetRequestId(v string) *CreateLogAnalysisResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateLogAnalysisResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCreateLogAnalysisResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CreateLogAnalysisResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CreateLogAnalysisResponse
	GetStatusCode() *int32
	SetBody(v *CreateLogAnalysisResponseBody) *CreateLogAnalysisResponse
	GetBody() *CreateLogAnalysisResponseBody
}

type CreateLogAnalysisResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateLogAnalysisResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateLogAnalysisResponse) String() string {
	return dara.Prettify(s)
}

func (s CreateLogAnalysisResponse) GoString() string {
	return s.String()
}

func (s *CreateLogAnalysisResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CreateLogAnalysisResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CreateLogAnalysisResponse) GetBody() *CreateLogAnalysisResponseBody {
	return s.Body
}

func (s *CreateLogAnalysisResponse) SetHeaders(v map[string]*string) *CreateLogAnalysisResponse {
	s.Headers = v
	return s
}

func (s *CreateLogAnalysisResponse) SetStatusCode(v int32) *CreateLogAnalysisResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateLogAnalysisResponse) SetBody(v *CreateLogAnalysisResponseBody) *CreateLogAnalysisResponse {
	s.Body = v
	return s
}

func (s *CreateLogAnalysisResponse) Validate() error {
	return dara.Validate(s)
}

type iCreateMountTargetRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAccessGroupName(v string) *CreateMountTargetRequest
	GetAccessGroupName() *string
	SetDryRun(v bool) *CreateMountTargetRequest
	GetDryRun() *bool
	SetEnableIpv6(v bool) *CreateMountTargetRequest
	GetEnableIpv6() *bool
	SetFileSystemId(v string) *CreateMountTargetRequest
	GetFileSystemId() *string
	SetNetworkType(v string) *CreateMountTargetRequest
	GetNetworkType() *string
	SetSecurityGroupId(v string) *CreateMountTargetRequest
	GetSecurityGroupId() *string
	SetVSwitchId(v string) *CreateMountTargetRequest
	GetVSwitchId() *string
	SetVpcId(v string) *CreateMountTargetRequest
	GetVpcId() *string
}

type CreateMountTargetRequest struct {
	// The name of the permission group.
	//
	// This parameter is required if you create a mount target for a General-purpose NAS file system or an Extreme NAS file system.
	//
	// The default permission group for virtual private clouds (VPCs) is named DEFAULT_VPC_GROUP_NAME.
	//
	// example:
	//
	// vpc-test
	AccessGroupName *string `json:"AccessGroupName,omitempty" xml:"AccessGroupName,omitempty"`
	// Specifies whether to perform a dry run to check for existing mount targets. This parameter is valid only for CPFS file systems.
	//
	// If you set this parameter to true, the system checks whether the request parameters are valid and whether the requested resources are available. In this case, no mount target is created and no fee is incurred.
	//
	// 	- true: performs a dry run but does not create a mount target. In the dry run, the system checks the request format, service limits, available CPFS resources, and whether the required parameters are specified. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code `200` is returned. No value is returned for the `MountTargetDomain` parameter.
	//
	// 	- false (default): sends the request. If the request passes the dry run, a mount target is created.
	//
	// example:
	//
	// false
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// Specifies whether to create an IPv6 domain name for the mount target.
	//
	// Valid values:
	//
	// 	- true: An IPv6 domain name is created for the mount target.
	//
	// 	- false (default): No IPv6 domain name is created for the mount target.
	//
	// > Only Extreme NAS file systems that reside in the Chinese mainland support IPv6. If you want to create an IPv6 domain name for the mount target, you must enable IPv6 for the file system.
	//
	// example:
	//
	// true
	EnableIpv6 *bool `json:"EnableIpv6,omitempty" xml:"EnableIpv6,omitempty"`
	// The ID of the file system.
	//
	// 	- Sample ID of a General-purpose NAS file system: 31a8e4\\*\\*\\*\\*.
	//
	// 	- The IDs of Extreme NAS file systems must start with `extreme-`, for example, extreme-0015\\*\\*\\*\\*.
	//
	// 	- The IDs of Cloud Parallel File Storage (CPFS) file systems must start with `cpfs-`, for example, cpfs-125487\\*\\*\\*\\*.
	//
	// > CPFS file systems are available only on the China site (aliyun.com).
	//
	// This parameter is required.
	//
	// example:
	//
	// 174494****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The network type of the mount target. Valid value: **Vpc**.
	//
	// This parameter is required.
	//
	// example:
	//
	// Vpc
	NetworkType *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	// The ID of the security group.
	//
	// example:
	//
	// sg-bp1fg655nh68xyz9****
	SecurityGroupId *string `json:"SecurityGroupId,omitempty" xml:"SecurityGroupId,omitempty"`
	// The ID of the vSwitch.
	//
	// This parameter is valid and required if the mount target resides in a VPC. Example: If you set the NetworkType parameter to VPC, you must specify the VSwitchId parameter.
	//
	// example:
	//
	// vsw-2zevmwkwyztjuoffg****
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the VPC.
	//
	// This parameter is valid and required if the mount target resides in a VPC. Example: If you set the NetworkType parameter to VPC, you must specify the VpcId parameter.
	//
	// example:
	//
	// vpc-2zesj9afh3y518k9o****
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s CreateMountTargetRequest) String() string {
	return dara.Prettify(s)
}

func (s CreateMountTargetRequest) GoString() string {
	return s.String()
}

func (s *CreateMountTargetRequest) GetAccessGroupName() *string {
	return s.AccessGroupName
}

func (s *CreateMountTargetRequest) GetDryRun() *bool {
	return s.DryRun
}

func (s *CreateMountTargetRequest) GetEnableIpv6() *bool {
	return s.EnableIpv6
}

func (s *CreateMountTargetRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *CreateMountTargetRequest) GetNetworkType() *string {
	return s.NetworkType
}

func (s *CreateMountTargetRequest) GetSecurityGroupId() *string {
	return s.SecurityGroupId
}

func (s *CreateMountTargetRequest) GetVSwitchId() *string {
	return s.VSwitchId
}

func (s *CreateMountTargetRequest) GetVpcId() *string {
	return s.VpcId
}

func (s *CreateMountTargetRequest) SetAccessGroupName(v string) *CreateMountTargetRequest {
	s.AccessGroupName = &v
	return s
}

func (s *CreateMountTargetRequest) SetDryRun(v bool) *CreateMountTargetRequest {
	s.DryRun = &v
	return s
}

func (s *CreateMountTargetRequest) SetEnableIpv6(v bool) *CreateMountTargetRequest {
	s.EnableIpv6 = &v
	return s
}

func (s *CreateMountTargetRequest) SetFileSystemId(v string) *CreateMountTargetRequest {
	s.FileSystemId = &v
	return s
}

func (s *CreateMountTargetRequest) SetNetworkType(v string) *CreateMountTargetRequest {
	s.NetworkType = &v
	return s
}

func (s *CreateMountTargetRequest) SetSecurityGroupId(v string) *CreateMountTargetRequest {
	s.SecurityGroupId = &v
	return s
}

func (s *CreateMountTargetRequest) SetVSwitchId(v string) *CreateMountTargetRequest {
	s.VSwitchId = &v
	return s
}

func (s *CreateMountTargetRequest) SetVpcId(v string) *CreateMountTargetRequest {
	s.VpcId = &v
	return s
}

func (s *CreateMountTargetRequest) Validate() error {
	return dara.Validate(s)
}

type iCreateMountTargetResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetMountTargetDomain(v string) *CreateMountTargetResponseBody
	GetMountTargetDomain() *string
	SetMountTargetExtra(v *CreateMountTargetResponseBodyMountTargetExtra) *CreateMountTargetResponseBody
	GetMountTargetExtra() *CreateMountTargetResponseBodyMountTargetExtra
	SetRequestId(v string) *CreateMountTargetResponseBody
	GetRequestId() *string
}

type CreateMountTargetResponseBody struct {
	// The IPv4 domain name of the mount target.
	//
	// example:
	//
	// 174494b666-x****.cn-hangzhou.nas.aliyuncs.com
	MountTargetDomain *string `json:"MountTargetDomain,omitempty" xml:"MountTargetDomain,omitempty"`
	// The information about the mount target.
	MountTargetExtra *CreateMountTargetResponseBodyMountTargetExtra `json:"MountTargetExtra,omitempty" xml:"MountTargetExtra,omitempty" type:"Struct"`
	// The request ID.
	//
	// example:
	//
	// 70EACC9C-D07A-4A34-ADA4-77506C42****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateMountTargetResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CreateMountTargetResponseBody) GoString() string {
	return s.String()
}

func (s *CreateMountTargetResponseBody) GetMountTargetDomain() *string {
	return s.MountTargetDomain
}

func (s *CreateMountTargetResponseBody) GetMountTargetExtra() *CreateMountTargetResponseBodyMountTargetExtra {
	return s.MountTargetExtra
}

func (s *CreateMountTargetResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CreateMountTargetResponseBody) SetMountTargetDomain(v string) *CreateMountTargetResponseBody {
	s.MountTargetDomain = &v
	return s
}

func (s *CreateMountTargetResponseBody) SetMountTargetExtra(v *CreateMountTargetResponseBodyMountTargetExtra) *CreateMountTargetResponseBody {
	s.MountTargetExtra = v
	return s
}

func (s *CreateMountTargetResponseBody) SetRequestId(v string) *CreateMountTargetResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateMountTargetResponseBody) Validate() error {
	return dara.Validate(s)
}

type CreateMountTargetResponseBodyMountTargetExtra struct {
	// The dual-stack (IPv4 and IPv6) domain name of the mount target.
	//
	// example:
	//
	// 174494b666-x****.dualstack.cn-hangzhou.nas.aliyuncs.com
	DualStackMountTargetDomain *string `json:"DualStackMountTargetDomain,omitempty" xml:"DualStackMountTargetDomain,omitempty"`
}

func (s CreateMountTargetResponseBodyMountTargetExtra) String() string {
	return dara.Prettify(s)
}

func (s CreateMountTargetResponseBodyMountTargetExtra) GoString() string {
	return s.String()
}

func (s *CreateMountTargetResponseBodyMountTargetExtra) GetDualStackMountTargetDomain() *string {
	return s.DualStackMountTargetDomain
}

func (s *CreateMountTargetResponseBodyMountTargetExtra) SetDualStackMountTargetDomain(v string) *CreateMountTargetResponseBodyMountTargetExtra {
	s.DualStackMountTargetDomain = &v
	return s
}

func (s *CreateMountTargetResponseBodyMountTargetExtra) Validate() error {
	return dara.Validate(s)
}

type iCreateMountTargetResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CreateMountTargetResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CreateMountTargetResponse
	GetStatusCode() *int32
	SetBody(v *CreateMountTargetResponseBody) *CreateMountTargetResponse
	GetBody() *CreateMountTargetResponseBody
}

type CreateMountTargetResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateMountTargetResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateMountTargetResponse) String() string {
	return dara.Prettify(s)
}

func (s CreateMountTargetResponse) GoString() string {
	return s.String()
}

func (s *CreateMountTargetResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CreateMountTargetResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CreateMountTargetResponse) GetBody() *CreateMountTargetResponseBody {
	return s.Body
}

func (s *CreateMountTargetResponse) SetHeaders(v map[string]*string) *CreateMountTargetResponse {
	s.Headers = v
	return s
}

func (s *CreateMountTargetResponse) SetStatusCode(v int32) *CreateMountTargetResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateMountTargetResponse) SetBody(v *CreateMountTargetResponseBody) *CreateMountTargetResponse {
	s.Body = v
	return s
}

func (s *CreateMountTargetResponse) Validate() error {
	return dara.Validate(s)
}

type iCreateProtocolMountTargetRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAccessGroupName(v string) *CreateProtocolMountTargetRequest
	GetAccessGroupName() *string
	SetClientToken(v string) *CreateProtocolMountTargetRequest
	GetClientToken() *string
	SetDescription(v string) *CreateProtocolMountTargetRequest
	GetDescription() *string
	SetDryRun(v bool) *CreateProtocolMountTargetRequest
	GetDryRun() *bool
	SetFileSystemId(v string) *CreateProtocolMountTargetRequest
	GetFileSystemId() *string
	SetFsetId(v string) *CreateProtocolMountTargetRequest
	GetFsetId() *string
	SetPath(v string) *CreateProtocolMountTargetRequest
	GetPath() *string
	SetProtocolServiceId(v string) *CreateProtocolMountTargetRequest
	GetProtocolServiceId() *string
	SetVSwitchId(v string) *CreateProtocolMountTargetRequest
	GetVSwitchId() *string
	SetVpcId(v string) *CreateProtocolMountTargetRequest
	GetVpcId() *string
}

type CreateProtocolMountTargetRequest struct {
	// The name of the permission group.
	//
	// Default value: DEFAULT_VPC_GROUP_NAME.
	//
	// example:
	//
	// DEFAULT_VPC_GROUP_NAME
	AccessGroupName *string `json:"AccessGroupName,omitempty" xml:"AccessGroupName,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// >  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.
	//
	// example:
	//
	// 473469C7-AA6F-4DC5-B3DB-A3DC0DE3****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the export directory for the protocol service. The **name of the export directory*	- appears in the console.
	//
	// Limits:
	//
	// 	- The description must be 2 to 128 characters in length.
	//
	// 	- The description must start with a letter but cannot start with `http://` or `https://`.
	//
	// 	- The description can contain letters, digits, colons (:), underscores (_), and hyphens (-).
	//
	// example:
	//
	// test
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to perform a dry run. The dry run checks parameter validity and prerequisites. The dry run does not create an export directory or incur fees.
	//
	// Valid values:
	//
	// 	- true: performs a dry run. The system checks the request format, service limits, prerequisites, and whether the required parameters are specified. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the ExportId parameter.
	//
	// 	- false (default): performs a dry run and sends the request. If the request passes the dry run, an export directory is created.
	//
	// example:
	//
	// true
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// cpfs-123****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The ID of the fileset that you want to export.
	//
	// Limits:
	//
	// 	- The fileset already exists.
	//
	// 	- You can create only one export directory for a fileset.
	//
	// 	- You can specify either a fileset or a path.
	//
	// example:
	//
	// fset-123****
	FsetId *string `json:"FsetId,omitempty" xml:"FsetId,omitempty"`
	// The path of the CPFS directory that you want to export.
	//
	// Limits:
	//
	// 	- The directory already exists in the CPFS file system.
	//
	// 	- You can create only one export directory for a directory.
	//
	// 	- You can specify either a fileset or a path.
	//
	// Format:
	//
	// 	- The path must be 1 to 1,024 characters in length.
	//
	// 	- The path must be encoded in UTF-8.
	//
	// 	- The path must start and end with a forward slash (/). The root directory is `/`.
	//
	// example:
	//
	// /
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The ID of the protocol service.
	//
	// This parameter is required.
	//
	// example:
	//
	// ptc-123****
	ProtocolServiceId *string `json:"ProtocolServiceId,omitempty" xml:"ProtocolServiceId,omitempty"`
	// The vSwitch ID of the export directory for the protocol service.
	//
	// This parameter is required.
	//
	// example:
	//
	// vsw-123****
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The VPC ID of the export directory for the protocol service.
	//
	// This parameter is required.
	//
	// example:
	//
	// vpc-123****
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s CreateProtocolMountTargetRequest) String() string {
	return dara.Prettify(s)
}

func (s CreateProtocolMountTargetRequest) GoString() string {
	return s.String()
}

func (s *CreateProtocolMountTargetRequest) GetAccessGroupName() *string {
	return s.AccessGroupName
}

func (s *CreateProtocolMountTargetRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *CreateProtocolMountTargetRequest) GetDescription() *string {
	return s.Description
}

func (s *CreateProtocolMountTargetRequest) GetDryRun() *bool {
	return s.DryRun
}

func (s *CreateProtocolMountTargetRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *CreateProtocolMountTargetRequest) GetFsetId() *string {
	return s.FsetId
}

func (s *CreateProtocolMountTargetRequest) GetPath() *string {
	return s.Path
}

func (s *CreateProtocolMountTargetRequest) GetProtocolServiceId() *string {
	return s.ProtocolServiceId
}

func (s *CreateProtocolMountTargetRequest) GetVSwitchId() *string {
	return s.VSwitchId
}

func (s *CreateProtocolMountTargetRequest) GetVpcId() *string {
	return s.VpcId
}

func (s *CreateProtocolMountTargetRequest) SetAccessGroupName(v string) *CreateProtocolMountTargetRequest {
	s.AccessGroupName = &v
	return s
}

func (s *CreateProtocolMountTargetRequest) SetClientToken(v string) *CreateProtocolMountTargetRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateProtocolMountTargetRequest) SetDescription(v string) *CreateProtocolMountTargetRequest {
	s.Description = &v
	return s
}

func (s *CreateProtocolMountTargetRequest) SetDryRun(v bool) *CreateProtocolMountTargetRequest {
	s.DryRun = &v
	return s
}

func (s *CreateProtocolMountTargetRequest) SetFileSystemId(v string) *CreateProtocolMountTargetRequest {
	s.FileSystemId = &v
	return s
}

func (s *CreateProtocolMountTargetRequest) SetFsetId(v string) *CreateProtocolMountTargetRequest {
	s.FsetId = &v
	return s
}

func (s *CreateProtocolMountTargetRequest) SetPath(v string) *CreateProtocolMountTargetRequest {
	s.Path = &v
	return s
}

func (s *CreateProtocolMountTargetRequest) SetProtocolServiceId(v string) *CreateProtocolMountTargetRequest {
	s.ProtocolServiceId = &v
	return s
}

func (s *CreateProtocolMountTargetRequest) SetVSwitchId(v string) *CreateProtocolMountTargetRequest {
	s.VSwitchId = &v
	return s
}

func (s *CreateProtocolMountTargetRequest) SetVpcId(v string) *CreateProtocolMountTargetRequest {
	s.VpcId = &v
	return s
}

func (s *CreateProtocolMountTargetRequest) Validate() error {
	return dara.Validate(s)
}

type iCreateProtocolMountTargetResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetExportId(v string) *CreateProtocolMountTargetResponseBody
	GetExportId() *string
	SetRequestId(v string) *CreateProtocolMountTargetResponseBody
	GetRequestId() *string
}

type CreateProtocolMountTargetResponseBody struct {
	// The ID of the export directory for the protocol service.
	//
	// example:
	//
	// exp-123****
	ExportId *string `json:"ExportId,omitempty" xml:"ExportId,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateProtocolMountTargetResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CreateProtocolMountTargetResponseBody) GoString() string {
	return s.String()
}

func (s *CreateProtocolMountTargetResponseBody) GetExportId() *string {
	return s.ExportId
}

func (s *CreateProtocolMountTargetResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CreateProtocolMountTargetResponseBody) SetExportId(v string) *CreateProtocolMountTargetResponseBody {
	s.ExportId = &v
	return s
}

func (s *CreateProtocolMountTargetResponseBody) SetRequestId(v string) *CreateProtocolMountTargetResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateProtocolMountTargetResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCreateProtocolMountTargetResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CreateProtocolMountTargetResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CreateProtocolMountTargetResponse
	GetStatusCode() *int32
	SetBody(v *CreateProtocolMountTargetResponseBody) *CreateProtocolMountTargetResponse
	GetBody() *CreateProtocolMountTargetResponseBody
}

type CreateProtocolMountTargetResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateProtocolMountTargetResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateProtocolMountTargetResponse) String() string {
	return dara.Prettify(s)
}

func (s CreateProtocolMountTargetResponse) GoString() string {
	return s.String()
}

func (s *CreateProtocolMountTargetResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CreateProtocolMountTargetResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CreateProtocolMountTargetResponse) GetBody() *CreateProtocolMountTargetResponseBody {
	return s.Body
}

func (s *CreateProtocolMountTargetResponse) SetHeaders(v map[string]*string) *CreateProtocolMountTargetResponse {
	s.Headers = v
	return s
}

func (s *CreateProtocolMountTargetResponse) SetStatusCode(v int32) *CreateProtocolMountTargetResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateProtocolMountTargetResponse) SetBody(v *CreateProtocolMountTargetResponseBody) *CreateProtocolMountTargetResponse {
	s.Body = v
	return s
}

func (s *CreateProtocolMountTargetResponse) Validate() error {
	return dara.Validate(s)
}

type iCreateProtocolServiceRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientToken(v string) *CreateProtocolServiceRequest
	GetClientToken() *string
	SetDescription(v string) *CreateProtocolServiceRequest
	GetDescription() *string
	SetDryRun(v bool) *CreateProtocolServiceRequest
	GetDryRun() *bool
	SetFileSystemId(v string) *CreateProtocolServiceRequest
	GetFileSystemId() *string
	SetMountTargetAccessGroupName(v string) *CreateProtocolServiceRequest
	GetMountTargetAccessGroupName() *string
	SetMountTargetDescription(v string) *CreateProtocolServiceRequest
	GetMountTargetDescription() *string
	SetMountTargetFsetId(v string) *CreateProtocolServiceRequest
	GetMountTargetFsetId() *string
	SetMountTargetPath(v string) *CreateProtocolServiceRequest
	GetMountTargetPath() *string
	SetMountTargetVSwitchId(v string) *CreateProtocolServiceRequest
	GetMountTargetVSwitchId() *string
	SetMountTargetVpcId(v string) *CreateProtocolServiceRequest
	GetMountTargetVpcId() *string
	SetProtocolSpec(v string) *CreateProtocolServiceRequest
	GetProtocolSpec() *string
	SetProtocolType(v string) *CreateProtocolServiceRequest
	GetProtocolType() *string
	SetThroughput(v int32) *CreateProtocolServiceRequest
	GetThroughput() *int32
	SetVSwitchId(v string) *CreateProtocolServiceRequest
	GetVSwitchId() *string
	SetVpcId(v string) *CreateProtocolServiceRequest
	GetVpcId() *string
}

type CreateProtocolServiceRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// >  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-42665544****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the protocol service. The name of the protocol service appears in the console.
	//
	// Limits:
	//
	// 	- The description must be 2 to 128 characters in length.
	//
	// 	- The description must start with a letter and cannot start with `http://` or `https://`.
	//
	// 	- The description can contain letters, digits, colons (:), underscores (_), and hyphens (-).
	//
	// example:
	//
	// test
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to perform a dry run.
	//
	// The dry run checks parameter validity and prerequisites. The dry run does not create a protocol service or incur fees.
	//
	// Valid values:
	//
	// 	- true: performs only a dry run and does not create the protocol service. The system checks the request format, service limits, prerequisites, and whether the required parameters are specified. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the ProtocolServiceId parameter.
	//
	// 	- false (default): performs a dry run and sends the request. If the request passes the dry run, a protocol service is created.
	//
	// example:
	//
	// false
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// cpfs-123****
	FileSystemId               *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	MountTargetAccessGroupName *string `json:"MountTargetAccessGroupName,omitempty" xml:"MountTargetAccessGroupName,omitempty"`
	MountTargetDescription     *string `json:"MountTargetDescription,omitempty" xml:"MountTargetDescription,omitempty"`
	MountTargetFsetId          *string `json:"MountTargetFsetId,omitempty" xml:"MountTargetFsetId,omitempty"`
	MountTargetPath            *string `json:"MountTargetPath,omitempty" xml:"MountTargetPath,omitempty"`
	MountTargetVSwitchId       *string `json:"MountTargetVSwitchId,omitempty" xml:"MountTargetVSwitchId,omitempty"`
	MountTargetVpcId           *string `json:"MountTargetVpcId,omitempty" xml:"MountTargetVpcId,omitempty"`
	// The specification of the protocol service.
	//
	// Set the value to General (default).
	//
	// Valid values:
	//
	// 	- CL2
	//
	// 	- General
	//
	// 	- CL1
	//
	// This parameter is required.
	//
	// example:
	//
	// General
	ProtocolSpec *string `json:"ProtocolSpec,omitempty" xml:"ProtocolSpec,omitempty"`
	// The protocol type of the protocol service.
	//
	// Valid value: NFS (default). Only NFSv3 is supported.
	//
	// This parameter is required.
	//
	// example:
	//
	// NFS
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The throughput of the protocol service.
	//
	// Unit: MB/s.
	//
	// example:
	//
	// 8000
	Throughput *int32 `json:"Throughput,omitempty" xml:"Throughput,omitempty"`
	// The vSwitch ID of the protocol service.
	//
	// This parameter is required.
	//
	// example:
	//
	// vsw-123****
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The virtual private cloud (VPC) ID of the protocol service. The VPC ID of the protocol service must be the same as the VPC ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// vpc-123****
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s CreateProtocolServiceRequest) String() string {
	return dara.Prettify(s)
}

func (s CreateProtocolServiceRequest) GoString() string {
	return s.String()
}

func (s *CreateProtocolServiceRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *CreateProtocolServiceRequest) GetDescription() *string {
	return s.Description
}

func (s *CreateProtocolServiceRequest) GetDryRun() *bool {
	return s.DryRun
}

func (s *CreateProtocolServiceRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *CreateProtocolServiceRequest) GetMountTargetAccessGroupName() *string {
	return s.MountTargetAccessGroupName
}

func (s *CreateProtocolServiceRequest) GetMountTargetDescription() *string {
	return s.MountTargetDescription
}

func (s *CreateProtocolServiceRequest) GetMountTargetFsetId() *string {
	return s.MountTargetFsetId
}

func (s *CreateProtocolServiceRequest) GetMountTargetPath() *string {
	return s.MountTargetPath
}

func (s *CreateProtocolServiceRequest) GetMountTargetVSwitchId() *string {
	return s.MountTargetVSwitchId
}

func (s *CreateProtocolServiceRequest) GetMountTargetVpcId() *string {
	return s.MountTargetVpcId
}

func (s *CreateProtocolServiceRequest) GetProtocolSpec() *string {
	return s.ProtocolSpec
}

func (s *CreateProtocolServiceRequest) GetProtocolType() *string {
	return s.ProtocolType
}

func (s *CreateProtocolServiceRequest) GetThroughput() *int32 {
	return s.Throughput
}

func (s *CreateProtocolServiceRequest) GetVSwitchId() *string {
	return s.VSwitchId
}

func (s *CreateProtocolServiceRequest) GetVpcId() *string {
	return s.VpcId
}

func (s *CreateProtocolServiceRequest) SetClientToken(v string) *CreateProtocolServiceRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateProtocolServiceRequest) SetDescription(v string) *CreateProtocolServiceRequest {
	s.Description = &v
	return s
}

func (s *CreateProtocolServiceRequest) SetDryRun(v bool) *CreateProtocolServiceRequest {
	s.DryRun = &v
	return s
}

func (s *CreateProtocolServiceRequest) SetFileSystemId(v string) *CreateProtocolServiceRequest {
	s.FileSystemId = &v
	return s
}

func (s *CreateProtocolServiceRequest) SetMountTargetAccessGroupName(v string) *CreateProtocolServiceRequest {
	s.MountTargetAccessGroupName = &v
	return s
}

func (s *CreateProtocolServiceRequest) SetMountTargetDescription(v string) *CreateProtocolServiceRequest {
	s.MountTargetDescription = &v
	return s
}

func (s *CreateProtocolServiceRequest) SetMountTargetFsetId(v string) *CreateProtocolServiceRequest {
	s.MountTargetFsetId = &v
	return s
}

func (s *CreateProtocolServiceRequest) SetMountTargetPath(v string) *CreateProtocolServiceRequest {
	s.MountTargetPath = &v
	return s
}

func (s *CreateProtocolServiceRequest) SetMountTargetVSwitchId(v string) *CreateProtocolServiceRequest {
	s.MountTargetVSwitchId = &v
	return s
}

func (s *CreateProtocolServiceRequest) SetMountTargetVpcId(v string) *CreateProtocolServiceRequest {
	s.MountTargetVpcId = &v
	return s
}

func (s *CreateProtocolServiceRequest) SetProtocolSpec(v string) *CreateProtocolServiceRequest {
	s.ProtocolSpec = &v
	return s
}

func (s *CreateProtocolServiceRequest) SetProtocolType(v string) *CreateProtocolServiceRequest {
	s.ProtocolType = &v
	return s
}

func (s *CreateProtocolServiceRequest) SetThroughput(v int32) *CreateProtocolServiceRequest {
	s.Throughput = &v
	return s
}

func (s *CreateProtocolServiceRequest) SetVSwitchId(v string) *CreateProtocolServiceRequest {
	s.VSwitchId = &v
	return s
}

func (s *CreateProtocolServiceRequest) SetVpcId(v string) *CreateProtocolServiceRequest {
	s.VpcId = &v
	return s
}

func (s *CreateProtocolServiceRequest) Validate() error {
	return dara.Validate(s)
}

type iCreateProtocolServiceResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetProtocolServiceId(v string) *CreateProtocolServiceResponseBody
	GetProtocolServiceId() *string
	SetRequestId(v string) *CreateProtocolServiceResponseBody
	GetRequestId() *string
}

type CreateProtocolServiceResponseBody struct {
	// The ID of the protocol service.
	//
	// example:
	//
	// ptc-123****
	ProtocolServiceId *string `json:"ProtocolServiceId,omitempty" xml:"ProtocolServiceId,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 98696EF0-1607-4E9D-B01D-F20930B6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateProtocolServiceResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CreateProtocolServiceResponseBody) GoString() string {
	return s.String()
}

func (s *CreateProtocolServiceResponseBody) GetProtocolServiceId() *string {
	return s.ProtocolServiceId
}

func (s *CreateProtocolServiceResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CreateProtocolServiceResponseBody) SetProtocolServiceId(v string) *CreateProtocolServiceResponseBody {
	s.ProtocolServiceId = &v
	return s
}

func (s *CreateProtocolServiceResponseBody) SetRequestId(v string) *CreateProtocolServiceResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateProtocolServiceResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCreateProtocolServiceResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CreateProtocolServiceResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CreateProtocolServiceResponse
	GetStatusCode() *int32
	SetBody(v *CreateProtocolServiceResponseBody) *CreateProtocolServiceResponse
	GetBody() *CreateProtocolServiceResponseBody
}

type CreateProtocolServiceResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateProtocolServiceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateProtocolServiceResponse) String() string {
	return dara.Prettify(s)
}

func (s CreateProtocolServiceResponse) GoString() string {
	return s.String()
}

func (s *CreateProtocolServiceResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CreateProtocolServiceResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CreateProtocolServiceResponse) GetBody() *CreateProtocolServiceResponseBody {
	return s.Body
}

func (s *CreateProtocolServiceResponse) SetHeaders(v map[string]*string) *CreateProtocolServiceResponse {
	s.Headers = v
	return s
}

func (s *CreateProtocolServiceResponse) SetStatusCode(v int32) *CreateProtocolServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateProtocolServiceResponse) SetBody(v *CreateProtocolServiceResponseBody) *CreateProtocolServiceResponse {
	s.Body = v
	return s
}

func (s *CreateProtocolServiceResponse) Validate() error {
	return dara.Validate(s)
}

type iCreateRecycleBinDeleteJobRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientToken(v string) *CreateRecycleBinDeleteJobRequest
	GetClientToken() *string
	SetFileId(v string) *CreateRecycleBinDeleteJobRequest
	GetFileId() *string
	SetFileSystemId(v string) *CreateRecycleBinDeleteJobRequest
	GetFileSystemId() *string
}

type CreateRecycleBinDeleteJobRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// > If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-42665544****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the file or directory that you want to permanently delete.
	//
	// You can call the [ListRecycledDirectoriesAndFiles](https://help.aliyun.com/document_detail/264193.html) operation to query the value of the FileId parameter.
	//
	// This parameter is required.
	//
	// example:
	//
	// 04***08
	FileId *string `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1ca404****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
}

func (s CreateRecycleBinDeleteJobRequest) String() string {
	return dara.Prettify(s)
}

func (s CreateRecycleBinDeleteJobRequest) GoString() string {
	return s.String()
}

func (s *CreateRecycleBinDeleteJobRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *CreateRecycleBinDeleteJobRequest) GetFileId() *string {
	return s.FileId
}

func (s *CreateRecycleBinDeleteJobRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *CreateRecycleBinDeleteJobRequest) SetClientToken(v string) *CreateRecycleBinDeleteJobRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateRecycleBinDeleteJobRequest) SetFileId(v string) *CreateRecycleBinDeleteJobRequest {
	s.FileId = &v
	return s
}

func (s *CreateRecycleBinDeleteJobRequest) SetFileSystemId(v string) *CreateRecycleBinDeleteJobRequest {
	s.FileSystemId = &v
	return s
}

func (s *CreateRecycleBinDeleteJobRequest) Validate() error {
	return dara.Validate(s)
}

type iCreateRecycleBinDeleteJobResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetJobId(v string) *CreateRecycleBinDeleteJobResponseBody
	GetJobId() *string
	SetRequestId(v string) *CreateRecycleBinDeleteJobResponseBody
	GetRequestId() *string
}

type CreateRecycleBinDeleteJobResponseBody struct {
	// The job ID.
	//
	// example:
	//
	// 8C****C54
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 98696EF0-1607-4E9D-B01D-F20930B6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateRecycleBinDeleteJobResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CreateRecycleBinDeleteJobResponseBody) GoString() string {
	return s.String()
}

func (s *CreateRecycleBinDeleteJobResponseBody) GetJobId() *string {
	return s.JobId
}

func (s *CreateRecycleBinDeleteJobResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CreateRecycleBinDeleteJobResponseBody) SetJobId(v string) *CreateRecycleBinDeleteJobResponseBody {
	s.JobId = &v
	return s
}

func (s *CreateRecycleBinDeleteJobResponseBody) SetRequestId(v string) *CreateRecycleBinDeleteJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateRecycleBinDeleteJobResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCreateRecycleBinDeleteJobResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CreateRecycleBinDeleteJobResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CreateRecycleBinDeleteJobResponse
	GetStatusCode() *int32
	SetBody(v *CreateRecycleBinDeleteJobResponseBody) *CreateRecycleBinDeleteJobResponse
	GetBody() *CreateRecycleBinDeleteJobResponseBody
}

type CreateRecycleBinDeleteJobResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateRecycleBinDeleteJobResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateRecycleBinDeleteJobResponse) String() string {
	return dara.Prettify(s)
}

func (s CreateRecycleBinDeleteJobResponse) GoString() string {
	return s.String()
}

func (s *CreateRecycleBinDeleteJobResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CreateRecycleBinDeleteJobResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CreateRecycleBinDeleteJobResponse) GetBody() *CreateRecycleBinDeleteJobResponseBody {
	return s.Body
}

func (s *CreateRecycleBinDeleteJobResponse) SetHeaders(v map[string]*string) *CreateRecycleBinDeleteJobResponse {
	s.Headers = v
	return s
}

func (s *CreateRecycleBinDeleteJobResponse) SetStatusCode(v int32) *CreateRecycleBinDeleteJobResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateRecycleBinDeleteJobResponse) SetBody(v *CreateRecycleBinDeleteJobResponseBody) *CreateRecycleBinDeleteJobResponse {
	s.Body = v
	return s
}

func (s *CreateRecycleBinDeleteJobResponse) Validate() error {
	return dara.Validate(s)
}

type iCreateRecycleBinRestoreJobRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientToken(v string) *CreateRecycleBinRestoreJobRequest
	GetClientToken() *string
	SetFileId(v string) *CreateRecycleBinRestoreJobRequest
	GetFileId() *string
	SetFileSystemId(v string) *CreateRecycleBinRestoreJobRequest
	GetFileSystemId() *string
	SetTargetFileId(v string) *CreateRecycleBinRestoreJobRequest
	GetTargetFileId() *string
}

type CreateRecycleBinRestoreJobRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](https://help.aliyun.com/document_detail/25693.html).
	//
	// > If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-42665544****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the file or directory that you want to restore.
	//
	// You can call the [ListRecycleBinJobs](https://help.aliyun.com/document_detail/264192.html) operation to query the value of the FileId parameter.
	//
	// This parameter is required.
	//
	// example:
	//
	// 04***08
	FileId *string `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1ca404****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The ID of the directory to which the file is restored.
	//
	// This parameter is required.
	//
	// example:
	//
	// 13***15
	TargetFileId *string `json:"TargetFileId,omitempty" xml:"TargetFileId,omitempty"`
}

func (s CreateRecycleBinRestoreJobRequest) String() string {
	return dara.Prettify(s)
}

func (s CreateRecycleBinRestoreJobRequest) GoString() string {
	return s.String()
}

func (s *CreateRecycleBinRestoreJobRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *CreateRecycleBinRestoreJobRequest) GetFileId() *string {
	return s.FileId
}

func (s *CreateRecycleBinRestoreJobRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *CreateRecycleBinRestoreJobRequest) GetTargetFileId() *string {
	return s.TargetFileId
}

func (s *CreateRecycleBinRestoreJobRequest) SetClientToken(v string) *CreateRecycleBinRestoreJobRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateRecycleBinRestoreJobRequest) SetFileId(v string) *CreateRecycleBinRestoreJobRequest {
	s.FileId = &v
	return s
}

func (s *CreateRecycleBinRestoreJobRequest) SetFileSystemId(v string) *CreateRecycleBinRestoreJobRequest {
	s.FileSystemId = &v
	return s
}

func (s *CreateRecycleBinRestoreJobRequest) SetTargetFileId(v string) *CreateRecycleBinRestoreJobRequest {
	s.TargetFileId = &v
	return s
}

func (s *CreateRecycleBinRestoreJobRequest) Validate() error {
	return dara.Validate(s)
}

type iCreateRecycleBinRestoreJobResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetJobId(v string) *CreateRecycleBinRestoreJobResponseBody
	GetJobId() *string
	SetRequestId(v string) *CreateRecycleBinRestoreJobResponseBody
	GetRequestId() *string
}

type CreateRecycleBinRestoreJobResponseBody struct {
	// The job ID.
	//
	// example:
	//
	// rb-10****491ff-r-162****165400
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 98696EF0-1607-4E9D-B01D-F20930B6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateRecycleBinRestoreJobResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CreateRecycleBinRestoreJobResponseBody) GoString() string {
	return s.String()
}

func (s *CreateRecycleBinRestoreJobResponseBody) GetJobId() *string {
	return s.JobId
}

func (s *CreateRecycleBinRestoreJobResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CreateRecycleBinRestoreJobResponseBody) SetJobId(v string) *CreateRecycleBinRestoreJobResponseBody {
	s.JobId = &v
	return s
}

func (s *CreateRecycleBinRestoreJobResponseBody) SetRequestId(v string) *CreateRecycleBinRestoreJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateRecycleBinRestoreJobResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCreateRecycleBinRestoreJobResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CreateRecycleBinRestoreJobResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CreateRecycleBinRestoreJobResponse
	GetStatusCode() *int32
	SetBody(v *CreateRecycleBinRestoreJobResponseBody) *CreateRecycleBinRestoreJobResponse
	GetBody() *CreateRecycleBinRestoreJobResponseBody
}

type CreateRecycleBinRestoreJobResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateRecycleBinRestoreJobResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateRecycleBinRestoreJobResponse) String() string {
	return dara.Prettify(s)
}

func (s CreateRecycleBinRestoreJobResponse) GoString() string {
	return s.String()
}

func (s *CreateRecycleBinRestoreJobResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CreateRecycleBinRestoreJobResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CreateRecycleBinRestoreJobResponse) GetBody() *CreateRecycleBinRestoreJobResponseBody {
	return s.Body
}

func (s *CreateRecycleBinRestoreJobResponse) SetHeaders(v map[string]*string) *CreateRecycleBinRestoreJobResponse {
	s.Headers = v
	return s
}

func (s *CreateRecycleBinRestoreJobResponse) SetStatusCode(v int32) *CreateRecycleBinRestoreJobResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateRecycleBinRestoreJobResponse) SetBody(v *CreateRecycleBinRestoreJobResponseBody) *CreateRecycleBinRestoreJobResponse {
	s.Body = v
	return s
}

func (s *CreateRecycleBinRestoreJobResponse) Validate() error {
	return dara.Validate(s)
}

type iCreateServicePolicyRequest interface {
	dara.Model
	String() string
	GoString() string
	SetServiceLinkedRoleName(v string) *CreateServicePolicyRequest
	GetServiceLinkedRoleName() *string
}

type CreateServicePolicyRequest struct {
	// This parameter is required.
	ServiceLinkedRoleName *string `json:"ServiceLinkedRoleName,omitempty" xml:"ServiceLinkedRoleName,omitempty"`
}

func (s CreateServicePolicyRequest) String() string {
	return dara.Prettify(s)
}

func (s CreateServicePolicyRequest) GoString() string {
	return s.String()
}

func (s *CreateServicePolicyRequest) GetServiceLinkedRoleName() *string {
	return s.ServiceLinkedRoleName
}

func (s *CreateServicePolicyRequest) SetServiceLinkedRoleName(v string) *CreateServicePolicyRequest {
	s.ServiceLinkedRoleName = &v
	return s
}

func (s *CreateServicePolicyRequest) Validate() error {
	return dara.Validate(s)
}

type iCreateServicePolicyResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *CreateServicePolicyResponseBody
	GetRequestId() *string
	SetSuccess(v bool) *CreateServicePolicyResponseBody
	GetSuccess() *bool
}

type CreateServicePolicyResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateServicePolicyResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CreateServicePolicyResponseBody) GoString() string {
	return s.String()
}

func (s *CreateServicePolicyResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CreateServicePolicyResponseBody) GetSuccess() *bool {
	return s.Success
}

func (s *CreateServicePolicyResponseBody) SetRequestId(v string) *CreateServicePolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateServicePolicyResponseBody) SetSuccess(v bool) *CreateServicePolicyResponseBody {
	s.Success = &v
	return s
}

func (s *CreateServicePolicyResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCreateServicePolicyResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CreateServicePolicyResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CreateServicePolicyResponse
	GetStatusCode() *int32
	SetBody(v *CreateServicePolicyResponseBody) *CreateServicePolicyResponse
	GetBody() *CreateServicePolicyResponseBody
}

type CreateServicePolicyResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateServicePolicyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateServicePolicyResponse) String() string {
	return dara.Prettify(s)
}

func (s CreateServicePolicyResponse) GoString() string {
	return s.String()
}

func (s *CreateServicePolicyResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CreateServicePolicyResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CreateServicePolicyResponse) GetBody() *CreateServicePolicyResponseBody {
	return s.Body
}

func (s *CreateServicePolicyResponse) SetHeaders(v map[string]*string) *CreateServicePolicyResponse {
	s.Headers = v
	return s
}

func (s *CreateServicePolicyResponse) SetStatusCode(v int32) *CreateServicePolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateServicePolicyResponse) SetBody(v *CreateServicePolicyResponseBody) *CreateServicePolicyResponse {
	s.Body = v
	return s
}

func (s *CreateServicePolicyResponse) Validate() error {
	return dara.Validate(s)
}

type iCreateSnapshotRequest interface {
	dara.Model
	String() string
	GoString() string
	SetDescription(v string) *CreateSnapshotRequest
	GetDescription() *string
	SetFileSystemId(v string) *CreateSnapshotRequest
	GetFileSystemId() *string
	SetRetentionDays(v int32) *CreateSnapshotRequest
	GetRetentionDays() *int32
	SetSnapshotName(v string) *CreateSnapshotRequest
	GetSnapshotName() *string
}

type CreateSnapshotRequest struct {
	// The description of the snapshot.
	//
	// Limits:
	//
	// 	- The description must be 2 to 256 characters in length.
	//
	// 	- The description cannot start with `http://` or `https://`.
	//
	// 	- This parameter is empty by default.
	//
	// example:
	//
	// FinanceDepet
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the advanced Extreme NAS file system. The value must start with `extreme-`, for example, `extreme-01dd****`.
	//
	// This parameter is required.
	//
	// example:
	//
	// extreme-01dd****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The retention period of the snapshot.
	//
	// Unit: days.
	//
	// Valid values:
	//
	// 	- \\-1 (default). Auto snapshots are permanently retained. After the number of auto snapshots exceeds the upper limit, the earliest auto snapshot is automatically deleted.
	//
	// 	- 1 to 65536: Auto snapshots are retained for the specified days. After the retention period of auto snapshots expires, the auto snapshots are automatically deleted.
	//
	// example:
	//
	// 30
	RetentionDays *int32 `json:"RetentionDays,omitempty" xml:"RetentionDays,omitempty"`
	// The snapshot name.
	//
	// Limits:
	//
	// 	- The name must be 2 to 128 characters in length. The name must start with a letter and cannot start with `http://` or `https://`.
	//
	// 	- The name can contain letters, digits, colons (:), underscores (_), and hyphens (-).
	//
	// 	- The name cannot start with auto because snapshots whose names start with auto are recognized as auto snapshots.
	//
	// example:
	//
	// FinanceJoshua
	SnapshotName *string `json:"SnapshotName,omitempty" xml:"SnapshotName,omitempty"`
}

func (s CreateSnapshotRequest) String() string {
	return dara.Prettify(s)
}

func (s CreateSnapshotRequest) GoString() string {
	return s.String()
}

func (s *CreateSnapshotRequest) GetDescription() *string {
	return s.Description
}

func (s *CreateSnapshotRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *CreateSnapshotRequest) GetRetentionDays() *int32 {
	return s.RetentionDays
}

func (s *CreateSnapshotRequest) GetSnapshotName() *string {
	return s.SnapshotName
}

func (s *CreateSnapshotRequest) SetDescription(v string) *CreateSnapshotRequest {
	s.Description = &v
	return s
}

func (s *CreateSnapshotRequest) SetFileSystemId(v string) *CreateSnapshotRequest {
	s.FileSystemId = &v
	return s
}

func (s *CreateSnapshotRequest) SetRetentionDays(v int32) *CreateSnapshotRequest {
	s.RetentionDays = &v
	return s
}

func (s *CreateSnapshotRequest) SetSnapshotName(v string) *CreateSnapshotRequest {
	s.SnapshotName = &v
	return s
}

func (s *CreateSnapshotRequest) Validate() error {
	return dara.Validate(s)
}

type iCreateSnapshotResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *CreateSnapshotResponseBody
	GetRequestId() *string
	SetSnapshotId(v string) *CreateSnapshotResponseBody
	GetSnapshotId() *string
}

type CreateSnapshotResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 473469C7-AA6F-4DC5-B3DB-A3DC0DE3****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The snapshot ID.
	//
	// example:
	//
	// s-extreme-snapsho****
	SnapshotId *string `json:"SnapshotId,omitempty" xml:"SnapshotId,omitempty"`
}

func (s CreateSnapshotResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CreateSnapshotResponseBody) GoString() string {
	return s.String()
}

func (s *CreateSnapshotResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CreateSnapshotResponseBody) GetSnapshotId() *string {
	return s.SnapshotId
}

func (s *CreateSnapshotResponseBody) SetRequestId(v string) *CreateSnapshotResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateSnapshotResponseBody) SetSnapshotId(v string) *CreateSnapshotResponseBody {
	s.SnapshotId = &v
	return s
}

func (s *CreateSnapshotResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCreateSnapshotResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CreateSnapshotResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CreateSnapshotResponse
	GetStatusCode() *int32
	SetBody(v *CreateSnapshotResponseBody) *CreateSnapshotResponse
	GetBody() *CreateSnapshotResponseBody
}

type CreateSnapshotResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateSnapshotResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateSnapshotResponse) String() string {
	return dara.Prettify(s)
}

func (s CreateSnapshotResponse) GoString() string {
	return s.String()
}

func (s *CreateSnapshotResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CreateSnapshotResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CreateSnapshotResponse) GetBody() *CreateSnapshotResponseBody {
	return s.Body
}

func (s *CreateSnapshotResponse) SetHeaders(v map[string]*string) *CreateSnapshotResponse {
	s.Headers = v
	return s
}

func (s *CreateSnapshotResponse) SetStatusCode(v int32) *CreateSnapshotResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateSnapshotResponse) SetBody(v *CreateSnapshotResponseBody) *CreateSnapshotResponse {
	s.Body = v
	return s
}

func (s *CreateSnapshotResponse) Validate() error {
	return dara.Validate(s)
}

type iCreateVscMountPointRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *CreateVscMountPointRequest
	GetFileSystemId() *string
}

type CreateVscMountPointRequest struct {
	// This parameter is required.
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
}

func (s CreateVscMountPointRequest) String() string {
	return dara.Prettify(s)
}

func (s CreateVscMountPointRequest) GoString() string {
	return s.String()
}

func (s *CreateVscMountPointRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *CreateVscMountPointRequest) SetFileSystemId(v string) *CreateVscMountPointRequest {
	s.FileSystemId = &v
	return s
}

func (s *CreateVscMountPointRequest) Validate() error {
	return dara.Validate(s)
}

type iCreateVscMountPointResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetMountPointDomain(v string) *CreateVscMountPointResponseBody
	GetMountPointDomain() *string
	SetRequestId(v string) *CreateVscMountPointResponseBody
	GetRequestId() *string
}

type CreateVscMountPointResponseBody struct {
	MountPointDomain *string `json:"MountPointDomain,omitempty" xml:"MountPointDomain,omitempty"`
	RequestId        *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateVscMountPointResponseBody) String() string {
	return dara.Prettify(s)
}

func (s CreateVscMountPointResponseBody) GoString() string {
	return s.String()
}

func (s *CreateVscMountPointResponseBody) GetMountPointDomain() *string {
	return s.MountPointDomain
}

func (s *CreateVscMountPointResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *CreateVscMountPointResponseBody) SetMountPointDomain(v string) *CreateVscMountPointResponseBody {
	s.MountPointDomain = &v
	return s
}

func (s *CreateVscMountPointResponseBody) SetRequestId(v string) *CreateVscMountPointResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateVscMountPointResponseBody) Validate() error {
	return dara.Validate(s)
}

type iCreateVscMountPointResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *CreateVscMountPointResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *CreateVscMountPointResponse
	GetStatusCode() *int32
	SetBody(v *CreateVscMountPointResponseBody) *CreateVscMountPointResponse
	GetBody() *CreateVscMountPointResponseBody
}

type CreateVscMountPointResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateVscMountPointResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateVscMountPointResponse) String() string {
	return dara.Prettify(s)
}

func (s CreateVscMountPointResponse) GoString() string {
	return s.String()
}

func (s *CreateVscMountPointResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *CreateVscMountPointResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *CreateVscMountPointResponse) GetBody() *CreateVscMountPointResponseBody {
	return s.Body
}

func (s *CreateVscMountPointResponse) SetHeaders(v map[string]*string) *CreateVscMountPointResponse {
	s.Headers = v
	return s
}

func (s *CreateVscMountPointResponse) SetStatusCode(v int32) *CreateVscMountPointResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateVscMountPointResponse) SetBody(v *CreateVscMountPointResponseBody) *CreateVscMountPointResponse {
	s.Body = v
	return s
}

func (s *CreateVscMountPointResponse) Validate() error {
	return dara.Validate(s)
}

type iDeleteAccessGroupRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAccessGroupName(v string) *DeleteAccessGroupRequest
	GetAccessGroupName() *string
	SetFileSystemType(v string) *DeleteAccessGroupRequest
	GetFileSystemType() *string
}

type DeleteAccessGroupRequest struct {
	// The name of the permission group to be deleted.
	//
	// This parameter is required.
	//
	// example:
	//
	// vpc-test
	AccessGroupName *string `json:"AccessGroupName,omitempty" xml:"AccessGroupName,omitempty"`
	// The type of the file system.
	//
	// Valid values:
	//
	// 	- standard (default): General-purpose NAS file system
	//
	// 	- extreme: Extreme NAS file system
	//
	// example:
	//
	// standard
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
}

func (s DeleteAccessGroupRequest) String() string {
	return dara.Prettify(s)
}

func (s DeleteAccessGroupRequest) GoString() string {
	return s.String()
}

func (s *DeleteAccessGroupRequest) GetAccessGroupName() *string {
	return s.AccessGroupName
}

func (s *DeleteAccessGroupRequest) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *DeleteAccessGroupRequest) SetAccessGroupName(v string) *DeleteAccessGroupRequest {
	s.AccessGroupName = &v
	return s
}

func (s *DeleteAccessGroupRequest) SetFileSystemType(v string) *DeleteAccessGroupRequest {
	s.FileSystemType = &v
	return s
}

func (s *DeleteAccessGroupRequest) Validate() error {
	return dara.Validate(s)
}

type iDeleteAccessGroupResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *DeleteAccessGroupResponseBody
	GetRequestId() *string
}

type DeleteAccessGroupResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 9E15E394-38A6-457A-A62A-D9797C9A****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAccessGroupResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DeleteAccessGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAccessGroupResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DeleteAccessGroupResponseBody) SetRequestId(v string) *DeleteAccessGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteAccessGroupResponseBody) Validate() error {
	return dara.Validate(s)
}

type iDeleteAccessGroupResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DeleteAccessGroupResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DeleteAccessGroupResponse
	GetStatusCode() *int32
	SetBody(v *DeleteAccessGroupResponseBody) *DeleteAccessGroupResponse
	GetBody() *DeleteAccessGroupResponseBody
}

type DeleteAccessGroupResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteAccessGroupResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteAccessGroupResponse) String() string {
	return dara.Prettify(s)
}

func (s DeleteAccessGroupResponse) GoString() string {
	return s.String()
}

func (s *DeleteAccessGroupResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DeleteAccessGroupResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DeleteAccessGroupResponse) GetBody() *DeleteAccessGroupResponseBody {
	return s.Body
}

func (s *DeleteAccessGroupResponse) SetHeaders(v map[string]*string) *DeleteAccessGroupResponse {
	s.Headers = v
	return s
}

func (s *DeleteAccessGroupResponse) SetStatusCode(v int32) *DeleteAccessGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAccessGroupResponse) SetBody(v *DeleteAccessGroupResponseBody) *DeleteAccessGroupResponse {
	s.Body = v
	return s
}

func (s *DeleteAccessGroupResponse) Validate() error {
	return dara.Validate(s)
}

type iDeleteAccessPointRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAccessPointId(v string) *DeleteAccessPointRequest
	GetAccessPointId() *string
	SetFileSystemId(v string) *DeleteAccessPointRequest
	GetFileSystemId() *string
}

type DeleteAccessPointRequest struct {
	// The ID of the access point.
	//
	// This parameter is required.
	//
	// example:
	//
	// ap-ie15yd****
	AccessPointId *string `json:"AccessPointId,omitempty" xml:"AccessPointId,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1ca404****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
}

func (s DeleteAccessPointRequest) String() string {
	return dara.Prettify(s)
}

func (s DeleteAccessPointRequest) GoString() string {
	return s.String()
}

func (s *DeleteAccessPointRequest) GetAccessPointId() *string {
	return s.AccessPointId
}

func (s *DeleteAccessPointRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DeleteAccessPointRequest) SetAccessPointId(v string) *DeleteAccessPointRequest {
	s.AccessPointId = &v
	return s
}

func (s *DeleteAccessPointRequest) SetFileSystemId(v string) *DeleteAccessPointRequest {
	s.FileSystemId = &v
	return s
}

func (s *DeleteAccessPointRequest) Validate() error {
	return dara.Validate(s)
}

type iDeleteAccessPointResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *DeleteAccessPointResponseBody
	GetRequestId() *string
}

type DeleteAccessPointResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 98696EF0-1607-4E9D-B01D-F20930B6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAccessPointResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DeleteAccessPointResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAccessPointResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DeleteAccessPointResponseBody) SetRequestId(v string) *DeleteAccessPointResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteAccessPointResponseBody) Validate() error {
	return dara.Validate(s)
}

type iDeleteAccessPointResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DeleteAccessPointResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DeleteAccessPointResponse
	GetStatusCode() *int32
	SetBody(v *DeleteAccessPointResponseBody) *DeleteAccessPointResponse
	GetBody() *DeleteAccessPointResponseBody
}

type DeleteAccessPointResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteAccessPointResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteAccessPointResponse) String() string {
	return dara.Prettify(s)
}

func (s DeleteAccessPointResponse) GoString() string {
	return s.String()
}

func (s *DeleteAccessPointResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DeleteAccessPointResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DeleteAccessPointResponse) GetBody() *DeleteAccessPointResponseBody {
	return s.Body
}

func (s *DeleteAccessPointResponse) SetHeaders(v map[string]*string) *DeleteAccessPointResponse {
	s.Headers = v
	return s
}

func (s *DeleteAccessPointResponse) SetStatusCode(v int32) *DeleteAccessPointResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAccessPointResponse) SetBody(v *DeleteAccessPointResponseBody) *DeleteAccessPointResponse {
	s.Body = v
	return s
}

func (s *DeleteAccessPointResponse) Validate() error {
	return dara.Validate(s)
}

type iDeleteAccessRuleRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAccessGroupName(v string) *DeleteAccessRuleRequest
	GetAccessGroupName() *string
	SetAccessRuleId(v string) *DeleteAccessRuleRequest
	GetAccessRuleId() *string
	SetFileSystemType(v string) *DeleteAccessRuleRequest
	GetFileSystemType() *string
}

type DeleteAccessRuleRequest struct {
	// The name of the permission group.
	//
	// This parameter is required.
	//
	// example:
	//
	// vpc-test
	AccessGroupName *string `json:"AccessGroupName,omitempty" xml:"AccessGroupName,omitempty"`
	// The rule ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1
	AccessRuleId *string `json:"AccessRuleId,omitempty" xml:"AccessRuleId,omitempty"`
	// The type of the file system.
	//
	// Valid values:
	//
	// 	- standard (default): General-purpose NAS file system
	//
	// 	- extreme: Extreme NAS file system
	//
	// example:
	//
	// standard
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
}

func (s DeleteAccessRuleRequest) String() string {
	return dara.Prettify(s)
}

func (s DeleteAccessRuleRequest) GoString() string {
	return s.String()
}

func (s *DeleteAccessRuleRequest) GetAccessGroupName() *string {
	return s.AccessGroupName
}

func (s *DeleteAccessRuleRequest) GetAccessRuleId() *string {
	return s.AccessRuleId
}

func (s *DeleteAccessRuleRequest) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *DeleteAccessRuleRequest) SetAccessGroupName(v string) *DeleteAccessRuleRequest {
	s.AccessGroupName = &v
	return s
}

func (s *DeleteAccessRuleRequest) SetAccessRuleId(v string) *DeleteAccessRuleRequest {
	s.AccessRuleId = &v
	return s
}

func (s *DeleteAccessRuleRequest) SetFileSystemType(v string) *DeleteAccessRuleRequest {
	s.FileSystemType = &v
	return s
}

func (s *DeleteAccessRuleRequest) Validate() error {
	return dara.Validate(s)
}

type iDeleteAccessRuleResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *DeleteAccessRuleResponseBody
	GetRequestId() *string
}

type DeleteAccessRuleResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 5B4511A7-C99E-4071-AA8C-32E2529D****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAccessRuleResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DeleteAccessRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAccessRuleResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DeleteAccessRuleResponseBody) SetRequestId(v string) *DeleteAccessRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteAccessRuleResponseBody) Validate() error {
	return dara.Validate(s)
}

type iDeleteAccessRuleResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DeleteAccessRuleResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DeleteAccessRuleResponse
	GetStatusCode() *int32
	SetBody(v *DeleteAccessRuleResponseBody) *DeleteAccessRuleResponse
	GetBody() *DeleteAccessRuleResponseBody
}

type DeleteAccessRuleResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteAccessRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteAccessRuleResponse) String() string {
	return dara.Prettify(s)
}

func (s DeleteAccessRuleResponse) GoString() string {
	return s.String()
}

func (s *DeleteAccessRuleResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DeleteAccessRuleResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DeleteAccessRuleResponse) GetBody() *DeleteAccessRuleResponseBody {
	return s.Body
}

func (s *DeleteAccessRuleResponse) SetHeaders(v map[string]*string) *DeleteAccessRuleResponse {
	s.Headers = v
	return s
}

func (s *DeleteAccessRuleResponse) SetStatusCode(v int32) *DeleteAccessRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAccessRuleResponse) SetBody(v *DeleteAccessRuleResponseBody) *DeleteAccessRuleResponse {
	s.Body = v
	return s
}

func (s *DeleteAccessRuleResponse) Validate() error {
	return dara.Validate(s)
}

type iDeleteAutoSnapshotPolicyRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAutoSnapshotPolicyId(v string) *DeleteAutoSnapshotPolicyRequest
	GetAutoSnapshotPolicyId() *string
}

type DeleteAutoSnapshotPolicyRequest struct {
	// The ID of the automatic snapshot policy.
	//
	// You can call the [DescribeAutoSnapshotPolicies](https://help.aliyun.com/document_detail/126583.html) operation to view available automatic snapshot policies.
	//
	// This parameter is required.
	//
	// example:
	//
	// sp-extreme-233e6****
	AutoSnapshotPolicyId *string `json:"AutoSnapshotPolicyId,omitempty" xml:"AutoSnapshotPolicyId,omitempty"`
}

func (s DeleteAutoSnapshotPolicyRequest) String() string {
	return dara.Prettify(s)
}

func (s DeleteAutoSnapshotPolicyRequest) GoString() string {
	return s.String()
}

func (s *DeleteAutoSnapshotPolicyRequest) GetAutoSnapshotPolicyId() *string {
	return s.AutoSnapshotPolicyId
}

func (s *DeleteAutoSnapshotPolicyRequest) SetAutoSnapshotPolicyId(v string) *DeleteAutoSnapshotPolicyRequest {
	s.AutoSnapshotPolicyId = &v
	return s
}

func (s *DeleteAutoSnapshotPolicyRequest) Validate() error {
	return dara.Validate(s)
}

type iDeleteAutoSnapshotPolicyResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *DeleteAutoSnapshotPolicyResponseBody
	GetRequestId() *string
}

type DeleteAutoSnapshotPolicyResponseBody struct {
	// The request ID.
	//
	// Every response returns a unique request ID regardless of whether the request is successful.
	//
	// example:
	//
	// 473469C7-AA6F-4DC5-B3DB-A3DC0DE3****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAutoSnapshotPolicyResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DeleteAutoSnapshotPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAutoSnapshotPolicyResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DeleteAutoSnapshotPolicyResponseBody) SetRequestId(v string) *DeleteAutoSnapshotPolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteAutoSnapshotPolicyResponseBody) Validate() error {
	return dara.Validate(s)
}

type iDeleteAutoSnapshotPolicyResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DeleteAutoSnapshotPolicyResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DeleteAutoSnapshotPolicyResponse
	GetStatusCode() *int32
	SetBody(v *DeleteAutoSnapshotPolicyResponseBody) *DeleteAutoSnapshotPolicyResponse
	GetBody() *DeleteAutoSnapshotPolicyResponseBody
}

type DeleteAutoSnapshotPolicyResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteAutoSnapshotPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteAutoSnapshotPolicyResponse) String() string {
	return dara.Prettify(s)
}

func (s DeleteAutoSnapshotPolicyResponse) GoString() string {
	return s.String()
}

func (s *DeleteAutoSnapshotPolicyResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DeleteAutoSnapshotPolicyResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DeleteAutoSnapshotPolicyResponse) GetBody() *DeleteAutoSnapshotPolicyResponseBody {
	return s.Body
}

func (s *DeleteAutoSnapshotPolicyResponse) SetHeaders(v map[string]*string) *DeleteAutoSnapshotPolicyResponse {
	s.Headers = v
	return s
}

func (s *DeleteAutoSnapshotPolicyResponse) SetStatusCode(v int32) *DeleteAutoSnapshotPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAutoSnapshotPolicyResponse) SetBody(v *DeleteAutoSnapshotPolicyResponseBody) *DeleteAutoSnapshotPolicyResponse {
	s.Body = v
	return s
}

func (s *DeleteAutoSnapshotPolicyResponse) Validate() error {
	return dara.Validate(s)
}

type iDeleteDataFlowRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientToken(v string) *DeleteDataFlowRequest
	GetClientToken() *string
	SetDataFlowId(v string) *DeleteDataFlowRequest
	GetDataFlowId() *string
	SetDryRun(v bool) *DeleteDataFlowRequest
	GetDryRun() *bool
	SetFileSystemId(v string) *DeleteDataFlowRequest
	GetFileSystemId() *string
}

type DeleteDataFlowRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// >  If you do not specify this parameter, the system automatically uses the request ID as the client token. The value of RequestId may be different for each API request.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-42665544****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The dataflow ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// df-194433a5be31****
	DataFlowId *string `json:"DataFlowId,omitempty" xml:"DataFlowId,omitempty"`
	// Specifies whether to perform a dry run.
	//
	// During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no file system is created and no fee is incurred.
	//
	// Valid values:
	//
	// 	- true: performs a dry run. The system checks the required parameters, request syntax, limits, and available NAS resources. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the FileSystemId parameter.
	//
	// 	- false (default): performs a dry run and sends the request. If the request passes the dry run, a file system is created.
	//
	// example:
	//
	// false
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the file system.
	//
	// 	- The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-125487\\*\\*\\*\\*.
	//
	// 	- The IDs of CPFS for LINGJUN file systems must start with `bmcpfs-`. Example: bmcpfs-0015\\*\\*\\*\\*.
	//
	// >  CPFS is not supported on the international site.
	//
	// This parameter is required.
	//
	// example:
	//
	// cpfs-099394bd928c****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
}

func (s DeleteDataFlowRequest) String() string {
	return dara.Prettify(s)
}

func (s DeleteDataFlowRequest) GoString() string {
	return s.String()
}

func (s *DeleteDataFlowRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *DeleteDataFlowRequest) GetDataFlowId() *string {
	return s.DataFlowId
}

func (s *DeleteDataFlowRequest) GetDryRun() *bool {
	return s.DryRun
}

func (s *DeleteDataFlowRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DeleteDataFlowRequest) SetClientToken(v string) *DeleteDataFlowRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteDataFlowRequest) SetDataFlowId(v string) *DeleteDataFlowRequest {
	s.DataFlowId = &v
	return s
}

func (s *DeleteDataFlowRequest) SetDryRun(v bool) *DeleteDataFlowRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteDataFlowRequest) SetFileSystemId(v string) *DeleteDataFlowRequest {
	s.FileSystemId = &v
	return s
}

func (s *DeleteDataFlowRequest) Validate() error {
	return dara.Validate(s)
}

type iDeleteDataFlowResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *DeleteDataFlowResponseBody
	GetRequestId() *string
}

type DeleteDataFlowResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 98696EF0-1607-4E9D-B01D-F20930B6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDataFlowResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DeleteDataFlowResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDataFlowResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DeleteDataFlowResponseBody) SetRequestId(v string) *DeleteDataFlowResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteDataFlowResponseBody) Validate() error {
	return dara.Validate(s)
}

type iDeleteDataFlowResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DeleteDataFlowResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DeleteDataFlowResponse
	GetStatusCode() *int32
	SetBody(v *DeleteDataFlowResponseBody) *DeleteDataFlowResponse
	GetBody() *DeleteDataFlowResponseBody
}

type DeleteDataFlowResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteDataFlowResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteDataFlowResponse) String() string {
	return dara.Prettify(s)
}

func (s DeleteDataFlowResponse) GoString() string {
	return s.String()
}

func (s *DeleteDataFlowResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DeleteDataFlowResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DeleteDataFlowResponse) GetBody() *DeleteDataFlowResponseBody {
	return s.Body
}

func (s *DeleteDataFlowResponse) SetHeaders(v map[string]*string) *DeleteDataFlowResponse {
	s.Headers = v
	return s
}

func (s *DeleteDataFlowResponse) SetStatusCode(v int32) *DeleteDataFlowResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDataFlowResponse) SetBody(v *DeleteDataFlowResponseBody) *DeleteDataFlowResponse {
	s.Body = v
	return s
}

func (s *DeleteDataFlowResponse) Validate() error {
	return dara.Validate(s)
}

type iDeleteFileSystemRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *DeleteFileSystemRequest
	GetFileSystemId() *string
}

type DeleteFileSystemRequest struct {
	// The ID of the file system that you want to delete.
	//
	// 	- Sample ID of a General-purpose NAS file system: 31a8e4\\*\\*\\*\\*.
	//
	// 	- The IDs of Extreme NAS file systems must start with `extreme-`, for example, extreme-0015\\*\\*\\*\\*.
	//
	// 	- The IDs of Cloud Parallel File Storage (CPFS) file systems must start with `cpfs-`, for example, cpfs-00cb6fa094ca\\*\\*\\*\\*.
	//
	// > CPFS file systems are available only on the China site (aliyun.com).
	//
	// This parameter is required.
	//
	// example:
	//
	// 1ca404****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
}

func (s DeleteFileSystemRequest) String() string {
	return dara.Prettify(s)
}

func (s DeleteFileSystemRequest) GoString() string {
	return s.String()
}

func (s *DeleteFileSystemRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DeleteFileSystemRequest) SetFileSystemId(v string) *DeleteFileSystemRequest {
	s.FileSystemId = &v
	return s
}

func (s *DeleteFileSystemRequest) Validate() error {
	return dara.Validate(s)
}

type iDeleteFileSystemResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *DeleteFileSystemResponseBody
	GetRequestId() *string
}

type DeleteFileSystemResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 9E15E394-38A6-457A-A62A-D9797C9A****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteFileSystemResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DeleteFileSystemResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteFileSystemResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DeleteFileSystemResponseBody) SetRequestId(v string) *DeleteFileSystemResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteFileSystemResponseBody) Validate() error {
	return dara.Validate(s)
}

type iDeleteFileSystemResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DeleteFileSystemResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DeleteFileSystemResponse
	GetStatusCode() *int32
	SetBody(v *DeleteFileSystemResponseBody) *DeleteFileSystemResponse
	GetBody() *DeleteFileSystemResponseBody
}

type DeleteFileSystemResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteFileSystemResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteFileSystemResponse) String() string {
	return dara.Prettify(s)
}

func (s DeleteFileSystemResponse) GoString() string {
	return s.String()
}

func (s *DeleteFileSystemResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DeleteFileSystemResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DeleteFileSystemResponse) GetBody() *DeleteFileSystemResponseBody {
	return s.Body
}

func (s *DeleteFileSystemResponse) SetHeaders(v map[string]*string) *DeleteFileSystemResponse {
	s.Headers = v
	return s
}

func (s *DeleteFileSystemResponse) SetStatusCode(v int32) *DeleteFileSystemResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteFileSystemResponse) SetBody(v *DeleteFileSystemResponseBody) *DeleteFileSystemResponse {
	s.Body = v
	return s
}

func (s *DeleteFileSystemResponse) Validate() error {
	return dara.Validate(s)
}

type iDeleteFilesetRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientToken(v string) *DeleteFilesetRequest
	GetClientToken() *string
	SetDryRun(v bool) *DeleteFilesetRequest
	GetDryRun() *bool
	SetFileSystemId(v string) *DeleteFilesetRequest
	GetFileSystemId() *string
	SetFsetId(v string) *DeleteFilesetRequest
	GetFsetId() *string
}

type DeleteFilesetRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// >  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-42665544****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run.
	//
	// During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no fileset is deleted.
	//
	// Valid values:
	//
	// 	- true: performs only a dry run. The system checks the required parameters, request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned.
	//
	// 	- false (default): performs a dry run and sends the request. If the request passes the dry run, the fileset is deleted.
	//
	// example:
	//
	// false
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the file system.
	//
	// 	- The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-099394bd928c\\*\\*\\*\\*.
	//
	// 	- The IDs of CPFS for LINGJUN file systems must start with `bmcpfs-`. Example: bmcpfs-290w65p03ok64ya\\*\\*\\*\\*.
	//
	// >  CPFS is not supported on the international site.
	//
	// This parameter is required.
	//
	// example:
	//
	// cpfs-099394bd928c****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The fileset ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// fset-1902718ea0ae****
	FsetId *string `json:"FsetId,omitempty" xml:"FsetId,omitempty"`
}

func (s DeleteFilesetRequest) String() string {
	return dara.Prettify(s)
}

func (s DeleteFilesetRequest) GoString() string {
	return s.String()
}

func (s *DeleteFilesetRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *DeleteFilesetRequest) GetDryRun() *bool {
	return s.DryRun
}

func (s *DeleteFilesetRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DeleteFilesetRequest) GetFsetId() *string {
	return s.FsetId
}

func (s *DeleteFilesetRequest) SetClientToken(v string) *DeleteFilesetRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteFilesetRequest) SetDryRun(v bool) *DeleteFilesetRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteFilesetRequest) SetFileSystemId(v string) *DeleteFilesetRequest {
	s.FileSystemId = &v
	return s
}

func (s *DeleteFilesetRequest) SetFsetId(v string) *DeleteFilesetRequest {
	s.FsetId = &v
	return s
}

func (s *DeleteFilesetRequest) Validate() error {
	return dara.Validate(s)
}

type iDeleteFilesetResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *DeleteFilesetResponseBody
	GetRequestId() *string
}

type DeleteFilesetResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 2D69A58F-345C-4FDE-88E4-BF518948****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteFilesetResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DeleteFilesetResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteFilesetResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DeleteFilesetResponseBody) SetRequestId(v string) *DeleteFilesetResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteFilesetResponseBody) Validate() error {
	return dara.Validate(s)
}

type iDeleteFilesetResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DeleteFilesetResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DeleteFilesetResponse
	GetStatusCode() *int32
	SetBody(v *DeleteFilesetResponseBody) *DeleteFilesetResponse
	GetBody() *DeleteFilesetResponseBody
}

type DeleteFilesetResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteFilesetResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteFilesetResponse) String() string {
	return dara.Prettify(s)
}

func (s DeleteFilesetResponse) GoString() string {
	return s.String()
}

func (s *DeleteFilesetResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DeleteFilesetResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DeleteFilesetResponse) GetBody() *DeleteFilesetResponseBody {
	return s.Body
}

func (s *DeleteFilesetResponse) SetHeaders(v map[string]*string) *DeleteFilesetResponse {
	s.Headers = v
	return s
}

func (s *DeleteFilesetResponse) SetStatusCode(v int32) *DeleteFilesetResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteFilesetResponse) SetBody(v *DeleteFilesetResponseBody) *DeleteFilesetResponse {
	s.Body = v
	return s
}

func (s *DeleteFilesetResponse) Validate() error {
	return dara.Validate(s)
}

type iDeleteLDAPConfigRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *DeleteLDAPConfigRequest
	GetFileSystemId() *string
}

type DeleteLDAPConfigRequest struct {
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1ca404a348
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
}

func (s DeleteLDAPConfigRequest) String() string {
	return dara.Prettify(s)
}

func (s DeleteLDAPConfigRequest) GoString() string {
	return s.String()
}

func (s *DeleteLDAPConfigRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DeleteLDAPConfigRequest) SetFileSystemId(v string) *DeleteLDAPConfigRequest {
	s.FileSystemId = &v
	return s
}

func (s *DeleteLDAPConfigRequest) Validate() error {
	return dara.Validate(s)
}

type iDeleteLDAPConfigResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *DeleteLDAPConfigResponseBody
	GetRequestId() *string
}

type DeleteLDAPConfigResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 5B4511A7-C99E-4071-AA8C-32E2529DA963
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteLDAPConfigResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DeleteLDAPConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteLDAPConfigResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DeleteLDAPConfigResponseBody) SetRequestId(v string) *DeleteLDAPConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteLDAPConfigResponseBody) Validate() error {
	return dara.Validate(s)
}

type iDeleteLDAPConfigResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DeleteLDAPConfigResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DeleteLDAPConfigResponse
	GetStatusCode() *int32
	SetBody(v *DeleteLDAPConfigResponseBody) *DeleteLDAPConfigResponse
	GetBody() *DeleteLDAPConfigResponseBody
}

type DeleteLDAPConfigResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteLDAPConfigResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteLDAPConfigResponse) String() string {
	return dara.Prettify(s)
}

func (s DeleteLDAPConfigResponse) GoString() string {
	return s.String()
}

func (s *DeleteLDAPConfigResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DeleteLDAPConfigResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DeleteLDAPConfigResponse) GetBody() *DeleteLDAPConfigResponseBody {
	return s.Body
}

func (s *DeleteLDAPConfigResponse) SetHeaders(v map[string]*string) *DeleteLDAPConfigResponse {
	s.Headers = v
	return s
}

func (s *DeleteLDAPConfigResponse) SetStatusCode(v int32) *DeleteLDAPConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteLDAPConfigResponse) SetBody(v *DeleteLDAPConfigResponseBody) *DeleteLDAPConfigResponse {
	s.Body = v
	return s
}

func (s *DeleteLDAPConfigResponse) Validate() error {
	return dara.Validate(s)
}

type iDeleteLifecyclePolicyRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *DeleteLifecyclePolicyRequest
	GetFileSystemId() *string
	SetLifecyclePolicyName(v string) *DeleteLifecyclePolicyRequest
	GetLifecyclePolicyName() *string
}

type DeleteLifecyclePolicyRequest struct {
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 31a8e4****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The name of the lifecycle policy.
	//
	// This parameter is required.
	//
	// example:
	//
	// lifecyclepolicy1
	LifecyclePolicyName *string `json:"LifecyclePolicyName,omitempty" xml:"LifecyclePolicyName,omitempty"`
}

func (s DeleteLifecyclePolicyRequest) String() string {
	return dara.Prettify(s)
}

func (s DeleteLifecyclePolicyRequest) GoString() string {
	return s.String()
}

func (s *DeleteLifecyclePolicyRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DeleteLifecyclePolicyRequest) GetLifecyclePolicyName() *string {
	return s.LifecyclePolicyName
}

func (s *DeleteLifecyclePolicyRequest) SetFileSystemId(v string) *DeleteLifecyclePolicyRequest {
	s.FileSystemId = &v
	return s
}

func (s *DeleteLifecyclePolicyRequest) SetLifecyclePolicyName(v string) *DeleteLifecyclePolicyRequest {
	s.LifecyclePolicyName = &v
	return s
}

func (s *DeleteLifecyclePolicyRequest) Validate() error {
	return dara.Validate(s)
}

type iDeleteLifecyclePolicyResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *DeleteLifecyclePolicyResponseBody
	GetRequestId() *string
	SetSuccess(v bool) *DeleteLifecyclePolicyResponseBody
	GetSuccess() *bool
}

type DeleteLifecyclePolicyResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// BC7C825C-5F65-4B56-BEF6-98C56C7C****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	//
	// Valid values:
	//
	// 	- true
	//
	// 	- false
	//
	// example:
	//
	// true
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteLifecyclePolicyResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DeleteLifecyclePolicyResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteLifecyclePolicyResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DeleteLifecyclePolicyResponseBody) GetSuccess() *bool {
	return s.Success
}

func (s *DeleteLifecyclePolicyResponseBody) SetRequestId(v string) *DeleteLifecyclePolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteLifecyclePolicyResponseBody) SetSuccess(v bool) *DeleteLifecyclePolicyResponseBody {
	s.Success = &v
	return s
}

func (s *DeleteLifecyclePolicyResponseBody) Validate() error {
	return dara.Validate(s)
}

type iDeleteLifecyclePolicyResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DeleteLifecyclePolicyResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DeleteLifecyclePolicyResponse
	GetStatusCode() *int32
	SetBody(v *DeleteLifecyclePolicyResponseBody) *DeleteLifecyclePolicyResponse
	GetBody() *DeleteLifecyclePolicyResponseBody
}

type DeleteLifecyclePolicyResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteLifecyclePolicyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteLifecyclePolicyResponse) String() string {
	return dara.Prettify(s)
}

func (s DeleteLifecyclePolicyResponse) GoString() string {
	return s.String()
}

func (s *DeleteLifecyclePolicyResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DeleteLifecyclePolicyResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DeleteLifecyclePolicyResponse) GetBody() *DeleteLifecyclePolicyResponseBody {
	return s.Body
}

func (s *DeleteLifecyclePolicyResponse) SetHeaders(v map[string]*string) *DeleteLifecyclePolicyResponse {
	s.Headers = v
	return s
}

func (s *DeleteLifecyclePolicyResponse) SetStatusCode(v int32) *DeleteLifecyclePolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteLifecyclePolicyResponse) SetBody(v *DeleteLifecyclePolicyResponseBody) *DeleteLifecyclePolicyResponse {
	s.Body = v
	return s
}

func (s *DeleteLifecyclePolicyResponse) Validate() error {
	return dara.Validate(s)
}

type iDeleteLogAnalysisRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *DeleteLogAnalysisRequest
	GetFileSystemId() *string
	SetRegionId(v string) *DeleteLogAnalysisRequest
	GetRegionId() *string
}

type DeleteLogAnalysisRequest struct {
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 174494xxxx
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The region ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// cn-hangzhou
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DeleteLogAnalysisRequest) String() string {
	return dara.Prettify(s)
}

func (s DeleteLogAnalysisRequest) GoString() string {
	return s.String()
}

func (s *DeleteLogAnalysisRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DeleteLogAnalysisRequest) GetRegionId() *string {
	return s.RegionId
}

func (s *DeleteLogAnalysisRequest) SetFileSystemId(v string) *DeleteLogAnalysisRequest {
	s.FileSystemId = &v
	return s
}

func (s *DeleteLogAnalysisRequest) SetRegionId(v string) *DeleteLogAnalysisRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteLogAnalysisRequest) Validate() error {
	return dara.Validate(s)
}

type iDeleteLogAnalysisResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *DeleteLogAnalysisResponseBody
	GetRequestId() *string
}

type DeleteLogAnalysisResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 70EACC9C-D07A-4A34-ADA4-77506C42B023
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteLogAnalysisResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DeleteLogAnalysisResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteLogAnalysisResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DeleteLogAnalysisResponseBody) SetRequestId(v string) *DeleteLogAnalysisResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteLogAnalysisResponseBody) Validate() error {
	return dara.Validate(s)
}

type iDeleteLogAnalysisResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DeleteLogAnalysisResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DeleteLogAnalysisResponse
	GetStatusCode() *int32
	SetBody(v *DeleteLogAnalysisResponseBody) *DeleteLogAnalysisResponse
	GetBody() *DeleteLogAnalysisResponseBody
}

type DeleteLogAnalysisResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteLogAnalysisResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteLogAnalysisResponse) String() string {
	return dara.Prettify(s)
}

func (s DeleteLogAnalysisResponse) GoString() string {
	return s.String()
}

func (s *DeleteLogAnalysisResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DeleteLogAnalysisResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DeleteLogAnalysisResponse) GetBody() *DeleteLogAnalysisResponseBody {
	return s.Body
}

func (s *DeleteLogAnalysisResponse) SetHeaders(v map[string]*string) *DeleteLogAnalysisResponse {
	s.Headers = v
	return s
}

func (s *DeleteLogAnalysisResponse) SetStatusCode(v int32) *DeleteLogAnalysisResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteLogAnalysisResponse) SetBody(v *DeleteLogAnalysisResponseBody) *DeleteLogAnalysisResponse {
	s.Body = v
	return s
}

func (s *DeleteLogAnalysisResponse) Validate() error {
	return dara.Validate(s)
}

type iDeleteMountTargetRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *DeleteMountTargetRequest
	GetFileSystemId() *string
	SetMountTargetDomain(v string) *DeleteMountTargetRequest
	GetMountTargetDomain() *string
}

type DeleteMountTargetRequest struct {
	// The ID of the file system.
	//
	// 	- Sample ID of a General-purpose NAS file system: 31a8e4\\*\\*\\*\\*.
	//
	// 	- The IDs of Extreme NAS file systems must start with `extreme-`, for example, extreme-0015\\*\\*\\*\\*.
	//
	// 	- The IDs of Cloud Parallel File Storage (CPFS) file systems must start with `cpfs-`, for example, cpfs-125487\\*\\*\\*\\*.
	//
	// > CPFS file systems are available only on the China site (aliyun.com).
	//
	// This parameter is required.
	//
	// example:
	//
	// 174494****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The domain name of the mount target.
	//
	// This parameter is required.
	//
	// example:
	//
	// 174494b666-x****.cn-hangzhou.nas.aliyuncs.com
	MountTargetDomain *string `json:"MountTargetDomain,omitempty" xml:"MountTargetDomain,omitempty"`
}

func (s DeleteMountTargetRequest) String() string {
	return dara.Prettify(s)
}

func (s DeleteMountTargetRequest) GoString() string {
	return s.String()
}

func (s *DeleteMountTargetRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DeleteMountTargetRequest) GetMountTargetDomain() *string {
	return s.MountTargetDomain
}

func (s *DeleteMountTargetRequest) SetFileSystemId(v string) *DeleteMountTargetRequest {
	s.FileSystemId = &v
	return s
}

func (s *DeleteMountTargetRequest) SetMountTargetDomain(v string) *DeleteMountTargetRequest {
	s.MountTargetDomain = &v
	return s
}

func (s *DeleteMountTargetRequest) Validate() error {
	return dara.Validate(s)
}

type iDeleteMountTargetResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *DeleteMountTargetResponseBody
	GetRequestId() *string
}

type DeleteMountTargetResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 5BC5CB97-9F28-42FE-84A4-0CD0DF42****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteMountTargetResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DeleteMountTargetResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteMountTargetResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DeleteMountTargetResponseBody) SetRequestId(v string) *DeleteMountTargetResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteMountTargetResponseBody) Validate() error {
	return dara.Validate(s)
}

type iDeleteMountTargetResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DeleteMountTargetResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DeleteMountTargetResponse
	GetStatusCode() *int32
	SetBody(v *DeleteMountTargetResponseBody) *DeleteMountTargetResponse
	GetBody() *DeleteMountTargetResponseBody
}

type DeleteMountTargetResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteMountTargetResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteMountTargetResponse) String() string {
	return dara.Prettify(s)
}

func (s DeleteMountTargetResponse) GoString() string {
	return s.String()
}

func (s *DeleteMountTargetResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DeleteMountTargetResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DeleteMountTargetResponse) GetBody() *DeleteMountTargetResponseBody {
	return s.Body
}

func (s *DeleteMountTargetResponse) SetHeaders(v map[string]*string) *DeleteMountTargetResponse {
	s.Headers = v
	return s
}

func (s *DeleteMountTargetResponse) SetStatusCode(v int32) *DeleteMountTargetResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteMountTargetResponse) SetBody(v *DeleteMountTargetResponseBody) *DeleteMountTargetResponse {
	s.Body = v
	return s
}

func (s *DeleteMountTargetResponse) Validate() error {
	return dara.Validate(s)
}

type iDeleteProtocolMountTargetRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientToken(v string) *DeleteProtocolMountTargetRequest
	GetClientToken() *string
	SetDryRun(v bool) *DeleteProtocolMountTargetRequest
	GetDryRun() *bool
	SetExportId(v string) *DeleteProtocolMountTargetRequest
	GetExportId() *string
	SetFileSystemId(v string) *DeleteProtocolMountTargetRequest
	GetFileSystemId() *string
	SetProtocolServiceId(v string) *DeleteProtocolMountTargetRequest
	GetProtocolServiceId() *string
}

type DeleteProtocolMountTargetRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// >  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-42665544****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform only a dry run, without performing the actual request. The dry run checks parameter validity and prerequisites. The dry run does not delete the specified export directory or incur fees.
	//
	// Valid values:
	//
	// 	- true: performs only a dry run. The system checks the required parameters, request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned.
	//
	// 	- false (default): performs a dry run and sends the request. If the request passes the dry run, the specified export directory is deleted.
	//
	// example:
	//
	// true
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the export directory.
	//
	// This parameter is required.
	//
	// example:
	//
	// exp-123****
	ExportId *string `json:"ExportId,omitempty" xml:"ExportId,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// cpfs-123****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The ID of the protocol service.
	//
	// This parameter is required.
	//
	// example:
	//
	// ptc-123****
	ProtocolServiceId *string `json:"ProtocolServiceId,omitempty" xml:"ProtocolServiceId,omitempty"`
}

func (s DeleteProtocolMountTargetRequest) String() string {
	return dara.Prettify(s)
}

func (s DeleteProtocolMountTargetRequest) GoString() string {
	return s.String()
}

func (s *DeleteProtocolMountTargetRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *DeleteProtocolMountTargetRequest) GetDryRun() *bool {
	return s.DryRun
}

func (s *DeleteProtocolMountTargetRequest) GetExportId() *string {
	return s.ExportId
}

func (s *DeleteProtocolMountTargetRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DeleteProtocolMountTargetRequest) GetProtocolServiceId() *string {
	return s.ProtocolServiceId
}

func (s *DeleteProtocolMountTargetRequest) SetClientToken(v string) *DeleteProtocolMountTargetRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteProtocolMountTargetRequest) SetDryRun(v bool) *DeleteProtocolMountTargetRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteProtocolMountTargetRequest) SetExportId(v string) *DeleteProtocolMountTargetRequest {
	s.ExportId = &v
	return s
}

func (s *DeleteProtocolMountTargetRequest) SetFileSystemId(v string) *DeleteProtocolMountTargetRequest {
	s.FileSystemId = &v
	return s
}

func (s *DeleteProtocolMountTargetRequest) SetProtocolServiceId(v string) *DeleteProtocolMountTargetRequest {
	s.ProtocolServiceId = &v
	return s
}

func (s *DeleteProtocolMountTargetRequest) Validate() error {
	return dara.Validate(s)
}

type iDeleteProtocolMountTargetResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *DeleteProtocolMountTargetResponseBody
	GetRequestId() *string
}

type DeleteProtocolMountTargetResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 98696EF0-1607-4E9D-B01D-F20930B6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteProtocolMountTargetResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DeleteProtocolMountTargetResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteProtocolMountTargetResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DeleteProtocolMountTargetResponseBody) SetRequestId(v string) *DeleteProtocolMountTargetResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteProtocolMountTargetResponseBody) Validate() error {
	return dara.Validate(s)
}

type iDeleteProtocolMountTargetResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DeleteProtocolMountTargetResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DeleteProtocolMountTargetResponse
	GetStatusCode() *int32
	SetBody(v *DeleteProtocolMountTargetResponseBody) *DeleteProtocolMountTargetResponse
	GetBody() *DeleteProtocolMountTargetResponseBody
}

type DeleteProtocolMountTargetResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteProtocolMountTargetResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteProtocolMountTargetResponse) String() string {
	return dara.Prettify(s)
}

func (s DeleteProtocolMountTargetResponse) GoString() string {
	return s.String()
}

func (s *DeleteProtocolMountTargetResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DeleteProtocolMountTargetResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DeleteProtocolMountTargetResponse) GetBody() *DeleteProtocolMountTargetResponseBody {
	return s.Body
}

func (s *DeleteProtocolMountTargetResponse) SetHeaders(v map[string]*string) *DeleteProtocolMountTargetResponse {
	s.Headers = v
	return s
}

func (s *DeleteProtocolMountTargetResponse) SetStatusCode(v int32) *DeleteProtocolMountTargetResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteProtocolMountTargetResponse) SetBody(v *DeleteProtocolMountTargetResponseBody) *DeleteProtocolMountTargetResponse {
	s.Body = v
	return s
}

func (s *DeleteProtocolMountTargetResponse) Validate() error {
	return dara.Validate(s)
}

type iDeleteProtocolServiceRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientToken(v string) *DeleteProtocolServiceRequest
	GetClientToken() *string
	SetDryRun(v bool) *DeleteProtocolServiceRequest
	GetDryRun() *bool
	SetFileSystemId(v string) *DeleteProtocolServiceRequest
	GetFileSystemId() *string
	SetProtocolServiceId(v string) *DeleteProtocolServiceRequest
	GetProtocolServiceId() *string
}

type DeleteProtocolServiceRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// >  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-42665544****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform only a dry run, without performing the actual request. The dry run checks parameter validity and prerequisites. The dry run does not delete the specified protocol service.
	//
	// Valid values:
	//
	// 	- true: performs only a dry run. The system checks the required parameters, request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned.
	//
	// 	- false (default): performs a dry run and sends the request. If the request passes the dry run, the specified protocol service is deleted.
	//
	// example:
	//
	// false
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// cpfs-123****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The ID of the protocol service.
	//
	// This parameter is required.
	//
	// example:
	//
	// ptc-123****
	ProtocolServiceId *string `json:"ProtocolServiceId,omitempty" xml:"ProtocolServiceId,omitempty"`
}

func (s DeleteProtocolServiceRequest) String() string {
	return dara.Prettify(s)
}

func (s DeleteProtocolServiceRequest) GoString() string {
	return s.String()
}

func (s *DeleteProtocolServiceRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *DeleteProtocolServiceRequest) GetDryRun() *bool {
	return s.DryRun
}

func (s *DeleteProtocolServiceRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DeleteProtocolServiceRequest) GetProtocolServiceId() *string {
	return s.ProtocolServiceId
}

func (s *DeleteProtocolServiceRequest) SetClientToken(v string) *DeleteProtocolServiceRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteProtocolServiceRequest) SetDryRun(v bool) *DeleteProtocolServiceRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteProtocolServiceRequest) SetFileSystemId(v string) *DeleteProtocolServiceRequest {
	s.FileSystemId = &v
	return s
}

func (s *DeleteProtocolServiceRequest) SetProtocolServiceId(v string) *DeleteProtocolServiceRequest {
	s.ProtocolServiceId = &v
	return s
}

func (s *DeleteProtocolServiceRequest) Validate() error {
	return dara.Validate(s)
}

type iDeleteProtocolServiceResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *DeleteProtocolServiceResponseBody
	GetRequestId() *string
}

type DeleteProtocolServiceResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 98696EF0-1607-4E9D-B01D-F20930B6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteProtocolServiceResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DeleteProtocolServiceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteProtocolServiceResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DeleteProtocolServiceResponseBody) SetRequestId(v string) *DeleteProtocolServiceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteProtocolServiceResponseBody) Validate() error {
	return dara.Validate(s)
}

type iDeleteProtocolServiceResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DeleteProtocolServiceResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DeleteProtocolServiceResponse
	GetStatusCode() *int32
	SetBody(v *DeleteProtocolServiceResponseBody) *DeleteProtocolServiceResponse
	GetBody() *DeleteProtocolServiceResponseBody
}

type DeleteProtocolServiceResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteProtocolServiceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteProtocolServiceResponse) String() string {
	return dara.Prettify(s)
}

func (s DeleteProtocolServiceResponse) GoString() string {
	return s.String()
}

func (s *DeleteProtocolServiceResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DeleteProtocolServiceResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DeleteProtocolServiceResponse) GetBody() *DeleteProtocolServiceResponseBody {
	return s.Body
}

func (s *DeleteProtocolServiceResponse) SetHeaders(v map[string]*string) *DeleteProtocolServiceResponse {
	s.Headers = v
	return s
}

func (s *DeleteProtocolServiceResponse) SetStatusCode(v int32) *DeleteProtocolServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteProtocolServiceResponse) SetBody(v *DeleteProtocolServiceResponseBody) *DeleteProtocolServiceResponse {
	s.Body = v
	return s
}

func (s *DeleteProtocolServiceResponse) Validate() error {
	return dara.Validate(s)
}

type iDeleteSnapshotRequest interface {
	dara.Model
	String() string
	GoString() string
	SetSnapshotId(v string) *DeleteSnapshotRequest
	GetSnapshotId() *string
}

type DeleteSnapshotRequest struct {
	// The snapshot ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// s-extreme-snapsho****
	SnapshotId *string `json:"SnapshotId,omitempty" xml:"SnapshotId,omitempty"`
}

func (s DeleteSnapshotRequest) String() string {
	return dara.Prettify(s)
}

func (s DeleteSnapshotRequest) GoString() string {
	return s.String()
}

func (s *DeleteSnapshotRequest) GetSnapshotId() *string {
	return s.SnapshotId
}

func (s *DeleteSnapshotRequest) SetSnapshotId(v string) *DeleteSnapshotRequest {
	s.SnapshotId = &v
	return s
}

func (s *DeleteSnapshotRequest) Validate() error {
	return dara.Validate(s)
}

type iDeleteSnapshotResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *DeleteSnapshotResponseBody
	GetRequestId() *string
}

type DeleteSnapshotResponseBody struct {
	// The request ID.
	//
	// Every response returns a unique request ID regardless of whether the request is successful.
	//
	// example:
	//
	// 473469C7-AA6F-4DC5-B3DB-A3DC0DE3****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteSnapshotResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DeleteSnapshotResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSnapshotResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DeleteSnapshotResponseBody) SetRequestId(v string) *DeleteSnapshotResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteSnapshotResponseBody) Validate() error {
	return dara.Validate(s)
}

type iDeleteSnapshotResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DeleteSnapshotResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DeleteSnapshotResponse
	GetStatusCode() *int32
	SetBody(v *DeleteSnapshotResponseBody) *DeleteSnapshotResponse
	GetBody() *DeleteSnapshotResponseBody
}

type DeleteSnapshotResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteSnapshotResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteSnapshotResponse) String() string {
	return dara.Prettify(s)
}

func (s DeleteSnapshotResponse) GoString() string {
	return s.String()
}

func (s *DeleteSnapshotResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DeleteSnapshotResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DeleteSnapshotResponse) GetBody() *DeleteSnapshotResponseBody {
	return s.Body
}

func (s *DeleteSnapshotResponse) SetHeaders(v map[string]*string) *DeleteSnapshotResponse {
	s.Headers = v
	return s
}

func (s *DeleteSnapshotResponse) SetStatusCode(v int32) *DeleteSnapshotResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSnapshotResponse) SetBody(v *DeleteSnapshotResponseBody) *DeleteSnapshotResponse {
	s.Body = v
	return s
}

func (s *DeleteSnapshotResponse) Validate() error {
	return dara.Validate(s)
}

type iDeleteVscMountPointRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *DeleteVscMountPointRequest
	GetFileSystemId() *string
	SetMountPointDomain(v string) *DeleteVscMountPointRequest
	GetMountPointDomain() *string
}

type DeleteVscMountPointRequest struct {
	// This parameter is required.
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// This parameter is required.
	MountPointDomain *string `json:"MountPointDomain,omitempty" xml:"MountPointDomain,omitempty"`
}

func (s DeleteVscMountPointRequest) String() string {
	return dara.Prettify(s)
}

func (s DeleteVscMountPointRequest) GoString() string {
	return s.String()
}

func (s *DeleteVscMountPointRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DeleteVscMountPointRequest) GetMountPointDomain() *string {
	return s.MountPointDomain
}

func (s *DeleteVscMountPointRequest) SetFileSystemId(v string) *DeleteVscMountPointRequest {
	s.FileSystemId = &v
	return s
}

func (s *DeleteVscMountPointRequest) SetMountPointDomain(v string) *DeleteVscMountPointRequest {
	s.MountPointDomain = &v
	return s
}

func (s *DeleteVscMountPointRequest) Validate() error {
	return dara.Validate(s)
}

type iDeleteVscMountPointResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *DeleteVscMountPointResponseBody
	GetRequestId() *string
}

type DeleteVscMountPointResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteVscMountPointResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DeleteVscMountPointResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteVscMountPointResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DeleteVscMountPointResponseBody) SetRequestId(v string) *DeleteVscMountPointResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteVscMountPointResponseBody) Validate() error {
	return dara.Validate(s)
}

type iDeleteVscMountPointResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DeleteVscMountPointResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DeleteVscMountPointResponse
	GetStatusCode() *int32
	SetBody(v *DeleteVscMountPointResponseBody) *DeleteVscMountPointResponse
	GetBody() *DeleteVscMountPointResponseBody
}

type DeleteVscMountPointResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteVscMountPointResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteVscMountPointResponse) String() string {
	return dara.Prettify(s)
}

func (s DeleteVscMountPointResponse) GoString() string {
	return s.String()
}

func (s *DeleteVscMountPointResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DeleteVscMountPointResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DeleteVscMountPointResponse) GetBody() *DeleteVscMountPointResponseBody {
	return s.Body
}

func (s *DeleteVscMountPointResponse) SetHeaders(v map[string]*string) *DeleteVscMountPointResponse {
	s.Headers = v
	return s
}

func (s *DeleteVscMountPointResponse) SetStatusCode(v int32) *DeleteVscMountPointResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteVscMountPointResponse) SetBody(v *DeleteVscMountPointResponseBody) *DeleteVscMountPointResponse {
	s.Body = v
	return s
}

func (s *DeleteVscMountPointResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeAccessGroupsRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAccessGroupName(v string) *DescribeAccessGroupsRequest
	GetAccessGroupName() *string
	SetFileSystemType(v string) *DescribeAccessGroupsRequest
	GetFileSystemType() *string
	SetPageNumber(v int32) *DescribeAccessGroupsRequest
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeAccessGroupsRequest
	GetPageSize() *int32
	SetUseUTCDateTime(v bool) *DescribeAccessGroupsRequest
	GetUseUTCDateTime() *bool
}

type DescribeAccessGroupsRequest struct {
	// The name of the permission group.
	//
	// Limits:
	//
	// 	- The name must be 3 to 64 characters in length.
	//
	// 	- The name must start with a letter and can contain letters, digits, underscores (_), and hyphens (-).
	//
	// example:
	//
	// DEFAULT_VPC_GROUP_NAME
	AccessGroupName *string `json:"AccessGroupName,omitempty" xml:"AccessGroupName,omitempty"`
	// The type of the file system.
	//
	// Valid values:
	//
	// 	- standard (default): General-purpose NAS file system
	//
	// 	- extreme: Extreme NAS file system
	//
	// 	- cpfs: Cloud Parallel File Storage (CPFS) file system
	//
	// > CPFS file systems are available only on the China site (aliyun.com).
	//
	// example:
	//
	// standard
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
	// The page number.
	//
	// Pages start from page 1. Default value: 1.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	//
	// Valid values: 1 to 100.
	//
	// Default value: 10.
	//
	// example:
	//
	// 2
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// Specifies whether to display the creation time of the permission group in UTC.
	//
	// Valid values:
	//
	// 	- true (default): The time is displayed in UTC.
	//
	// 	- false: The time is not displayed in UTC.
	//
	// example:
	//
	// true
	UseUTCDateTime *bool `json:"UseUTCDateTime,omitempty" xml:"UseUTCDateTime,omitempty"`
}

func (s DescribeAccessGroupsRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeAccessGroupsRequest) GoString() string {
	return s.String()
}

func (s *DescribeAccessGroupsRequest) GetAccessGroupName() *string {
	return s.AccessGroupName
}

func (s *DescribeAccessGroupsRequest) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *DescribeAccessGroupsRequest) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeAccessGroupsRequest) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeAccessGroupsRequest) GetUseUTCDateTime() *bool {
	return s.UseUTCDateTime
}

func (s *DescribeAccessGroupsRequest) SetAccessGroupName(v string) *DescribeAccessGroupsRequest {
	s.AccessGroupName = &v
	return s
}

func (s *DescribeAccessGroupsRequest) SetFileSystemType(v string) *DescribeAccessGroupsRequest {
	s.FileSystemType = &v
	return s
}

func (s *DescribeAccessGroupsRequest) SetPageNumber(v int32) *DescribeAccessGroupsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeAccessGroupsRequest) SetPageSize(v int32) *DescribeAccessGroupsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeAccessGroupsRequest) SetUseUTCDateTime(v bool) *DescribeAccessGroupsRequest {
	s.UseUTCDateTime = &v
	return s
}

func (s *DescribeAccessGroupsRequest) Validate() error {
	return dara.Validate(s)
}

type iDescribeAccessGroupsResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetAccessGroups(v *DescribeAccessGroupsResponseBodyAccessGroups) *DescribeAccessGroupsResponseBody
	GetAccessGroups() *DescribeAccessGroupsResponseBodyAccessGroups
	SetPageNumber(v int32) *DescribeAccessGroupsResponseBody
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeAccessGroupsResponseBody
	GetPageSize() *int32
	SetRequestId(v string) *DescribeAccessGroupsResponseBody
	GetRequestId() *string
	SetTotalCount(v int32) *DescribeAccessGroupsResponseBody
	GetTotalCount() *int32
}

type DescribeAccessGroupsResponseBody struct {
	// The queried permission groups.
	AccessGroups *DescribeAccessGroupsResponseBodyAccessGroups `json:"AccessGroups,omitempty" xml:"AccessGroups,omitempty" type:"Struct"`
	// The page number.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of permission groups returned per page.
	//
	// example:
	//
	// 2
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 2514F97E-FFF0-4A1F-BF04-729CEAC6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of permission groups.
	//
	// example:
	//
	// 1
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeAccessGroupsResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeAccessGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAccessGroupsResponseBody) GetAccessGroups() *DescribeAccessGroupsResponseBodyAccessGroups {
	return s.AccessGroups
}

func (s *DescribeAccessGroupsResponseBody) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeAccessGroupsResponseBody) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeAccessGroupsResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeAccessGroupsResponseBody) GetTotalCount() *int32 {
	return s.TotalCount
}

func (s *DescribeAccessGroupsResponseBody) SetAccessGroups(v *DescribeAccessGroupsResponseBodyAccessGroups) *DescribeAccessGroupsResponseBody {
	s.AccessGroups = v
	return s
}

func (s *DescribeAccessGroupsResponseBody) SetPageNumber(v int32) *DescribeAccessGroupsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeAccessGroupsResponseBody) SetPageSize(v int32) *DescribeAccessGroupsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeAccessGroupsResponseBody) SetRequestId(v string) *DescribeAccessGroupsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeAccessGroupsResponseBody) SetTotalCount(v int32) *DescribeAccessGroupsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeAccessGroupsResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeAccessGroupsResponseBodyAccessGroups struct {
	AccessGroup []*DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup `json:"AccessGroup,omitempty" xml:"AccessGroup,omitempty" type:"Repeated"`
}

func (s DescribeAccessGroupsResponseBodyAccessGroups) String() string {
	return dara.Prettify(s)
}

func (s DescribeAccessGroupsResponseBodyAccessGroups) GoString() string {
	return s.String()
}

func (s *DescribeAccessGroupsResponseBodyAccessGroups) GetAccessGroup() []*DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup {
	return s.AccessGroup
}

func (s *DescribeAccessGroupsResponseBodyAccessGroups) SetAccessGroup(v []*DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup) *DescribeAccessGroupsResponseBodyAccessGroups {
	s.AccessGroup = v
	return s
}

func (s *DescribeAccessGroupsResponseBodyAccessGroups) Validate() error {
	return dara.Validate(s)
}

type DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup struct {
	// The name of the permission group.
	//
	// example:
	//
	// DEFAULT_VPC_GROUP_NAME
	AccessGroupName *string `json:"AccessGroupName,omitempty" xml:"AccessGroupName,omitempty"`
	// The network type of the permission group. Valid value: **Vpc**.
	//
	// example:
	//
	// Vpc
	AccessGroupType *string `json:"AccessGroupType,omitempty" xml:"AccessGroupType,omitempty"`
	// The time when the permission group was created.
	//
	// example:
	//
	// 2020-01-05T16:00:00Z
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The description of the permission group.
	//
	// example:
	//
	// This is a test access group.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The type of the file system.
	//
	// Valid values:
	//
	// 	- standard: General-purpose File Storage NAS (NAS) file system
	//
	// 	- extreme: Extreme NAS file system
	//
	// 	- cpfs: Cloud Parallel File Storage (CPFS) file system
	//
	// >  CPFS file systems are available only on the China site (aliyun.com).
	//
	// example:
	//
	// standard
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
	// The number of mount targets to which the permission group is attached.
	//
	// example:
	//
	// 0
	MountTargetCount *int32 `json:"MountTargetCount,omitempty" xml:"MountTargetCount,omitempty"`
	// The region ID.
	//
	// example:
	//
	// cn-hangzhou
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The total number of rules in the permission group.
	//
	// example:
	//
	// 0
	RuleCount *int32                                                       `json:"RuleCount,omitempty" xml:"RuleCount,omitempty"`
	Tags      *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroupTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
}

func (s DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup) String() string {
	return dara.Prettify(s)
}

func (s DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup) GoString() string {
	return s.String()
}

func (s *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup) GetAccessGroupName() *string {
	return s.AccessGroupName
}

func (s *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup) GetAccessGroupType() *string {
	return s.AccessGroupType
}

func (s *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup) GetCreateTime() *string {
	return s.CreateTime
}

func (s *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup) GetDescription() *string {
	return s.Description
}

func (s *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup) GetMountTargetCount() *int32 {
	return s.MountTargetCount
}

func (s *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup) GetRegionId() *string {
	return s.RegionId
}

func (s *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup) GetRuleCount() *int32 {
	return s.RuleCount
}

func (s *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup) GetTags() *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroupTags {
	return s.Tags
}

func (s *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup) SetAccessGroupName(v string) *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup {
	s.AccessGroupName = &v
	return s
}

func (s *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup) SetAccessGroupType(v string) *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup {
	s.AccessGroupType = &v
	return s
}

func (s *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup) SetCreateTime(v string) *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup {
	s.CreateTime = &v
	return s
}

func (s *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup) SetDescription(v string) *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup {
	s.Description = &v
	return s
}

func (s *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup) SetFileSystemType(v string) *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup {
	s.FileSystemType = &v
	return s
}

func (s *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup) SetMountTargetCount(v int32) *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup {
	s.MountTargetCount = &v
	return s
}

func (s *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup) SetRegionId(v string) *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup {
	s.RegionId = &v
	return s
}

func (s *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup) SetRuleCount(v int32) *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup {
	s.RuleCount = &v
	return s
}

func (s *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup) SetTags(v *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroupTags) *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup {
	s.Tags = v
	return s
}

func (s *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroup) Validate() error {
	return dara.Validate(s)
}

type DescribeAccessGroupsResponseBodyAccessGroupsAccessGroupTags struct {
	Tag []*DescribeAccessGroupsResponseBodyAccessGroupsAccessGroupTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeAccessGroupsResponseBodyAccessGroupsAccessGroupTags) String() string {
	return dara.Prettify(s)
}

func (s DescribeAccessGroupsResponseBodyAccessGroupsAccessGroupTags) GoString() string {
	return s.String()
}

func (s *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroupTags) GetTag() []*DescribeAccessGroupsResponseBodyAccessGroupsAccessGroupTagsTag {
	return s.Tag
}

func (s *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroupTags) SetTag(v []*DescribeAccessGroupsResponseBodyAccessGroupsAccessGroupTagsTag) *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroupTags {
	s.Tag = v
	return s
}

func (s *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroupTags) Validate() error {
	return dara.Validate(s)
}

type DescribeAccessGroupsResponseBodyAccessGroupsAccessGroupTagsTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeAccessGroupsResponseBodyAccessGroupsAccessGroupTagsTag) String() string {
	return dara.Prettify(s)
}

func (s DescribeAccessGroupsResponseBodyAccessGroupsAccessGroupTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroupTagsTag) GetKey() *string {
	return s.Key
}

func (s *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroupTagsTag) GetValue() *string {
	return s.Value
}

func (s *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroupTagsTag) SetKey(v string) *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroupTagsTag {
	s.Key = &v
	return s
}

func (s *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroupTagsTag) SetValue(v string) *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroupTagsTag {
	s.Value = &v
	return s
}

func (s *DescribeAccessGroupsResponseBodyAccessGroupsAccessGroupTagsTag) Validate() error {
	return dara.Validate(s)
}

type iDescribeAccessGroupsResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeAccessGroupsResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeAccessGroupsResponse
	GetStatusCode() *int32
	SetBody(v *DescribeAccessGroupsResponseBody) *DescribeAccessGroupsResponse
	GetBody() *DescribeAccessGroupsResponseBody
}

type DescribeAccessGroupsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeAccessGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeAccessGroupsResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeAccessGroupsResponse) GoString() string {
	return s.String()
}

func (s *DescribeAccessGroupsResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeAccessGroupsResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeAccessGroupsResponse) GetBody() *DescribeAccessGroupsResponseBody {
	return s.Body
}

func (s *DescribeAccessGroupsResponse) SetHeaders(v map[string]*string) *DescribeAccessGroupsResponse {
	s.Headers = v
	return s
}

func (s *DescribeAccessGroupsResponse) SetStatusCode(v int32) *DescribeAccessGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAccessGroupsResponse) SetBody(v *DescribeAccessGroupsResponseBody) *DescribeAccessGroupsResponse {
	s.Body = v
	return s
}

func (s *DescribeAccessGroupsResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeAccessPointRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAccessPointId(v string) *DescribeAccessPointRequest
	GetAccessPointId() *string
	SetFileSystemId(v string) *DescribeAccessPointRequest
	GetFileSystemId() *string
}

type DescribeAccessPointRequest struct {
	// The ID of the access point.
	//
	// This parameter is required.
	//
	// example:
	//
	// ap-ie15yd****
	AccessPointId *string `json:"AccessPointId,omitempty" xml:"AccessPointId,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 31a8e4****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
}

func (s DescribeAccessPointRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeAccessPointRequest) GoString() string {
	return s.String()
}

func (s *DescribeAccessPointRequest) GetAccessPointId() *string {
	return s.AccessPointId
}

func (s *DescribeAccessPointRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeAccessPointRequest) SetAccessPointId(v string) *DescribeAccessPointRequest {
	s.AccessPointId = &v
	return s
}

func (s *DescribeAccessPointRequest) SetFileSystemId(v string) *DescribeAccessPointRequest {
	s.FileSystemId = &v
	return s
}

func (s *DescribeAccessPointRequest) Validate() error {
	return dara.Validate(s)
}

type iDescribeAccessPointResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetAccessPoint(v *DescribeAccessPointResponseBodyAccessPoint) *DescribeAccessPointResponseBody
	GetAccessPoint() *DescribeAccessPointResponseBodyAccessPoint
	SetRequestId(v string) *DescribeAccessPointResponseBody
	GetRequestId() *string
}

type DescribeAccessPointResponseBody struct {
	// The information about the access point.
	AccessPoint *DescribeAccessPointResponseBodyAccessPoint `json:"AccessPoint,omitempty" xml:"AccessPoint,omitempty" type:"Struct"`
	// The request ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// 473469C7-AA6F-4DC5-B3DB-A3DC0DE3****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeAccessPointResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeAccessPointResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAccessPointResponseBody) GetAccessPoint() *DescribeAccessPointResponseBodyAccessPoint {
	return s.AccessPoint
}

func (s *DescribeAccessPointResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeAccessPointResponseBody) SetAccessPoint(v *DescribeAccessPointResponseBodyAccessPoint) *DescribeAccessPointResponseBody {
	s.AccessPoint = v
	return s
}

func (s *DescribeAccessPointResponseBody) SetRequestId(v string) *DescribeAccessPointResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeAccessPointResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeAccessPointResponseBodyAccessPoint struct {
	// The Alibaba Cloud Resource Name (ARN) of the access point.
	//
	// example:
	//
	// acs:nas:cn-hangzhou:178321033379****:accesspoint/ap-ie15yd****
	ARN *string `json:"ARN,omitempty" xml:"ARN,omitempty"`
	// The name of the permission group.
	//
	// example:
	//
	// test
	AccessGroup *string `json:"AccessGroup,omitempty" xml:"AccessGroup,omitempty"`
	// The ID of the access point.
	//
	// example:
	//
	// ap-ie15yd****
	AccessPointId *string `json:"AccessPointId,omitempty" xml:"AccessPointId,omitempty"`
	// The name of the access point.
	//
	// example:
	//
	// test
	AccessPointName *string `json:"AccessPointName,omitempty" xml:"AccessPointName,omitempty"`
	// The time when the access point was created.
	//
	// example:
	//
	// 1709619668276167
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The domain name of the access point.
	//
	// example:
	//
	// ap-ie15ydanoz.001014****-w****.cn-hangzhou.nas.aliyuncs.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// Indicates whether the RAM policy is enabled.
	//
	// example:
	//
	// false
	EnabledRam *bool `json:"EnabledRam,omitempty" xml:"EnabledRam,omitempty"`
	// The ID of the file system.
	//
	// example:
	//
	// 31a8e4****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The time when the access point was modified.
	//
	// example:
	//
	// 1709619668276167
	ModifyTime *string `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// The POSIX user.
	PosixUser *DescribeAccessPointResponseBodyAccessPointPosixUser `json:"PosixUser,omitempty" xml:"PosixUser,omitempty" type:"Struct"`
	// The region ID.
	//
	// example:
	//
	// cn-hangzhou
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The root directory.
	//
	// example:
	//
	// /
	RootPath *string `json:"RootPath,omitempty" xml:"RootPath,omitempty"`
	// The permissions to create the root directory.
	RootPathPermission *DescribeAccessPointResponseBodyAccessPointRootPathPermission `json:"RootPathPermission,omitempty" xml:"RootPathPermission,omitempty" type:"Struct"`
	// The status of the root directory.
	//
	// Valid values:
	//
	// 	- 0: The rootpath status is unknown.
	//
	// 	- 1: The rootpath does not exist and may be deleted.
	//
	// 	- 2: The rootpath is normal.
	//
	// example:
	//
	// 2
	RootPathStatus *string `json:"RootPathStatus,omitempty" xml:"RootPathStatus,omitempty"`
	// The status of the access point.
	//
	// Valid values:
	//
	// 	- Active: The access point is available.
	//
	// 	- Inactive: The access point is unavailable.
	//
	// 	- Pending: The access point is being created.
	//
	// 	- Deleting: The access point is being deleted.
	//
	// example:
	//
	// Active
	Status *string                                           `json:"Status,omitempty" xml:"Status,omitempty"`
	Tags   []*DescribeAccessPointResponseBodyAccessPointTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The vSwitch ID.
	//
	// example:
	//
	// vsw-2zevmwkwyztjuoffg****
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the virtual private cloud (VPC).
	//
	// You must select the VPC of the Elastic Compute Service (ECS) instance on which you want to mount the file system.
	//
	// example:
	//
	// vpc-2zesj9afh3y518k9o****
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeAccessPointResponseBodyAccessPoint) String() string {
	return dara.Prettify(s)
}

func (s DescribeAccessPointResponseBodyAccessPoint) GoString() string {
	return s.String()
}

func (s *DescribeAccessPointResponseBodyAccessPoint) GetARN() *string {
	return s.ARN
}

func (s *DescribeAccessPointResponseBodyAccessPoint) GetAccessGroup() *string {
	return s.AccessGroup
}

func (s *DescribeAccessPointResponseBodyAccessPoint) GetAccessPointId() *string {
	return s.AccessPointId
}

func (s *DescribeAccessPointResponseBodyAccessPoint) GetAccessPointName() *string {
	return s.AccessPointName
}

func (s *DescribeAccessPointResponseBodyAccessPoint) GetCreateTime() *string {
	return s.CreateTime
}

func (s *DescribeAccessPointResponseBodyAccessPoint) GetDomainName() *string {
	return s.DomainName
}

func (s *DescribeAccessPointResponseBodyAccessPoint) GetEnabledRam() *bool {
	return s.EnabledRam
}

func (s *DescribeAccessPointResponseBodyAccessPoint) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeAccessPointResponseBodyAccessPoint) GetModifyTime() *string {
	return s.ModifyTime
}

func (s *DescribeAccessPointResponseBodyAccessPoint) GetPosixUser() *DescribeAccessPointResponseBodyAccessPointPosixUser {
	return s.PosixUser
}

func (s *DescribeAccessPointResponseBodyAccessPoint) GetRegionId() *string {
	return s.RegionId
}

func (s *DescribeAccessPointResponseBodyAccessPoint) GetRootPath() *string {
	return s.RootPath
}

func (s *DescribeAccessPointResponseBodyAccessPoint) GetRootPathPermission() *DescribeAccessPointResponseBodyAccessPointRootPathPermission {
	return s.RootPathPermission
}

func (s *DescribeAccessPointResponseBodyAccessPoint) GetRootPathStatus() *string {
	return s.RootPathStatus
}

func (s *DescribeAccessPointResponseBodyAccessPoint) GetStatus() *string {
	return s.Status
}

func (s *DescribeAccessPointResponseBodyAccessPoint) GetTags() []*DescribeAccessPointResponseBodyAccessPointTags {
	return s.Tags
}

func (s *DescribeAccessPointResponseBodyAccessPoint) GetVSwitchId() *string {
	return s.VSwitchId
}

func (s *DescribeAccessPointResponseBodyAccessPoint) GetVpcId() *string {
	return s.VpcId
}

func (s *DescribeAccessPointResponseBodyAccessPoint) SetARN(v string) *DescribeAccessPointResponseBodyAccessPoint {
	s.ARN = &v
	return s
}

func (s *DescribeAccessPointResponseBodyAccessPoint) SetAccessGroup(v string) *DescribeAccessPointResponseBodyAccessPoint {
	s.AccessGroup = &v
	return s
}

func (s *DescribeAccessPointResponseBodyAccessPoint) SetAccessPointId(v string) *DescribeAccessPointResponseBodyAccessPoint {
	s.AccessPointId = &v
	return s
}

func (s *DescribeAccessPointResponseBodyAccessPoint) SetAccessPointName(v string) *DescribeAccessPointResponseBodyAccessPoint {
	s.AccessPointName = &v
	return s
}

func (s *DescribeAccessPointResponseBodyAccessPoint) SetCreateTime(v string) *DescribeAccessPointResponseBodyAccessPoint {
	s.CreateTime = &v
	return s
}

func (s *DescribeAccessPointResponseBodyAccessPoint) SetDomainName(v string) *DescribeAccessPointResponseBodyAccessPoint {
	s.DomainName = &v
	return s
}

func (s *DescribeAccessPointResponseBodyAccessPoint) SetEnabledRam(v bool) *DescribeAccessPointResponseBodyAccessPoint {
	s.EnabledRam = &v
	return s
}

func (s *DescribeAccessPointResponseBodyAccessPoint) SetFileSystemId(v string) *DescribeAccessPointResponseBodyAccessPoint {
	s.FileSystemId = &v
	return s
}

func (s *DescribeAccessPointResponseBodyAccessPoint) SetModifyTime(v string) *DescribeAccessPointResponseBodyAccessPoint {
	s.ModifyTime = &v
	return s
}

func (s *DescribeAccessPointResponseBodyAccessPoint) SetPosixUser(v *DescribeAccessPointResponseBodyAccessPointPosixUser) *DescribeAccessPointResponseBodyAccessPoint {
	s.PosixUser = v
	return s
}

func (s *DescribeAccessPointResponseBodyAccessPoint) SetRegionId(v string) *DescribeAccessPointResponseBodyAccessPoint {
	s.RegionId = &v
	return s
}

func (s *DescribeAccessPointResponseBodyAccessPoint) SetRootPath(v string) *DescribeAccessPointResponseBodyAccessPoint {
	s.RootPath = &v
	return s
}

func (s *DescribeAccessPointResponseBodyAccessPoint) SetRootPathPermission(v *DescribeAccessPointResponseBodyAccessPointRootPathPermission) *DescribeAccessPointResponseBodyAccessPoint {
	s.RootPathPermission = v
	return s
}

func (s *DescribeAccessPointResponseBodyAccessPoint) SetRootPathStatus(v string) *DescribeAccessPointResponseBodyAccessPoint {
	s.RootPathStatus = &v
	return s
}

func (s *DescribeAccessPointResponseBodyAccessPoint) SetStatus(v string) *DescribeAccessPointResponseBodyAccessPoint {
	s.Status = &v
	return s
}

func (s *DescribeAccessPointResponseBodyAccessPoint) SetTags(v []*DescribeAccessPointResponseBodyAccessPointTags) *DescribeAccessPointResponseBodyAccessPoint {
	s.Tags = v
	return s
}

func (s *DescribeAccessPointResponseBodyAccessPoint) SetVSwitchId(v string) *DescribeAccessPointResponseBodyAccessPoint {
	s.VSwitchId = &v
	return s
}

func (s *DescribeAccessPointResponseBodyAccessPoint) SetVpcId(v string) *DescribeAccessPointResponseBodyAccessPoint {
	s.VpcId = &v
	return s
}

func (s *DescribeAccessPointResponseBodyAccessPoint) Validate() error {
	return dara.Validate(s)
}

type DescribeAccessPointResponseBodyAccessPointPosixUser struct {
	// The ID of the POSIX user group.
	//
	// example:
	//
	// 12
	PosixGroupId *int32 `json:"PosixGroupId,omitempty" xml:"PosixGroupId,omitempty"`
	// The IDs of the secondary user groups.
	PosixSecondaryGroupIds []*int32 `json:"PosixSecondaryGroupIds,omitempty" xml:"PosixSecondaryGroupIds,omitempty" type:"Repeated"`
	// The ID of the POSIX user.
	//
	// example:
	//
	// 123
	PosixUserId *int32 `json:"PosixUserId,omitempty" xml:"PosixUserId,omitempty"`
}

func (s DescribeAccessPointResponseBodyAccessPointPosixUser) String() string {
	return dara.Prettify(s)
}

func (s DescribeAccessPointResponseBodyAccessPointPosixUser) GoString() string {
	return s.String()
}

func (s *DescribeAccessPointResponseBodyAccessPointPosixUser) GetPosixGroupId() *int32 {
	return s.PosixGroupId
}

func (s *DescribeAccessPointResponseBodyAccessPointPosixUser) GetPosixSecondaryGroupIds() []*int32 {
	return s.PosixSecondaryGroupIds
}

func (s *DescribeAccessPointResponseBodyAccessPointPosixUser) GetPosixUserId() *int32 {
	return s.PosixUserId
}

func (s *DescribeAccessPointResponseBodyAccessPointPosixUser) SetPosixGroupId(v int32) *DescribeAccessPointResponseBodyAccessPointPosixUser {
	s.PosixGroupId = &v
	return s
}

func (s *DescribeAccessPointResponseBodyAccessPointPosixUser) SetPosixSecondaryGroupIds(v []*int32) *DescribeAccessPointResponseBodyAccessPointPosixUser {
	s.PosixSecondaryGroupIds = v
	return s
}

func (s *DescribeAccessPointResponseBodyAccessPointPosixUser) SetPosixUserId(v int32) *DescribeAccessPointResponseBodyAccessPointPosixUser {
	s.PosixUserId = &v
	return s
}

func (s *DescribeAccessPointResponseBodyAccessPointPosixUser) Validate() error {
	return dara.Validate(s)
}

type DescribeAccessPointResponseBodyAccessPointRootPathPermission struct {
	// The ID of the owner group.
	//
	// example:
	//
	// 123
	OwnerGroupId *int32 `json:"OwnerGroupId,omitempty" xml:"OwnerGroupId,omitempty"`
	// The owner ID.
	//
	// example:
	//
	// 1
	OwnerUserId *int32 `json:"OwnerUserId,omitempty" xml:"OwnerUserId,omitempty"`
	// The POSIX permission.
	//
	// example:
	//
	// 0755
	Permission *string `json:"Permission,omitempty" xml:"Permission,omitempty"`
}

func (s DescribeAccessPointResponseBodyAccessPointRootPathPermission) String() string {
	return dara.Prettify(s)
}

func (s DescribeAccessPointResponseBodyAccessPointRootPathPermission) GoString() string {
	return s.String()
}

func (s *DescribeAccessPointResponseBodyAccessPointRootPathPermission) GetOwnerGroupId() *int32 {
	return s.OwnerGroupId
}

func (s *DescribeAccessPointResponseBodyAccessPointRootPathPermission) GetOwnerUserId() *int32 {
	return s.OwnerUserId
}

func (s *DescribeAccessPointResponseBodyAccessPointRootPathPermission) GetPermission() *string {
	return s.Permission
}

func (s *DescribeAccessPointResponseBodyAccessPointRootPathPermission) SetOwnerGroupId(v int32) *DescribeAccessPointResponseBodyAccessPointRootPathPermission {
	s.OwnerGroupId = &v
	return s
}

func (s *DescribeAccessPointResponseBodyAccessPointRootPathPermission) SetOwnerUserId(v int32) *DescribeAccessPointResponseBodyAccessPointRootPathPermission {
	s.OwnerUserId = &v
	return s
}

func (s *DescribeAccessPointResponseBodyAccessPointRootPathPermission) SetPermission(v string) *DescribeAccessPointResponseBodyAccessPointRootPathPermission {
	s.Permission = &v
	return s
}

func (s *DescribeAccessPointResponseBodyAccessPointRootPathPermission) Validate() error {
	return dara.Validate(s)
}

type DescribeAccessPointResponseBodyAccessPointTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeAccessPointResponseBodyAccessPointTags) String() string {
	return dara.Prettify(s)
}

func (s DescribeAccessPointResponseBodyAccessPointTags) GoString() string {
	return s.String()
}

func (s *DescribeAccessPointResponseBodyAccessPointTags) GetKey() *string {
	return s.Key
}

func (s *DescribeAccessPointResponseBodyAccessPointTags) GetValue() *string {
	return s.Value
}

func (s *DescribeAccessPointResponseBodyAccessPointTags) SetKey(v string) *DescribeAccessPointResponseBodyAccessPointTags {
	s.Key = &v
	return s
}

func (s *DescribeAccessPointResponseBodyAccessPointTags) SetValue(v string) *DescribeAccessPointResponseBodyAccessPointTags {
	s.Value = &v
	return s
}

func (s *DescribeAccessPointResponseBodyAccessPointTags) Validate() error {
	return dara.Validate(s)
}

type iDescribeAccessPointResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeAccessPointResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeAccessPointResponse
	GetStatusCode() *int32
	SetBody(v *DescribeAccessPointResponseBody) *DescribeAccessPointResponse
	GetBody() *DescribeAccessPointResponseBody
}

type DescribeAccessPointResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeAccessPointResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeAccessPointResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeAccessPointResponse) GoString() string {
	return s.String()
}

func (s *DescribeAccessPointResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeAccessPointResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeAccessPointResponse) GetBody() *DescribeAccessPointResponseBody {
	return s.Body
}

func (s *DescribeAccessPointResponse) SetHeaders(v map[string]*string) *DescribeAccessPointResponse {
	s.Headers = v
	return s
}

func (s *DescribeAccessPointResponse) SetStatusCode(v int32) *DescribeAccessPointResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAccessPointResponse) SetBody(v *DescribeAccessPointResponseBody) *DescribeAccessPointResponse {
	s.Body = v
	return s
}

func (s *DescribeAccessPointResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeAccessPointsRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAccessGroup(v string) *DescribeAccessPointsRequest
	GetAccessGroup() *string
	SetFileSystemId(v string) *DescribeAccessPointsRequest
	GetFileSystemId() *string
	SetMaxResults(v int32) *DescribeAccessPointsRequest
	GetMaxResults() *int32
	SetNextToken(v string) *DescribeAccessPointsRequest
	GetNextToken() *string
}

type DescribeAccessPointsRequest struct {
	// The name of the permission group.
	//
	// This parameter is required for a General-purpose File Storage NAS (NAS) file system.
	//
	// The default permission group for virtual private clouds (VPCs) is named DEFAULT_VPC_GROUP_NAME.
	//
	// example:
	//
	// DEFAULT_VPC_GROUP_NAME
	AccessGroup *string `json:"AccessGroup,omitempty" xml:"AccessGroup,omitempty"`
	// The ID of the file system.
	//
	// example:
	//
	// 174494****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The number of results for each query.
	//
	// Valid values: 10 to 100. Default value: 10.
	//
	// example:
	//
	// 10
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.
	//
	// example:
	//
	// MTY4NzcxOTcwMjAzMDk2Nzc0MyM4MDM4****
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
}

func (s DescribeAccessPointsRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeAccessPointsRequest) GoString() string {
	return s.String()
}

func (s *DescribeAccessPointsRequest) GetAccessGroup() *string {
	return s.AccessGroup
}

func (s *DescribeAccessPointsRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeAccessPointsRequest) GetMaxResults() *int32 {
	return s.MaxResults
}

func (s *DescribeAccessPointsRequest) GetNextToken() *string {
	return s.NextToken
}

func (s *DescribeAccessPointsRequest) SetAccessGroup(v string) *DescribeAccessPointsRequest {
	s.AccessGroup = &v
	return s
}

func (s *DescribeAccessPointsRequest) SetFileSystemId(v string) *DescribeAccessPointsRequest {
	s.FileSystemId = &v
	return s
}

func (s *DescribeAccessPointsRequest) SetMaxResults(v int32) *DescribeAccessPointsRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeAccessPointsRequest) SetNextToken(v string) *DescribeAccessPointsRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeAccessPointsRequest) Validate() error {
	return dara.Validate(s)
}

type iDescribeAccessPointsResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetAccessPoints(v []*DescribeAccessPointsResponseBodyAccessPoints) *DescribeAccessPointsResponseBody
	GetAccessPoints() []*DescribeAccessPointsResponseBodyAccessPoints
	SetNextToken(v string) *DescribeAccessPointsResponseBody
	GetNextToken() *string
	SetRequestId(v string) *DescribeAccessPointsResponseBody
	GetRequestId() *string
	SetTotalCount(v int32) *DescribeAccessPointsResponseBody
	GetTotalCount() *int32
}

type DescribeAccessPointsResponseBody struct {
	// The information about the access point.
	AccessPoints []*DescribeAccessPointsResponseBodyAccessPoints `json:"AccessPoints,omitempty" xml:"AccessPoints,omitempty" type:"Repeated"`
	// The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.
	//
	// example:
	//
	// MTY4NzcxOTcwMjAzMDk2Nzc0MyM4MDM4****
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// 6299428C-3861-435D-AE54-9B330A00****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of access points.
	//
	// example:
	//
	// 20
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeAccessPointsResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeAccessPointsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAccessPointsResponseBody) GetAccessPoints() []*DescribeAccessPointsResponseBodyAccessPoints {
	return s.AccessPoints
}

func (s *DescribeAccessPointsResponseBody) GetNextToken() *string {
	return s.NextToken
}

func (s *DescribeAccessPointsResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeAccessPointsResponseBody) GetTotalCount() *int32 {
	return s.TotalCount
}

func (s *DescribeAccessPointsResponseBody) SetAccessPoints(v []*DescribeAccessPointsResponseBodyAccessPoints) *DescribeAccessPointsResponseBody {
	s.AccessPoints = v
	return s
}

func (s *DescribeAccessPointsResponseBody) SetNextToken(v string) *DescribeAccessPointsResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeAccessPointsResponseBody) SetRequestId(v string) *DescribeAccessPointsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeAccessPointsResponseBody) SetTotalCount(v int32) *DescribeAccessPointsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeAccessPointsResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeAccessPointsResponseBodyAccessPoints struct {
	// The Alibaba Cloud Resource Name (ARN) of the access point.
	//
	// example:
	//
	// acs:nas:cn-hangzhou:178321033379****:accesspoint/ap-ie15yd****
	ARN *string `json:"ARN,omitempty" xml:"ARN,omitempty"`
	// The name of the permission group.
	//
	// example:
	//
	// test
	AccessGroup *string `json:"AccessGroup,omitempty" xml:"AccessGroup,omitempty"`
	// The ID of the access point.
	//
	// example:
	//
	// ap-ie15yd****
	AccessPointId *string `json:"AccessPointId,omitempty" xml:"AccessPointId,omitempty"`
	// The name of the access point.
	//
	// example:
	//
	// test
	AccessPointName *string `json:"AccessPointName,omitempty" xml:"AccessPointName,omitempty"`
	// The time when the access point was created.
	//
	// example:
	//
	// 1709619668276167
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The domain name of the access point.
	//
	// example:
	//
	// ap-ie15ydanoz.001014****-w****.cn-hangzhou.nas.aliyuncs.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// Indicates whether the Resource Access Management (RAM) policy is enabled.
	//
	// example:
	//
	// false
	EnabledRam *bool `json:"EnabledRam,omitempty" xml:"EnabledRam,omitempty"`
	// The ID of the file system.
	//
	// example:
	//
	// 31a8e4****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The time when the access point was modified.
	//
	// example:
	//
	// 1709619668276167
	ModifyTime *string `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// The Portable Operating System Interface for UNIX (POSIX) user.
	PosixUser *DescribeAccessPointsResponseBodyAccessPointsPosixUser `json:"PosixUser,omitempty" xml:"PosixUser,omitempty" type:"Struct"`
	// The root directory.
	//
	// example:
	//
	// /
	RootPath *string `json:"RootPath,omitempty" xml:"RootPath,omitempty"`
	// The permissions on the root directory.
	RootPathPermission *DescribeAccessPointsResponseBodyAccessPointsRootPathPermission `json:"RootPathPermission,omitempty" xml:"RootPathPermission,omitempty" type:"Struct"`
	// The status of the root directory.
	//
	// Valid values:
	//
	// 	- 0: The rootpath status is unknown.
	//
	// 	- 1: The rootpath does not exist and may be deleted.
	//
	// 	- 2: The rootpath is normal.
	//
	// example:
	//
	// 2
	RootPathStatus *string `json:"RootPathStatus,omitempty" xml:"RootPathStatus,omitempty"`
	// The status of the access point.
	//
	// Valid values:
	//
	// 	- Active: The access point is available.
	//
	// 	- Inactive: The access point is unavailable.
	//
	// 	- Pending: The access point is being created.
	//
	// 	- Deleting: The access point is being deleted.
	//
	// >  You can mount a file system only if the access point is in the Active state.
	//
	// example:
	//
	// Active
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The vSwitch ID.
	//
	// example:
	//
	// vsw-2zevmwkwyztjuoffg****
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The VPC ID.
	//
	// example:
	//
	// vpc-2zesj9afh3y518k9o****
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeAccessPointsResponseBodyAccessPoints) String() string {
	return dara.Prettify(s)
}

func (s DescribeAccessPointsResponseBodyAccessPoints) GoString() string {
	return s.String()
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) GetARN() *string {
	return s.ARN
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) GetAccessGroup() *string {
	return s.AccessGroup
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) GetAccessPointId() *string {
	return s.AccessPointId
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) GetAccessPointName() *string {
	return s.AccessPointName
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) GetCreateTime() *string {
	return s.CreateTime
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) GetDomainName() *string {
	return s.DomainName
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) GetEnabledRam() *bool {
	return s.EnabledRam
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) GetModifyTime() *string {
	return s.ModifyTime
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) GetPosixUser() *DescribeAccessPointsResponseBodyAccessPointsPosixUser {
	return s.PosixUser
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) GetRootPath() *string {
	return s.RootPath
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) GetRootPathPermission() *DescribeAccessPointsResponseBodyAccessPointsRootPathPermission {
	return s.RootPathPermission
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) GetRootPathStatus() *string {
	return s.RootPathStatus
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) GetStatus() *string {
	return s.Status
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) GetVSwitchId() *string {
	return s.VSwitchId
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) GetVpcId() *string {
	return s.VpcId
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) SetARN(v string) *DescribeAccessPointsResponseBodyAccessPoints {
	s.ARN = &v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) SetAccessGroup(v string) *DescribeAccessPointsResponseBodyAccessPoints {
	s.AccessGroup = &v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) SetAccessPointId(v string) *DescribeAccessPointsResponseBodyAccessPoints {
	s.AccessPointId = &v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) SetAccessPointName(v string) *DescribeAccessPointsResponseBodyAccessPoints {
	s.AccessPointName = &v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) SetCreateTime(v string) *DescribeAccessPointsResponseBodyAccessPoints {
	s.CreateTime = &v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) SetDomainName(v string) *DescribeAccessPointsResponseBodyAccessPoints {
	s.DomainName = &v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) SetEnabledRam(v bool) *DescribeAccessPointsResponseBodyAccessPoints {
	s.EnabledRam = &v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) SetFileSystemId(v string) *DescribeAccessPointsResponseBodyAccessPoints {
	s.FileSystemId = &v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) SetModifyTime(v string) *DescribeAccessPointsResponseBodyAccessPoints {
	s.ModifyTime = &v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) SetPosixUser(v *DescribeAccessPointsResponseBodyAccessPointsPosixUser) *DescribeAccessPointsResponseBodyAccessPoints {
	s.PosixUser = v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) SetRootPath(v string) *DescribeAccessPointsResponseBodyAccessPoints {
	s.RootPath = &v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) SetRootPathPermission(v *DescribeAccessPointsResponseBodyAccessPointsRootPathPermission) *DescribeAccessPointsResponseBodyAccessPoints {
	s.RootPathPermission = v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) SetRootPathStatus(v string) *DescribeAccessPointsResponseBodyAccessPoints {
	s.RootPathStatus = &v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) SetStatus(v string) *DescribeAccessPointsResponseBodyAccessPoints {
	s.Status = &v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) SetVSwitchId(v string) *DescribeAccessPointsResponseBodyAccessPoints {
	s.VSwitchId = &v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) SetVpcId(v string) *DescribeAccessPointsResponseBodyAccessPoints {
	s.VpcId = &v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPoints) Validate() error {
	return dara.Validate(s)
}

type DescribeAccessPointsResponseBodyAccessPointsPosixUser struct {
	// The ID of the POSIX user group.
	//
	// example:
	//
	// 12
	PosixGroupId *int32 `json:"PosixGroupId,omitempty" xml:"PosixGroupId,omitempty"`
	// The IDs of the secondary user groups.
	PosixSecondaryGroupIds []*int32 `json:"PosixSecondaryGroupIds,omitempty" xml:"PosixSecondaryGroupIds,omitempty" type:"Repeated"`
	// The ID of the POSIX user.
	//
	// example:
	//
	// 123
	PosixUserId *int32 `json:"PosixUserId,omitempty" xml:"PosixUserId,omitempty"`
}

func (s DescribeAccessPointsResponseBodyAccessPointsPosixUser) String() string {
	return dara.Prettify(s)
}

func (s DescribeAccessPointsResponseBodyAccessPointsPosixUser) GoString() string {
	return s.String()
}

func (s *DescribeAccessPointsResponseBodyAccessPointsPosixUser) GetPosixGroupId() *int32 {
	return s.PosixGroupId
}

func (s *DescribeAccessPointsResponseBodyAccessPointsPosixUser) GetPosixSecondaryGroupIds() []*int32 {
	return s.PosixSecondaryGroupIds
}

func (s *DescribeAccessPointsResponseBodyAccessPointsPosixUser) GetPosixUserId() *int32 {
	return s.PosixUserId
}

func (s *DescribeAccessPointsResponseBodyAccessPointsPosixUser) SetPosixGroupId(v int32) *DescribeAccessPointsResponseBodyAccessPointsPosixUser {
	s.PosixGroupId = &v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPointsPosixUser) SetPosixSecondaryGroupIds(v []*int32) *DescribeAccessPointsResponseBodyAccessPointsPosixUser {
	s.PosixSecondaryGroupIds = v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPointsPosixUser) SetPosixUserId(v int32) *DescribeAccessPointsResponseBodyAccessPointsPosixUser {
	s.PosixUserId = &v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPointsPosixUser) Validate() error {
	return dara.Validate(s)
}

type DescribeAccessPointsResponseBodyAccessPointsRootPathPermission struct {
	// The ID of the owner group.
	//
	// example:
	//
	// 12
	OwnerGroupId *int64 `json:"OwnerGroupId,omitempty" xml:"OwnerGroupId,omitempty"`
	// The owner ID.
	//
	// example:
	//
	// 1
	OwnerUserId *int64 `json:"OwnerUserId,omitempty" xml:"OwnerUserId,omitempty"`
	// The POSIX permission.
	//
	// example:
	//
	// 0755
	Permission *string `json:"Permission,omitempty" xml:"Permission,omitempty"`
}

func (s DescribeAccessPointsResponseBodyAccessPointsRootPathPermission) String() string {
	return dara.Prettify(s)
}

func (s DescribeAccessPointsResponseBodyAccessPointsRootPathPermission) GoString() string {
	return s.String()
}

func (s *DescribeAccessPointsResponseBodyAccessPointsRootPathPermission) GetOwnerGroupId() *int64 {
	return s.OwnerGroupId
}

func (s *DescribeAccessPointsResponseBodyAccessPointsRootPathPermission) GetOwnerUserId() *int64 {
	return s.OwnerUserId
}

func (s *DescribeAccessPointsResponseBodyAccessPointsRootPathPermission) GetPermission() *string {
	return s.Permission
}

func (s *DescribeAccessPointsResponseBodyAccessPointsRootPathPermission) SetOwnerGroupId(v int64) *DescribeAccessPointsResponseBodyAccessPointsRootPathPermission {
	s.OwnerGroupId = &v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPointsRootPathPermission) SetOwnerUserId(v int64) *DescribeAccessPointsResponseBodyAccessPointsRootPathPermission {
	s.OwnerUserId = &v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPointsRootPathPermission) SetPermission(v string) *DescribeAccessPointsResponseBodyAccessPointsRootPathPermission {
	s.Permission = &v
	return s
}

func (s *DescribeAccessPointsResponseBodyAccessPointsRootPathPermission) Validate() error {
	return dara.Validate(s)
}

type iDescribeAccessPointsResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeAccessPointsResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeAccessPointsResponse
	GetStatusCode() *int32
	SetBody(v *DescribeAccessPointsResponseBody) *DescribeAccessPointsResponse
	GetBody() *DescribeAccessPointsResponseBody
}

type DescribeAccessPointsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeAccessPointsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeAccessPointsResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeAccessPointsResponse) GoString() string {
	return s.String()
}

func (s *DescribeAccessPointsResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeAccessPointsResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeAccessPointsResponse) GetBody() *DescribeAccessPointsResponseBody {
	return s.Body
}

func (s *DescribeAccessPointsResponse) SetHeaders(v map[string]*string) *DescribeAccessPointsResponse {
	s.Headers = v
	return s
}

func (s *DescribeAccessPointsResponse) SetStatusCode(v int32) *DescribeAccessPointsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAccessPointsResponse) SetBody(v *DescribeAccessPointsResponseBody) *DescribeAccessPointsResponse {
	s.Body = v
	return s
}

func (s *DescribeAccessPointsResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeAccessRulesRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAccessGroupName(v string) *DescribeAccessRulesRequest
	GetAccessGroupName() *string
	SetAccessRuleId(v string) *DescribeAccessRulesRequest
	GetAccessRuleId() *string
	SetFileSystemType(v string) *DescribeAccessRulesRequest
	GetFileSystemType() *string
	SetPageNumber(v int32) *DescribeAccessRulesRequest
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeAccessRulesRequest
	GetPageSize() *int32
	SetSourceCidrIp(v string) *DescribeAccessRulesRequest
	GetSourceCidrIp() *string
	SetSourceCidrIpFilter(v string) *DescribeAccessRulesRequest
	GetSourceCidrIpFilter() *string
}

type DescribeAccessRulesRequest struct {
	// The name of the permission group.
	//
	// This parameter is required.
	//
	// example:
	//
	// vpc-test
	AccessGroupName *string `json:"AccessGroupName,omitempty" xml:"AccessGroupName,omitempty"`
	// The rule ID.
	//
	// example:
	//
	// 1
	AccessRuleId *string `json:"AccessRuleId,omitempty" xml:"AccessRuleId,omitempty"`
	// The type of the file system.
	//
	// Valid values:
	//
	// 	- standard (default): General-purpose NAS file system
	//
	// 	- extreme: Extreme NAS file system
	//
	// example:
	//
	// standard
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
	// The page number.
	//
	// Pages start from page 1. Default value: 1.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	//
	// Valid values: 1 to 100.
	//
	// Default value: 10.
	//
	// example:
	//
	// 1
	PageSize           *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	SourceCidrIp       *string `json:"SourceCidrIp,omitempty" xml:"SourceCidrIp,omitempty"`
	SourceCidrIpFilter *string `json:"SourceCidrIpFilter,omitempty" xml:"SourceCidrIpFilter,omitempty"`
}

func (s DescribeAccessRulesRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeAccessRulesRequest) GoString() string {
	return s.String()
}

func (s *DescribeAccessRulesRequest) GetAccessGroupName() *string {
	return s.AccessGroupName
}

func (s *DescribeAccessRulesRequest) GetAccessRuleId() *string {
	return s.AccessRuleId
}

func (s *DescribeAccessRulesRequest) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *DescribeAccessRulesRequest) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeAccessRulesRequest) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeAccessRulesRequest) GetSourceCidrIp() *string {
	return s.SourceCidrIp
}

func (s *DescribeAccessRulesRequest) GetSourceCidrIpFilter() *string {
	return s.SourceCidrIpFilter
}

func (s *DescribeAccessRulesRequest) SetAccessGroupName(v string) *DescribeAccessRulesRequest {
	s.AccessGroupName = &v
	return s
}

func (s *DescribeAccessRulesRequest) SetAccessRuleId(v string) *DescribeAccessRulesRequest {
	s.AccessRuleId = &v
	return s
}

func (s *DescribeAccessRulesRequest) SetFileSystemType(v string) *DescribeAccessRulesRequest {
	s.FileSystemType = &v
	return s
}

func (s *DescribeAccessRulesRequest) SetPageNumber(v int32) *DescribeAccessRulesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeAccessRulesRequest) SetPageSize(v int32) *DescribeAccessRulesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeAccessRulesRequest) SetSourceCidrIp(v string) *DescribeAccessRulesRequest {
	s.SourceCidrIp = &v
	return s
}

func (s *DescribeAccessRulesRequest) SetSourceCidrIpFilter(v string) *DescribeAccessRulesRequest {
	s.SourceCidrIpFilter = &v
	return s
}

func (s *DescribeAccessRulesRequest) Validate() error {
	return dara.Validate(s)
}

type iDescribeAccessRulesResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetAccessRules(v *DescribeAccessRulesResponseBodyAccessRules) *DescribeAccessRulesResponseBody
	GetAccessRules() *DescribeAccessRulesResponseBodyAccessRules
	SetPageNumber(v int32) *DescribeAccessRulesResponseBody
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeAccessRulesResponseBody
	GetPageSize() *int32
	SetRequestId(v string) *DescribeAccessRulesResponseBody
	GetRequestId() *string
	SetTotalCount(v int32) *DescribeAccessRulesResponseBody
	GetTotalCount() *int32
}

type DescribeAccessRulesResponseBody struct {
	// The rules in the permission group.
	AccessRules *DescribeAccessRulesResponseBodyAccessRules `json:"AccessRules,omitempty" xml:"AccessRules,omitempty" type:"Struct"`
	// The page number.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	//
	// example:
	//
	// 1
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 86D89E82-4297-4343-8E1E-A2495B35****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of rules.
	//
	// example:
	//
	// 1
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeAccessRulesResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeAccessRulesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAccessRulesResponseBody) GetAccessRules() *DescribeAccessRulesResponseBodyAccessRules {
	return s.AccessRules
}

func (s *DescribeAccessRulesResponseBody) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeAccessRulesResponseBody) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeAccessRulesResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeAccessRulesResponseBody) GetTotalCount() *int32 {
	return s.TotalCount
}

func (s *DescribeAccessRulesResponseBody) SetAccessRules(v *DescribeAccessRulesResponseBodyAccessRules) *DescribeAccessRulesResponseBody {
	s.AccessRules = v
	return s
}

func (s *DescribeAccessRulesResponseBody) SetPageNumber(v int32) *DescribeAccessRulesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeAccessRulesResponseBody) SetPageSize(v int32) *DescribeAccessRulesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeAccessRulesResponseBody) SetRequestId(v string) *DescribeAccessRulesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeAccessRulesResponseBody) SetTotalCount(v int32) *DescribeAccessRulesResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeAccessRulesResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeAccessRulesResponseBodyAccessRules struct {
	AccessRule []*DescribeAccessRulesResponseBodyAccessRulesAccessRule `json:"AccessRule,omitempty" xml:"AccessRule,omitempty" type:"Repeated"`
}

func (s DescribeAccessRulesResponseBodyAccessRules) String() string {
	return dara.Prettify(s)
}

func (s DescribeAccessRulesResponseBodyAccessRules) GoString() string {
	return s.String()
}

func (s *DescribeAccessRulesResponseBodyAccessRules) GetAccessRule() []*DescribeAccessRulesResponseBodyAccessRulesAccessRule {
	return s.AccessRule
}

func (s *DescribeAccessRulesResponseBodyAccessRules) SetAccessRule(v []*DescribeAccessRulesResponseBodyAccessRulesAccessRule) *DescribeAccessRulesResponseBodyAccessRules {
	s.AccessRule = v
	return s
}

func (s *DescribeAccessRulesResponseBodyAccessRules) Validate() error {
	return dara.Validate(s)
}

type DescribeAccessRulesResponseBodyAccessRulesAccessRule struct {
	// The name of the permission group.
	//
	// example:
	//
	// test
	AccessGroupName *string `json:"AccessGroupName,omitempty" xml:"AccessGroupName,omitempty"`
	// The ID of the rule.
	//
	// example:
	//
	// 1
	AccessRuleId *string `json:"AccessRuleId,omitempty" xml:"AccessRuleId,omitempty"`
	// The type of the file system.
	//
	// Valid values:
	//
	// 	- standard: General-purpose File Storage NAS (NAS) file system
	//
	// 	- extreme: Extreme NAS file system
	//
	// example:
	//
	// standard
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
	// The IPv6 address or CIDR block of the authorized object.
	//
	// example:
	//
	// 2001:250:6000::***
	Ipv6SourceCidrIp *string `json:"Ipv6SourceCidrIp,omitempty" xml:"Ipv6SourceCidrIp,omitempty"`
	// The priority of the rule.
	//
	// If multiple rules are attached to the authorized object, the rule with the highest priority takes effect.
	//
	// Valid values: 1 to 100. The value 1 indicates the highest priority.
	//
	// example:
	//
	// 1
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The access permissions of the authorized object on the file system.
	//
	// Valid values:
	//
	// 	- RDWR (default): the read and write permissions
	//
	// 	- RDONLY: the read-only permissions
	//
	// example:
	//
	// RDWR
	RWAccess *string `json:"RWAccess,omitempty" xml:"RWAccess,omitempty"`
	// The region ID.
	//
	// example:
	//
	// cn-hangzhou
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The IP address or CIDR block of the authorized object.
	SourceCidrIp *string `json:"SourceCidrIp,omitempty" xml:"SourceCidrIp,omitempty"`
	// The access permissions for different types of users in the authorized object.
	//
	// Valid values:
	//
	// 	- no_squash: allows access from root users to the file system.
	//
	// 	- root_squash: grants root users the least permissions as the nobody user.
	//
	// 	- all_squash: grants all users the least permissions as the nobody user.
	//
	// The nobody user has the least permissions in Linux and can access only the public content of the file system. This ensures the security of the file system.
	//
	// example:
	//
	// no_squash
	UserAccess *string `json:"UserAccess,omitempty" xml:"UserAccess,omitempty"`
}

func (s DescribeAccessRulesResponseBodyAccessRulesAccessRule) String() string {
	return dara.Prettify(s)
}

func (s DescribeAccessRulesResponseBodyAccessRulesAccessRule) GoString() string {
	return s.String()
}

func (s *DescribeAccessRulesResponseBodyAccessRulesAccessRule) GetAccessGroupName() *string {
	return s.AccessGroupName
}

func (s *DescribeAccessRulesResponseBodyAccessRulesAccessRule) GetAccessRuleId() *string {
	return s.AccessRuleId
}

func (s *DescribeAccessRulesResponseBodyAccessRulesAccessRule) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *DescribeAccessRulesResponseBodyAccessRulesAccessRule) GetIpv6SourceCidrIp() *string {
	return s.Ipv6SourceCidrIp
}

func (s *DescribeAccessRulesResponseBodyAccessRulesAccessRule) GetPriority() *int32 {
	return s.Priority
}

func (s *DescribeAccessRulesResponseBodyAccessRulesAccessRule) GetRWAccess() *string {
	return s.RWAccess
}

func (s *DescribeAccessRulesResponseBodyAccessRulesAccessRule) GetRegionId() *string {
	return s.RegionId
}

func (s *DescribeAccessRulesResponseBodyAccessRulesAccessRule) GetSourceCidrIp() *string {
	return s.SourceCidrIp
}

func (s *DescribeAccessRulesResponseBodyAccessRulesAccessRule) GetUserAccess() *string {
	return s.UserAccess
}

func (s *DescribeAccessRulesResponseBodyAccessRulesAccessRule) SetAccessGroupName(v string) *DescribeAccessRulesResponseBodyAccessRulesAccessRule {
	s.AccessGroupName = &v
	return s
}

func (s *DescribeAccessRulesResponseBodyAccessRulesAccessRule) SetAccessRuleId(v string) *DescribeAccessRulesResponseBodyAccessRulesAccessRule {
	s.AccessRuleId = &v
	return s
}

func (s *DescribeAccessRulesResponseBodyAccessRulesAccessRule) SetFileSystemType(v string) *DescribeAccessRulesResponseBodyAccessRulesAccessRule {
	s.FileSystemType = &v
	return s
}

func (s *DescribeAccessRulesResponseBodyAccessRulesAccessRule) SetIpv6SourceCidrIp(v string) *DescribeAccessRulesResponseBodyAccessRulesAccessRule {
	s.Ipv6SourceCidrIp = &v
	return s
}

func (s *DescribeAccessRulesResponseBodyAccessRulesAccessRule) SetPriority(v int32) *DescribeAccessRulesResponseBodyAccessRulesAccessRule {
	s.Priority = &v
	return s
}

func (s *DescribeAccessRulesResponseBodyAccessRulesAccessRule) SetRWAccess(v string) *DescribeAccessRulesResponseBodyAccessRulesAccessRule {
	s.RWAccess = &v
	return s
}

func (s *DescribeAccessRulesResponseBodyAccessRulesAccessRule) SetRegionId(v string) *DescribeAccessRulesResponseBodyAccessRulesAccessRule {
	s.RegionId = &v
	return s
}

func (s *DescribeAccessRulesResponseBodyAccessRulesAccessRule) SetSourceCidrIp(v string) *DescribeAccessRulesResponseBodyAccessRulesAccessRule {
	s.SourceCidrIp = &v
	return s
}

func (s *DescribeAccessRulesResponseBodyAccessRulesAccessRule) SetUserAccess(v string) *DescribeAccessRulesResponseBodyAccessRulesAccessRule {
	s.UserAccess = &v
	return s
}

func (s *DescribeAccessRulesResponseBodyAccessRulesAccessRule) Validate() error {
	return dara.Validate(s)
}

type iDescribeAccessRulesResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeAccessRulesResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeAccessRulesResponse
	GetStatusCode() *int32
	SetBody(v *DescribeAccessRulesResponseBody) *DescribeAccessRulesResponse
	GetBody() *DescribeAccessRulesResponseBody
}

type DescribeAccessRulesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeAccessRulesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeAccessRulesResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeAccessRulesResponse) GoString() string {
	return s.String()
}

func (s *DescribeAccessRulesResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeAccessRulesResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeAccessRulesResponse) GetBody() *DescribeAccessRulesResponseBody {
	return s.Body
}

func (s *DescribeAccessRulesResponse) SetHeaders(v map[string]*string) *DescribeAccessRulesResponse {
	s.Headers = v
	return s
}

func (s *DescribeAccessRulesResponse) SetStatusCode(v int32) *DescribeAccessRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAccessRulesResponse) SetBody(v *DescribeAccessRulesResponseBody) *DescribeAccessRulesResponse {
	s.Body = v
	return s
}

func (s *DescribeAccessRulesResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeAutoSnapshotPoliciesRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAutoSnapshotPolicyId(v string) *DescribeAutoSnapshotPoliciesRequest
	GetAutoSnapshotPolicyId() *string
	SetFileSystemType(v string) *DescribeAutoSnapshotPoliciesRequest
	GetFileSystemType() *string
	SetPageNumber(v int32) *DescribeAutoSnapshotPoliciesRequest
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeAutoSnapshotPoliciesRequest
	GetPageSize() *int32
}

type DescribeAutoSnapshotPoliciesRequest struct {
	// The ID of the automatic snapshot policy.
	//
	// example:
	//
	// sp-extreme-233e6****
	AutoSnapshotPolicyId *string `json:"AutoSnapshotPolicyId,omitempty" xml:"AutoSnapshotPolicyId,omitempty"`
	// The type of the file system.
	//
	// Valid value: extreme, which indicates Extreme File Storage NAS (NAS) file systems.
	//
	// example:
	//
	// extreme
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
	// The page number.
	//
	// Pages start from page 1. Default value: 1.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	//
	// Valid values: 1 to 100.
	//
	// Default value: 10.
	//
	// example:
	//
	// 10
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribeAutoSnapshotPoliciesRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeAutoSnapshotPoliciesRequest) GoString() string {
	return s.String()
}

func (s *DescribeAutoSnapshotPoliciesRequest) GetAutoSnapshotPolicyId() *string {
	return s.AutoSnapshotPolicyId
}

func (s *DescribeAutoSnapshotPoliciesRequest) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *DescribeAutoSnapshotPoliciesRequest) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeAutoSnapshotPoliciesRequest) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeAutoSnapshotPoliciesRequest) SetAutoSnapshotPolicyId(v string) *DescribeAutoSnapshotPoliciesRequest {
	s.AutoSnapshotPolicyId = &v
	return s
}

func (s *DescribeAutoSnapshotPoliciesRequest) SetFileSystemType(v string) *DescribeAutoSnapshotPoliciesRequest {
	s.FileSystemType = &v
	return s
}

func (s *DescribeAutoSnapshotPoliciesRequest) SetPageNumber(v int32) *DescribeAutoSnapshotPoliciesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeAutoSnapshotPoliciesRequest) SetPageSize(v int32) *DescribeAutoSnapshotPoliciesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeAutoSnapshotPoliciesRequest) Validate() error {
	return dara.Validate(s)
}

type iDescribeAutoSnapshotPoliciesResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetAutoSnapshotPolicies(v *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPolicies) *DescribeAutoSnapshotPoliciesResponseBody
	GetAutoSnapshotPolicies() *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPolicies
	SetPageNumber(v int32) *DescribeAutoSnapshotPoliciesResponseBody
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeAutoSnapshotPoliciesResponseBody
	GetPageSize() *int32
	SetRequestId(v string) *DescribeAutoSnapshotPoliciesResponseBody
	GetRequestId() *string
	SetTotalCount(v int32) *DescribeAutoSnapshotPoliciesResponseBody
	GetTotalCount() *int32
}

type DescribeAutoSnapshotPoliciesResponseBody struct {
	// The queried automatic snapshot policies.
	AutoSnapshotPolicies *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPolicies `json:"AutoSnapshotPolicies,omitempty" xml:"AutoSnapshotPolicies,omitempty" type:"Struct"`
	// The page number.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	//
	// example:
	//
	// 10
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of automatic snapshot policies.
	//
	// example:
	//
	// 2
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeAutoSnapshotPoliciesResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeAutoSnapshotPoliciesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAutoSnapshotPoliciesResponseBody) GetAutoSnapshotPolicies() *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPolicies {
	return s.AutoSnapshotPolicies
}

func (s *DescribeAutoSnapshotPoliciesResponseBody) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeAutoSnapshotPoliciesResponseBody) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeAutoSnapshotPoliciesResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeAutoSnapshotPoliciesResponseBody) GetTotalCount() *int32 {
	return s.TotalCount
}

func (s *DescribeAutoSnapshotPoliciesResponseBody) SetAutoSnapshotPolicies(v *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPolicies) *DescribeAutoSnapshotPoliciesResponseBody {
	s.AutoSnapshotPolicies = v
	return s
}

func (s *DescribeAutoSnapshotPoliciesResponseBody) SetPageNumber(v int32) *DescribeAutoSnapshotPoliciesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeAutoSnapshotPoliciesResponseBody) SetPageSize(v int32) *DescribeAutoSnapshotPoliciesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeAutoSnapshotPoliciesResponseBody) SetRequestId(v string) *DescribeAutoSnapshotPoliciesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeAutoSnapshotPoliciesResponseBody) SetTotalCount(v int32) *DescribeAutoSnapshotPoliciesResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeAutoSnapshotPoliciesResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPolicies struct {
	AutoSnapshotPolicy []*DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy `json:"AutoSnapshotPolicy,omitempty" xml:"AutoSnapshotPolicy,omitempty" type:"Repeated"`
}

func (s DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPolicies) String() string {
	return dara.Prettify(s)
}

func (s DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPolicies) GoString() string {
	return s.String()
}

func (s *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPolicies) GetAutoSnapshotPolicy() []*DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy {
	return s.AutoSnapshotPolicy
}

func (s *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPolicies) SetAutoSnapshotPolicy(v []*DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy) *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPolicies {
	s.AutoSnapshotPolicy = v
	return s
}

func (s *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPolicies) Validate() error {
	return dara.Validate(s)
}

type DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy struct {
	// The ID of the automatic snapshot policy.
	//
	// example:
	//
	// sp-extreme-233e6****
	AutoSnapshotPolicyId *string `json:"AutoSnapshotPolicyId,omitempty" xml:"AutoSnapshotPolicyId,omitempty"`
	// The name of the automatic snapshot policy.
	//
	// example:
	//
	// FinanceJoshua
	AutoSnapshotPolicyName *string `json:"AutoSnapshotPolicyName,omitempty" xml:"AutoSnapshotPolicyName,omitempty"`
	// The time when the automatic snapshot policy was created.
	//
	// The time follows the [ISO8601](https://www.iso.org/iso-8601-date-and-time-format.html) standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.
	//
	// example:
	//
	// 2014-04-21T12:08:52Z
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The number of file systems to which the automatic snapshot policy applies.
	//
	// example:
	//
	// 2
	FileSystemNums *int32 `json:"FileSystemNums,omitempty" xml:"FileSystemNums,omitempty"`
	// The type of the file system.
	//
	// example:
	//
	// extreme
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
	// The region ID of the automatic snapshot policy.
	//
	// example:
	//
	// cn-hangzhou
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The days of a week on which auto snapshots are created.
	//
	// Auto snapshots are created on a weekly basis.
	//
	// Valid values: 1 to 7. The values from 1 to 7 indicate 7 days in a week from Monday to Sunday.
	//
	// example:
	//
	// 1,5
	RepeatWeekdays *string `json:"RepeatWeekdays,omitempty" xml:"RepeatWeekdays,omitempty"`
	// The retention period of auto snapshots.
	//
	// Unit: days.
	//
	// Valid values:
	//
	// 	- \\-1: Auto snapshots are permanently retained. After the number of auto snapshots exceeds the upper limit, the earliest auto snapshot is automatically deleted.
	//
	// 	- 1 to 65536: Auto snapshots are retained for the specified days. After the retention period of auto snapshots expires, the auto snapshots are automatically deleted.
	//
	// example:
	//
	// 30
	RetentionDays *int32 `json:"RetentionDays,omitempty" xml:"RetentionDays,omitempty"`
	// The status of the automatic snapshot policy.
	//
	// Valid values:
	//
	// 	- Creating: The automatic snapshot policy is being created.
	//
	// 	- Available: The automatic snapshot policy is available.
	//
	// example:
	//
	// Available
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The points in time at which auto snapshots are created.
	//
	// Unit: hours.
	//
	// Valid values: `0 to 23`. The values from 0 to 23 indicate a total of 24 hours from `00:00 to 23:00`. For example, 1 indicates 01:00. A maximum of 24 points in time can be returned. Multiple points in time are separated with commas (,).
	//
	// example:
	//
	// 4,19
	TimePoints *string `json:"TimePoints,omitempty" xml:"TimePoints,omitempty"`
}

func (s DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy) String() string {
	return dara.Prettify(s)
}

func (s DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy) GoString() string {
	return s.String()
}

func (s *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy) GetAutoSnapshotPolicyId() *string {
	return s.AutoSnapshotPolicyId
}

func (s *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy) GetAutoSnapshotPolicyName() *string {
	return s.AutoSnapshotPolicyName
}

func (s *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy) GetCreateTime() *string {
	return s.CreateTime
}

func (s *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy) GetFileSystemNums() *int32 {
	return s.FileSystemNums
}

func (s *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy) GetRegionId() *string {
	return s.RegionId
}

func (s *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy) GetRepeatWeekdays() *string {
	return s.RepeatWeekdays
}

func (s *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy) GetRetentionDays() *int32 {
	return s.RetentionDays
}

func (s *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy) GetStatus() *string {
	return s.Status
}

func (s *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy) GetTimePoints() *string {
	return s.TimePoints
}

func (s *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy) SetAutoSnapshotPolicyId(v string) *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy {
	s.AutoSnapshotPolicyId = &v
	return s
}

func (s *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy) SetAutoSnapshotPolicyName(v string) *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy {
	s.AutoSnapshotPolicyName = &v
	return s
}

func (s *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy) SetCreateTime(v string) *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy {
	s.CreateTime = &v
	return s
}

func (s *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy) SetFileSystemNums(v int32) *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy {
	s.FileSystemNums = &v
	return s
}

func (s *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy) SetFileSystemType(v string) *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy {
	s.FileSystemType = &v
	return s
}

func (s *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy) SetRegionId(v string) *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy {
	s.RegionId = &v
	return s
}

func (s *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy) SetRepeatWeekdays(v string) *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy {
	s.RepeatWeekdays = &v
	return s
}

func (s *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy) SetRetentionDays(v int32) *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy {
	s.RetentionDays = &v
	return s
}

func (s *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy) SetStatus(v string) *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy {
	s.Status = &v
	return s
}

func (s *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy) SetTimePoints(v string) *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy {
	s.TimePoints = &v
	return s
}

func (s *DescribeAutoSnapshotPoliciesResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy) Validate() error {
	return dara.Validate(s)
}

type iDescribeAutoSnapshotPoliciesResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeAutoSnapshotPoliciesResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeAutoSnapshotPoliciesResponse
	GetStatusCode() *int32
	SetBody(v *DescribeAutoSnapshotPoliciesResponseBody) *DescribeAutoSnapshotPoliciesResponse
	GetBody() *DescribeAutoSnapshotPoliciesResponseBody
}

type DescribeAutoSnapshotPoliciesResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeAutoSnapshotPoliciesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeAutoSnapshotPoliciesResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeAutoSnapshotPoliciesResponse) GoString() string {
	return s.String()
}

func (s *DescribeAutoSnapshotPoliciesResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeAutoSnapshotPoliciesResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeAutoSnapshotPoliciesResponse) GetBody() *DescribeAutoSnapshotPoliciesResponseBody {
	return s.Body
}

func (s *DescribeAutoSnapshotPoliciesResponse) SetHeaders(v map[string]*string) *DescribeAutoSnapshotPoliciesResponse {
	s.Headers = v
	return s
}

func (s *DescribeAutoSnapshotPoliciesResponse) SetStatusCode(v int32) *DescribeAutoSnapshotPoliciesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAutoSnapshotPoliciesResponse) SetBody(v *DescribeAutoSnapshotPoliciesResponseBody) *DescribeAutoSnapshotPoliciesResponse {
	s.Body = v
	return s
}

func (s *DescribeAutoSnapshotPoliciesResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeAutoSnapshotTasksRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAutoSnapshotPolicyIds(v string) *DescribeAutoSnapshotTasksRequest
	GetAutoSnapshotPolicyIds() *string
	SetFileSystemIds(v string) *DescribeAutoSnapshotTasksRequest
	GetFileSystemIds() *string
	SetFileSystemType(v string) *DescribeAutoSnapshotTasksRequest
	GetFileSystemType() *string
	SetPageNumber(v int32) *DescribeAutoSnapshotTasksRequest
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeAutoSnapshotTasksRequest
	GetPageSize() *int32
}

type DescribeAutoSnapshotTasksRequest struct {
	// The IDs of automatic snapshot policies.
	//
	// You can specify a maximum of 100 policy IDs. If you want to query the tasks of multiple automatic snapshot policies, you must separate the policy IDs with commas (,).
	//
	// example:
	//
	// sp-extreme-233e6****,sp-extreme-233e6****, sp-extreme-233e6****
	AutoSnapshotPolicyIds *string `json:"AutoSnapshotPolicyIds,omitempty" xml:"AutoSnapshotPolicyIds,omitempty"`
	// The ID of the file system.
	//
	// You can specify a maximum of 100 file system IDs. If you want to query the snapshots of multiple file systems, you must separate the file system IDs with commas (,).
	//
	// example:
	//
	// extreme-233e6****,extreme -23vbp****,extreme -23vas****
	FileSystemIds *string `json:"FileSystemIds,omitempty" xml:"FileSystemIds,omitempty"`
	// The type of the file system.
	//
	// Valid value: extreme, which indicates Extreme NAS file systems.
	//
	// This parameter is required.
	//
	// example:
	//
	// extreme
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
	// The number of entries per page.
	//
	// Valid values: 1 to 100.
	//
	// Default value: 10.
	//
	// example:
	//
	// 10
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The page number.
	//
	// Pages start from page 1. Default value: 1.
	//
	// example:
	//
	// 1
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribeAutoSnapshotTasksRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeAutoSnapshotTasksRequest) GoString() string {
	return s.String()
}

func (s *DescribeAutoSnapshotTasksRequest) GetAutoSnapshotPolicyIds() *string {
	return s.AutoSnapshotPolicyIds
}

func (s *DescribeAutoSnapshotTasksRequest) GetFileSystemIds() *string {
	return s.FileSystemIds
}

func (s *DescribeAutoSnapshotTasksRequest) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *DescribeAutoSnapshotTasksRequest) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeAutoSnapshotTasksRequest) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeAutoSnapshotTasksRequest) SetAutoSnapshotPolicyIds(v string) *DescribeAutoSnapshotTasksRequest {
	s.AutoSnapshotPolicyIds = &v
	return s
}

func (s *DescribeAutoSnapshotTasksRequest) SetFileSystemIds(v string) *DescribeAutoSnapshotTasksRequest {
	s.FileSystemIds = &v
	return s
}

func (s *DescribeAutoSnapshotTasksRequest) SetFileSystemType(v string) *DescribeAutoSnapshotTasksRequest {
	s.FileSystemType = &v
	return s
}

func (s *DescribeAutoSnapshotTasksRequest) SetPageNumber(v int32) *DescribeAutoSnapshotTasksRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeAutoSnapshotTasksRequest) SetPageSize(v int32) *DescribeAutoSnapshotTasksRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeAutoSnapshotTasksRequest) Validate() error {
	return dara.Validate(s)
}

type iDescribeAutoSnapshotTasksResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetAutoSnapshotTasks(v *DescribeAutoSnapshotTasksResponseBodyAutoSnapshotTasks) *DescribeAutoSnapshotTasksResponseBody
	GetAutoSnapshotTasks() *DescribeAutoSnapshotTasksResponseBodyAutoSnapshotTasks
	SetPageNumber(v int32) *DescribeAutoSnapshotTasksResponseBody
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeAutoSnapshotTasksResponseBody
	GetPageSize() *int32
	SetRequestId(v string) *DescribeAutoSnapshotTasksResponseBody
	GetRequestId() *string
	SetTotalCount(v int32) *DescribeAutoSnapshotTasksResponseBody
	GetTotalCount() *int32
}

type DescribeAutoSnapshotTasksResponseBody struct {
	// The queried automatic snapshot tasks.
	AutoSnapshotTasks *DescribeAutoSnapshotTasksResponseBodyAutoSnapshotTasks `json:"AutoSnapshotTasks,omitempty" xml:"AutoSnapshotTasks,omitempty" type:"Struct"`
	// The page number.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	//
	// example:
	//
	// 10
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 473469C7-AA6F-4DC5-B3DB-A3DC0DE3****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of automatic snapshot tasks.
	//
	// example:
	//
	// 9
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeAutoSnapshotTasksResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeAutoSnapshotTasksResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAutoSnapshotTasksResponseBody) GetAutoSnapshotTasks() *DescribeAutoSnapshotTasksResponseBodyAutoSnapshotTasks {
	return s.AutoSnapshotTasks
}

func (s *DescribeAutoSnapshotTasksResponseBody) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeAutoSnapshotTasksResponseBody) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeAutoSnapshotTasksResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeAutoSnapshotTasksResponseBody) GetTotalCount() *int32 {
	return s.TotalCount
}

func (s *DescribeAutoSnapshotTasksResponseBody) SetAutoSnapshotTasks(v *DescribeAutoSnapshotTasksResponseBodyAutoSnapshotTasks) *DescribeAutoSnapshotTasksResponseBody {
	s.AutoSnapshotTasks = v
	return s
}

func (s *DescribeAutoSnapshotTasksResponseBody) SetPageNumber(v int32) *DescribeAutoSnapshotTasksResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeAutoSnapshotTasksResponseBody) SetPageSize(v int32) *DescribeAutoSnapshotTasksResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeAutoSnapshotTasksResponseBody) SetRequestId(v string) *DescribeAutoSnapshotTasksResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeAutoSnapshotTasksResponseBody) SetTotalCount(v int32) *DescribeAutoSnapshotTasksResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeAutoSnapshotTasksResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeAutoSnapshotTasksResponseBodyAutoSnapshotTasks struct {
	AutoSnapshotTask []*DescribeAutoSnapshotTasksResponseBodyAutoSnapshotTasksAutoSnapshotTask `json:"AutoSnapshotTask,omitempty" xml:"AutoSnapshotTask,omitempty" type:"Repeated"`
}

func (s DescribeAutoSnapshotTasksResponseBodyAutoSnapshotTasks) String() string {
	return dara.Prettify(s)
}

func (s DescribeAutoSnapshotTasksResponseBodyAutoSnapshotTasks) GoString() string {
	return s.String()
}

func (s *DescribeAutoSnapshotTasksResponseBodyAutoSnapshotTasks) GetAutoSnapshotTask() []*DescribeAutoSnapshotTasksResponseBodyAutoSnapshotTasksAutoSnapshotTask {
	return s.AutoSnapshotTask
}

func (s *DescribeAutoSnapshotTasksResponseBodyAutoSnapshotTasks) SetAutoSnapshotTask(v []*DescribeAutoSnapshotTasksResponseBodyAutoSnapshotTasksAutoSnapshotTask) *DescribeAutoSnapshotTasksResponseBodyAutoSnapshotTasks {
	s.AutoSnapshotTask = v
	return s
}

func (s *DescribeAutoSnapshotTasksResponseBodyAutoSnapshotTasks) Validate() error {
	return dara.Validate(s)
}

type DescribeAutoSnapshotTasksResponseBodyAutoSnapshotTasksAutoSnapshotTask struct {
	// The ID of the automatic snapshot policy.
	//
	// example:
	//
	// sp-extreme-233e6****
	AutoSnapshotPolicyId *string `json:"AutoSnapshotPolicyId,omitempty" xml:"AutoSnapshotPolicyId,omitempty"`
	// The ID of the file system.
	//
	// example:
	//
	// extreme-233e6****
	SourceFileSystemId *string `json:"SourceFileSystemId,omitempty" xml:"SourceFileSystemId,omitempty"`
}

func (s DescribeAutoSnapshotTasksResponseBodyAutoSnapshotTasksAutoSnapshotTask) String() string {
	return dara.Prettify(s)
}

func (s DescribeAutoSnapshotTasksResponseBodyAutoSnapshotTasksAutoSnapshotTask) GoString() string {
	return s.String()
}

func (s *DescribeAutoSnapshotTasksResponseBodyAutoSnapshotTasksAutoSnapshotTask) GetAutoSnapshotPolicyId() *string {
	return s.AutoSnapshotPolicyId
}

func (s *DescribeAutoSnapshotTasksResponseBodyAutoSnapshotTasksAutoSnapshotTask) GetSourceFileSystemId() *string {
	return s.SourceFileSystemId
}

func (s *DescribeAutoSnapshotTasksResponseBodyAutoSnapshotTasksAutoSnapshotTask) SetAutoSnapshotPolicyId(v string) *DescribeAutoSnapshotTasksResponseBodyAutoSnapshotTasksAutoSnapshotTask {
	s.AutoSnapshotPolicyId = &v
	return s
}

func (s *DescribeAutoSnapshotTasksResponseBodyAutoSnapshotTasksAutoSnapshotTask) SetSourceFileSystemId(v string) *DescribeAutoSnapshotTasksResponseBodyAutoSnapshotTasksAutoSnapshotTask {
	s.SourceFileSystemId = &v
	return s
}

func (s *DescribeAutoSnapshotTasksResponseBodyAutoSnapshotTasksAutoSnapshotTask) Validate() error {
	return dara.Validate(s)
}

type iDescribeAutoSnapshotTasksResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeAutoSnapshotTasksResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeAutoSnapshotTasksResponse
	GetStatusCode() *int32
	SetBody(v *DescribeAutoSnapshotTasksResponseBody) *DescribeAutoSnapshotTasksResponse
	GetBody() *DescribeAutoSnapshotTasksResponseBody
}

type DescribeAutoSnapshotTasksResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeAutoSnapshotTasksResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeAutoSnapshotTasksResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeAutoSnapshotTasksResponse) GoString() string {
	return s.String()
}

func (s *DescribeAutoSnapshotTasksResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeAutoSnapshotTasksResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeAutoSnapshotTasksResponse) GetBody() *DescribeAutoSnapshotTasksResponseBody {
	return s.Body
}

func (s *DescribeAutoSnapshotTasksResponse) SetHeaders(v map[string]*string) *DescribeAutoSnapshotTasksResponse {
	s.Headers = v
	return s
}

func (s *DescribeAutoSnapshotTasksResponse) SetStatusCode(v int32) *DescribeAutoSnapshotTasksResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAutoSnapshotTasksResponse) SetBody(v *DescribeAutoSnapshotTasksResponseBody) *DescribeAutoSnapshotTasksResponse {
	s.Body = v
	return s
}

func (s *DescribeAutoSnapshotTasksResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeBlackListClientsRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientIP(v string) *DescribeBlackListClientsRequest
	GetClientIP() *string
	SetFileSystemId(v string) *DescribeBlackListClientsRequest
	GetFileSystemId() *string
	SetRegionId(v string) *DescribeBlackListClientsRequest
	GetRegionId() *string
}

type DescribeBlackListClientsRequest struct {
	// The IP address of the client.
	//
	// example:
	//
	// 192.168.0.0
	ClientIP *string `json:"ClientIP,omitempty" xml:"ClientIP,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// cpfs-123458****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The ID of the region where the file system resides.
	//
	// This parameter is required.
	//
	// example:
	//
	// cn-hangzhou
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeBlackListClientsRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeBlackListClientsRequest) GoString() string {
	return s.String()
}

func (s *DescribeBlackListClientsRequest) GetClientIP() *string {
	return s.ClientIP
}

func (s *DescribeBlackListClientsRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeBlackListClientsRequest) GetRegionId() *string {
	return s.RegionId
}

func (s *DescribeBlackListClientsRequest) SetClientIP(v string) *DescribeBlackListClientsRequest {
	s.ClientIP = &v
	return s
}

func (s *DescribeBlackListClientsRequest) SetFileSystemId(v string) *DescribeBlackListClientsRequest {
	s.FileSystemId = &v
	return s
}

func (s *DescribeBlackListClientsRequest) SetRegionId(v string) *DescribeBlackListClientsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeBlackListClientsRequest) Validate() error {
	return dara.Validate(s)
}

type iDescribeBlackListClientsResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetClients(v string) *DescribeBlackListClientsResponseBody
	GetClients() *string
	SetRequestId(v string) *DescribeBlackListClientsResponseBody
	GetRequestId() *string
}

type DescribeBlackListClientsResponseBody struct {
	// The IDs of clients and the status of each client. This parameter contains a JSON object, for example, {"client1": "EVICTING","client2":"EVICTED"}.
	//
	// Available client statuses include:
	//
	// 	- EVICTING indicates that a client is being removed
	//
	// 	- EVICTED indicates that a client is removed
	//
	// 	- ACCEPTING indicates that the write access to the file system is being granted to a client
	//
	// 	- ACCEPTABLE indicates that the write access to the file system is granted to a client
	//
	// example:
	//
	// {"client1": "EVICTING","client2":"EVICTED"}
	Clients *string `json:"Clients,omitempty" xml:"Clients,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// A70BEE5D-76D3-49FB-B58F-1F398211A5C3
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeBlackListClientsResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeBlackListClientsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeBlackListClientsResponseBody) GetClients() *string {
	return s.Clients
}

func (s *DescribeBlackListClientsResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeBlackListClientsResponseBody) SetClients(v string) *DescribeBlackListClientsResponseBody {
	s.Clients = &v
	return s
}

func (s *DescribeBlackListClientsResponseBody) SetRequestId(v string) *DescribeBlackListClientsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeBlackListClientsResponseBody) Validate() error {
	return dara.Validate(s)
}

type iDescribeBlackListClientsResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeBlackListClientsResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeBlackListClientsResponse
	GetStatusCode() *int32
	SetBody(v *DescribeBlackListClientsResponseBody) *DescribeBlackListClientsResponse
	GetBody() *DescribeBlackListClientsResponseBody
}

type DescribeBlackListClientsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeBlackListClientsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeBlackListClientsResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeBlackListClientsResponse) GoString() string {
	return s.String()
}

func (s *DescribeBlackListClientsResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeBlackListClientsResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeBlackListClientsResponse) GetBody() *DescribeBlackListClientsResponseBody {
	return s.Body
}

func (s *DescribeBlackListClientsResponse) SetHeaders(v map[string]*string) *DescribeBlackListClientsResponse {
	s.Headers = v
	return s
}

func (s *DescribeBlackListClientsResponse) SetStatusCode(v int32) *DescribeBlackListClientsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeBlackListClientsResponse) SetBody(v *DescribeBlackListClientsResponseBody) *DescribeBlackListClientsResponse {
	s.Body = v
	return s
}

func (s *DescribeBlackListClientsResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeDataFlowSubTasksRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *DescribeDataFlowSubTasksRequest
	GetFileSystemId() *string
	SetFilters(v []*DescribeDataFlowSubTasksRequestFilters) *DescribeDataFlowSubTasksRequest
	GetFilters() []*DescribeDataFlowSubTasksRequestFilters
	SetMaxResults(v int64) *DescribeDataFlowSubTasksRequest
	GetMaxResults() *int64
	SetNextToken(v string) *DescribeDataFlowSubTasksRequest
	GetNextToken() *string
}

type DescribeDataFlowSubTasksRequest struct {
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// bmcpfs-370lx1ev9ss27o0****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The filter that is used to query data streaming tasks.
	//
	// if can be null:
	// false
	Filters []*DescribeDataFlowSubTasksRequestFilters `json:"Filters,omitempty" xml:"Filters,omitempty" type:"Repeated"`
	// The number of results for each query.
	//
	// 	- Valid values: 20 to 100.
	//
	// 	- Default value: 20.
	//
	// example:
	//
	// 20
	MaxResults *int64 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.
	//
	// example:
	//
	// iWk0AQAAAAAvY2FzZS8=
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
}

func (s DescribeDataFlowSubTasksRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeDataFlowSubTasksRequest) GoString() string {
	return s.String()
}

func (s *DescribeDataFlowSubTasksRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeDataFlowSubTasksRequest) GetFilters() []*DescribeDataFlowSubTasksRequestFilters {
	return s.Filters
}

func (s *DescribeDataFlowSubTasksRequest) GetMaxResults() *int64 {
	return s.MaxResults
}

func (s *DescribeDataFlowSubTasksRequest) GetNextToken() *string {
	return s.NextToken
}

func (s *DescribeDataFlowSubTasksRequest) SetFileSystemId(v string) *DescribeDataFlowSubTasksRequest {
	s.FileSystemId = &v
	return s
}

func (s *DescribeDataFlowSubTasksRequest) SetFilters(v []*DescribeDataFlowSubTasksRequestFilters) *DescribeDataFlowSubTasksRequest {
	s.Filters = v
	return s
}

func (s *DescribeDataFlowSubTasksRequest) SetMaxResults(v int64) *DescribeDataFlowSubTasksRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeDataFlowSubTasksRequest) SetNextToken(v string) *DescribeDataFlowSubTasksRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeDataFlowSubTasksRequest) Validate() error {
	return dara.Validate(s)
}

type DescribeDataFlowSubTasksRequestFilters struct {
	// The filter name.
	//
	// Valid values:
	//
	// 	- DataFlowIds: filters data flow subtasks by data flow ID.
	//
	// 	- DataFlowTaskIds: filters data flow subtasks by data flow task ID.
	//
	// 	- DataFlowSubTaskIds: filters data flow subtasks by data streaming task ID.
	//
	// 	- Status: filters data flow subtasks by status.
	//
	// 	- SrcFilePath: filters data flow subtasks by source file path.
	//
	// 	- DstFilePath: filters data flow subtasks by destination file path.
	//
	// example:
	//
	// DataFlowSubTaskIds
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The filter value. This parameter does not support wildcards.
	//
	// 	- If Key is set to DataFlowIds, set Value to a data flow ID or a part of the data flow ID. You can specify a data flow ID or a group of data flow IDs. You can specify a maximum of 10 data flow IDs. Example: `df-194433a5be31****` or `df-194433a5be31****,df-244433a5be31****`.
	//
	// 	- If Key is set to DataFlowTaskIds, set Value to a data flow task ID or a part of the data flow task ID. You can specify a data flow task ID or a group of data flow task IDs. You can specify a maximum of 10 data flow task IDs. Example:  `task-38aa8e890f45****` or `task-38aa8e890f45****,task-27aa8e890f45****`.
	//
	// 	- If Key is set to DataFlowSubTaskIds, set Value to a data streaming task ID or a part of the data streaming task ID. You can specify a data streaming task ID or a group of data streaming task IDs. You can specify a maximum of 10 data streaming task IDs. Example: ` subTaskId-370kyfmyknxcyzw***	- `or `subTaskId-370kyfmyknxcyzw****,subTaskId-280kyfmyknxcyzw****`.
	//
	// 	- If Key is set to Status, set Value to the status of the data flow task. The status can be EXPIRED, CREATED, RUNNING, COMPLETE, CANCELING, FAILED, or CANCELED. Combined query is supported.
	//
	// 	- If Key is set to SrcFilePath, set Value to the path of the source file. The path can be up to 1,023 characters in length.
	//
	// 	- If Key is set to DstFilePath, set Value to the path of the destination file. The path can be up to 1,023 characters in length.
	//
	// example:
	//
	// subTaskId-370kyfmyknxcyzw****
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDataFlowSubTasksRequestFilters) String() string {
	return dara.Prettify(s)
}

func (s DescribeDataFlowSubTasksRequestFilters) GoString() string {
	return s.String()
}

func (s *DescribeDataFlowSubTasksRequestFilters) GetKey() *string {
	return s.Key
}

func (s *DescribeDataFlowSubTasksRequestFilters) GetValue() *string {
	return s.Value
}

func (s *DescribeDataFlowSubTasksRequestFilters) SetKey(v string) *DescribeDataFlowSubTasksRequestFilters {
	s.Key = &v
	return s
}

func (s *DescribeDataFlowSubTasksRequestFilters) SetValue(v string) *DescribeDataFlowSubTasksRequestFilters {
	s.Value = &v
	return s
}

func (s *DescribeDataFlowSubTasksRequestFilters) Validate() error {
	return dara.Validate(s)
}

type iDescribeDataFlowSubTasksResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetDataFlowSubTask(v *DescribeDataFlowSubTasksResponseBodyDataFlowSubTask) *DescribeDataFlowSubTasksResponseBody
	GetDataFlowSubTask() *DescribeDataFlowSubTasksResponseBodyDataFlowSubTask
	SetNextToken(v string) *DescribeDataFlowSubTasksResponseBody
	GetNextToken() *string
	SetRequestId(v string) *DescribeDataFlowSubTasksResponseBody
	GetRequestId() *string
}

type DescribeDataFlowSubTasksResponseBody struct {
	// The details about data streaming tasks.
	DataFlowSubTask *DescribeDataFlowSubTasksResponseBodyDataFlowSubTask `json:"DataFlowSubTask,omitempty" xml:"DataFlowSubTask,omitempty" type:"Struct"`
	// The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.
	//
	// example:
	//
	// pUJaUwAAAABhdGUyNTk1MQ==
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 98696EF0-1607-4E9D-B01D-F20930B6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDataFlowSubTasksResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeDataFlowSubTasksResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDataFlowSubTasksResponseBody) GetDataFlowSubTask() *DescribeDataFlowSubTasksResponseBodyDataFlowSubTask {
	return s.DataFlowSubTask
}

func (s *DescribeDataFlowSubTasksResponseBody) GetNextToken() *string {
	return s.NextToken
}

func (s *DescribeDataFlowSubTasksResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeDataFlowSubTasksResponseBody) SetDataFlowSubTask(v *DescribeDataFlowSubTasksResponseBodyDataFlowSubTask) *DescribeDataFlowSubTasksResponseBody {
	s.DataFlowSubTask = v
	return s
}

func (s *DescribeDataFlowSubTasksResponseBody) SetNextToken(v string) *DescribeDataFlowSubTasksResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeDataFlowSubTasksResponseBody) SetRequestId(v string) *DescribeDataFlowSubTasksResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDataFlowSubTasksResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeDataFlowSubTasksResponseBodyDataFlowSubTask struct {
	DataFlowSubTask []*DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask `json:"DataFlowSubTask,omitempty" xml:"DataFlowSubTask,omitempty" type:"Repeated"`
}

func (s DescribeDataFlowSubTasksResponseBodyDataFlowSubTask) String() string {
	return dara.Prettify(s)
}

func (s DescribeDataFlowSubTasksResponseBodyDataFlowSubTask) GoString() string {
	return s.String()
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTask) GetDataFlowSubTask() []*DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask {
	return s.DataFlowSubTask
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTask) SetDataFlowSubTask(v []*DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) *DescribeDataFlowSubTasksResponseBodyDataFlowSubTask {
	s.DataFlowSubTask = v
	return s
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTask) Validate() error {
	return dara.Validate(s)
}

type DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask struct {
	// The time when the data streaming task was created.
	//
	// example:
	//
	// 2024-07-01 19:59:29
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the data flow.
	//
	// example:
	//
	// df-194433a5be31****
	DataFlowId *string `json:"DataFlowId,omitempty" xml:"DataFlowId,omitempty"`
	// The ID of the data streaming task.
	//
	// example:
	//
	// subTaskId-370kyfmyknxcyzw****
	DataFlowSubTaskId *string `json:"DataFlowSubTaskId,omitempty" xml:"DataFlowSubTaskId,omitempty"`
	// The ID of the data flow task.
	//
	// example:
	//
	// task-38aa8e890f45****
	DataFlowTaskId *string `json:"DataFlowTaskId,omitempty" xml:"DataFlowTaskId,omitempty"`
	// The path of the destination file. Limits:
	//
	// 	- The path must be 1 to 1,023 characters in length.
	//
	// 	- The path must be encoded in UTF-8.
	//
	// 	- The path must start with a forward slash (/).
	//
	// 	- The path must end with the file name.
	//
	// example:
	//
	// /mnt/file.png
	DstFilePath *string `json:"DstFilePath,omitempty" xml:"DstFilePath,omitempty"`
	// The time when the data streaming task ended.
	//
	// example:
	//
	// 2024-07-04 11:14:22
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The error message returned when the task failed.
	ErrorMsg *string `json:"ErrorMsg,omitempty" xml:"ErrorMsg,omitempty"`
	// The file information.
	FileDetail *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskFileDetail `json:"FileDetail,omitempty" xml:"FileDetail,omitempty" type:"Struct"`
	// The ID of the file system.
	//
	// example:
	//
	// bmcpfs-370lx1ev9ss27o0****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The progress of the data streaming task. Valid values: 0 to 10000.
	//
	// example:
	//
	// 10000
	Progress *int32 `json:"Progress,omitempty" xml:"Progress,omitempty"`
	// The progress information about data streaming tasks.
	ProgressStats *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskProgressStats `json:"ProgressStats,omitempty" xml:"ProgressStats,omitempty" type:"Struct"`
	// The path of the source file. Limits:
	//
	// 	- The path must be 1 to 1,023 characters in length.
	//
	// 	- The path must be encoded in UTF-8.
	//
	// 	- The path must start with a forward slash (/).
	//
	// 	- The path must end with the file name.
	//
	// example:
	//
	// /test/file.png
	SrcFilePath *string `json:"SrcFilePath,omitempty" xml:"SrcFilePath,omitempty"`
	// The time when the data streaming task started.
	//
	// example:
	//
	// 2024-07-03 10:43:16
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The status of the data streaming task. Valid values:
	//
	// 	- EXPIRED: The task is terminated.
	//
	// 	- CREATED: The task is created.
	//
	// 	- RUNNING: The task is running.
	//
	// 	- COMPLETE: The task is complete.
	//
	// 	- CANCELING: The task is being canceled.
	//
	// 	- FAILED: The task failed to be executed.
	//
	// 	- CANCELED: The task is canceled.
	//
	// example:
	//
	// COMPLETE
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) String() string {
	return dara.Prettify(s)
}

func (s DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) GoString() string {
	return s.String()
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) GetCreateTime() *string {
	return s.CreateTime
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) GetDataFlowId() *string {
	return s.DataFlowId
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) GetDataFlowSubTaskId() *string {
	return s.DataFlowSubTaskId
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) GetDataFlowTaskId() *string {
	return s.DataFlowTaskId
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) GetDstFilePath() *string {
	return s.DstFilePath
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) GetEndTime() *string {
	return s.EndTime
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) GetErrorMsg() *string {
	return s.ErrorMsg
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) GetFileDetail() *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskFileDetail {
	return s.FileDetail
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) GetProgress() *int32 {
	return s.Progress
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) GetProgressStats() *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskProgressStats {
	return s.ProgressStats
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) GetSrcFilePath() *string {
	return s.SrcFilePath
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) GetStartTime() *string {
	return s.StartTime
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) GetStatus() *string {
	return s.Status
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) SetCreateTime(v string) *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask {
	s.CreateTime = &v
	return s
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) SetDataFlowId(v string) *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask {
	s.DataFlowId = &v
	return s
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) SetDataFlowSubTaskId(v string) *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask {
	s.DataFlowSubTaskId = &v
	return s
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) SetDataFlowTaskId(v string) *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask {
	s.DataFlowTaskId = &v
	return s
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) SetDstFilePath(v string) *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask {
	s.DstFilePath = &v
	return s
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) SetEndTime(v string) *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask {
	s.EndTime = &v
	return s
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) SetErrorMsg(v string) *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask {
	s.ErrorMsg = &v
	return s
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) SetFileDetail(v *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskFileDetail) *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask {
	s.FileDetail = v
	return s
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) SetFileSystemId(v string) *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask {
	s.FileSystemId = &v
	return s
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) SetProgress(v int32) *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask {
	s.Progress = &v
	return s
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) SetProgressStats(v *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskProgressStats) *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask {
	s.ProgressStats = v
	return s
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) SetSrcFilePath(v string) *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask {
	s.SrcFilePath = &v
	return s
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) SetStartTime(v string) *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask {
	s.StartTime = &v
	return s
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) SetStatus(v string) *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask {
	s.Status = &v
	return s
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTask) Validate() error {
	return dara.Validate(s)
}

type DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskFileDetail struct {
	// The checksum. Format example: crc64:123456.
	//
	// example:
	//
	// crc64:850309505450944****
	Checksum *string `json:"Checksum,omitempty" xml:"Checksum,omitempty"`
	// The time when the file was modified. The value is a UNIX timestamp. Unit: ns.
	//
	// example:
	//
	// 1721167603
	ModifyTime *int64 `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// The file size. Unit: bytes.
	//
	// example:
	//
	// 68
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
}

func (s DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskFileDetail) String() string {
	return dara.Prettify(s)
}

func (s DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskFileDetail) GoString() string {
	return s.String()
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskFileDetail) GetChecksum() *string {
	return s.Checksum
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskFileDetail) GetModifyTime() *int64 {
	return s.ModifyTime
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskFileDetail) GetSize() *int64 {
	return s.Size
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskFileDetail) SetChecksum(v string) *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskFileDetail {
	s.Checksum = &v
	return s
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskFileDetail) SetModifyTime(v int64) *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskFileDetail {
	s.ModifyTime = &v
	return s
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskFileDetail) SetSize(v int64) *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskFileDetail {
	s.Size = &v
	return s
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskFileDetail) Validate() error {
	return dara.Validate(s)
}

type DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskProgressStats struct {
	// The actual amount of data for which the data flow task is complete. Unit: bytes.
	//
	// example:
	//
	// 68
	ActualBytes *int64 `json:"ActualBytes,omitempty" xml:"ActualBytes,omitempty"`
	// The average flow velocity. Unit: bytes/s.
	//
	// example:
	//
	// 34
	AverageSpeed *int64 `json:"AverageSpeed,omitempty" xml:"AverageSpeed,omitempty"`
	// The amount of data (including skipped data) for which the data flow task is complete. Unit: bytes.
	//
	// example:
	//
	// 68
	BytesDone *int64 `json:"BytesDone,omitempty" xml:"BytesDone,omitempty"`
	// The amount of data scanned on the source. Unit: bytes.
	//
	// example:
	//
	// 68
	BytesTotal *int64 `json:"BytesTotal,omitempty" xml:"BytesTotal,omitempty"`
}

func (s DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskProgressStats) String() string {
	return dara.Prettify(s)
}

func (s DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskProgressStats) GoString() string {
	return s.String()
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskProgressStats) GetActualBytes() *int64 {
	return s.ActualBytes
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskProgressStats) GetAverageSpeed() *int64 {
	return s.AverageSpeed
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskProgressStats) GetBytesDone() *int64 {
	return s.BytesDone
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskProgressStats) GetBytesTotal() *int64 {
	return s.BytesTotal
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskProgressStats) SetActualBytes(v int64) *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskProgressStats {
	s.ActualBytes = &v
	return s
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskProgressStats) SetAverageSpeed(v int64) *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskProgressStats {
	s.AverageSpeed = &v
	return s
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskProgressStats) SetBytesDone(v int64) *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskProgressStats {
	s.BytesDone = &v
	return s
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskProgressStats) SetBytesTotal(v int64) *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskProgressStats {
	s.BytesTotal = &v
	return s
}

func (s *DescribeDataFlowSubTasksResponseBodyDataFlowSubTaskDataFlowSubTaskProgressStats) Validate() error {
	return dara.Validate(s)
}

type iDescribeDataFlowSubTasksResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeDataFlowSubTasksResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeDataFlowSubTasksResponse
	GetStatusCode() *int32
	SetBody(v *DescribeDataFlowSubTasksResponseBody) *DescribeDataFlowSubTasksResponse
	GetBody() *DescribeDataFlowSubTasksResponseBody
}

type DescribeDataFlowSubTasksResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDataFlowSubTasksResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDataFlowSubTasksResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeDataFlowSubTasksResponse) GoString() string {
	return s.String()
}

func (s *DescribeDataFlowSubTasksResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeDataFlowSubTasksResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeDataFlowSubTasksResponse) GetBody() *DescribeDataFlowSubTasksResponseBody {
	return s.Body
}

func (s *DescribeDataFlowSubTasksResponse) SetHeaders(v map[string]*string) *DescribeDataFlowSubTasksResponse {
	s.Headers = v
	return s
}

func (s *DescribeDataFlowSubTasksResponse) SetStatusCode(v int32) *DescribeDataFlowSubTasksResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDataFlowSubTasksResponse) SetBody(v *DescribeDataFlowSubTasksResponseBody) *DescribeDataFlowSubTasksResponse {
	s.Body = v
	return s
}

func (s *DescribeDataFlowSubTasksResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeDataFlowTasksRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *DescribeDataFlowTasksRequest
	GetFileSystemId() *string
	SetFilters(v []*DescribeDataFlowTasksRequestFilters) *DescribeDataFlowTasksRequest
	GetFilters() []*DescribeDataFlowTasksRequestFilters
	SetMaxResults(v int64) *DescribeDataFlowTasksRequest
	GetMaxResults() *int64
	SetNextToken(v string) *DescribeDataFlowTasksRequest
	GetNextToken() *string
}

type DescribeDataFlowTasksRequest struct {
	// The ID of the file system.
	//
	// 	- The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-099394bd928c\\*\\*\\*\\*.
	//
	// 	- The IDs of CPFS for LINGJUN file systems must start with `bmcpfs-`. Example: bmcpfs-290w65p03ok64ya\\*\\*\\*\\*.
	//
	// >  CPFS is not supported on the international site.
	//
	// This parameter is required.
	//
	// example:
	//
	// cpfs-099394bd928c****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The details about filters.
	//
	// if can be null:
	// false
	Filters []*DescribeDataFlowTasksRequestFilters `json:"Filters,omitempty" xml:"Filters,omitempty" type:"Repeated"`
	// The number of results for each query.
	//
	// Valid values: 10 to 100.
	//
	// Default value: 20.
	//
	// example:
	//
	// 20
	MaxResults *int64 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.
	//
	// example:
	//
	// TGlzdFJlc291cmNlU****mVzJjE1MTI2NjY4NzY5MTAzOTEmMiZORnI4NDhVeEtrUT0=
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
}

func (s DescribeDataFlowTasksRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeDataFlowTasksRequest) GoString() string {
	return s.String()
}

func (s *DescribeDataFlowTasksRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeDataFlowTasksRequest) GetFilters() []*DescribeDataFlowTasksRequestFilters {
	return s.Filters
}

func (s *DescribeDataFlowTasksRequest) GetMaxResults() *int64 {
	return s.MaxResults
}

func (s *DescribeDataFlowTasksRequest) GetNextToken() *string {
	return s.NextToken
}

func (s *DescribeDataFlowTasksRequest) SetFileSystemId(v string) *DescribeDataFlowTasksRequest {
	s.FileSystemId = &v
	return s
}

func (s *DescribeDataFlowTasksRequest) SetFilters(v []*DescribeDataFlowTasksRequestFilters) *DescribeDataFlowTasksRequest {
	s.Filters = v
	return s
}

func (s *DescribeDataFlowTasksRequest) SetMaxResults(v int64) *DescribeDataFlowTasksRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeDataFlowTasksRequest) SetNextToken(v string) *DescribeDataFlowTasksRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeDataFlowTasksRequest) Validate() error {
	return dara.Validate(s)
}

type DescribeDataFlowTasksRequestFilters struct {
	// The filter name.
	//
	// Valid values:
	//
	// 	- DataFlowIds: filters data flow tasks by data flow ID.
	//
	// 	- TaskIds: filters data flow tasks by task ID.
	//
	// 	- Originator: filters data flow tasks by task initiator.
	//
	// 	- TaskActions: filters data flow tasks by task type.
	//
	// 	- DataTypes: filters data flow tasks by data type.
	//
	// 	- Status: filters data flow tasks by data flow status.
	//
	// 	- CreateTimeBegin: filters data flow tasks that are created after a specified time.
	//
	// 	- CreateTimeEnd: filters data flow tasks that are created before a specified time.
	//
	// 	- StartTimeBegin: filters data flow tasks that are started after a specified time.
	//
	// 	- StartTimeEnd: filters data flow tasks that are started before a specified time.
	//
	// 	- EndTimeBegin: filters data flow tasks that are stopped after a specified time.
	//
	// 	- EndTimeEnd: filters data flow tasks that are stopped before a specified time.
	//
	// example:
	//
	// DataFlowIds
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The filter value. This parameter does not support wildcards.
	//
	// 	- If Key is set to DataFlowIds, set Value to a data flow ID or a part of the data flow ID. You can specify a data flow ID or a group of data flow IDs. You can specify a maximum of 10 data flow IDs. Example: `df-194433a5be31****` or `df-194433a512a2****,df-234533a5be31****`.
	//
	// 	- If Key is set to TaskId, set Value to a data flow task ID or a part of the data flow task ID. You can specify a data flow task ID or a group of data flow task IDs. You can specify a maximum of 10 data flow task IDs. Example: `task-38aa8e890f45****` or `task-38aa8e890f45****,task-29ae8e890f45****`.
	//
	// 	- If Key is set to TaskActions, set Value to the type of data flow task. The task type can be **Import**, **Export**, **Evict**, **Inventory**, **StreamImport**, or **StreamExport**. Combined query is supported. CPFS for LINGJUN supports only the Import, Export, StreamImport, and StreamExport tasks. Only CPFS for LINGJUN V2.6.0 and later support the StreamImport and StreamExport tasks.
	//
	// 	- If Key is set to DataTypes, set Value to the data type of the data flow task. The data type can be MetaAndData, Metadata, or Data. Combined query is supported.
	//
	// 	- If Key is set to Originator, set Value to the initiator of the data flow task. The initiator can be User or System.
	//
	// 	- If Key is set to Status, set Value to the status of the data flow task. The status can be Pending, Executing, Failed, Completed, Canceling, or Canceled. Combined query is supported.
	//
	// 	- If Key is set to CreateTimeBegin, set Value to the beginning of the time range to create the data flow task. Time format: `yyyy-MM-ddThh:mmZ`.
	//
	// 	- If Key is set to CreateTimeEnd, set Value to the end of the time range to create the data flow task. Time format: `yyyy-MM-ddThh:mmZ`.
	//
	// 	- If Key is set to StartTimeBegin, set Value to the beginning of the time range to start the data flow task. Time format: `yyyy-MM-ddThh:mmZ`.
	//
	// 	- If Key is set to StartTimeEnd, set Value to the end of the time range to start the data flow task. Time format: `yyyy-MM-ddThh:mmZ`.
	//
	// 	- If Key is set to EndTimeBegin, set Value to the beginning of the time range to stop the data flow task. Time format: `yyyy-MM-ddThh:mmZ`.
	//
	// 	- If Key is set to EndTimeEnd, set Value to the end of the time range to stop the data flow task. Time format: `yyyy-MM-ddThh:mmZ`.
	//
	// example:
	//
	// dfid-12345678
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDataFlowTasksRequestFilters) String() string {
	return dara.Prettify(s)
}

func (s DescribeDataFlowTasksRequestFilters) GoString() string {
	return s.String()
}

func (s *DescribeDataFlowTasksRequestFilters) GetKey() *string {
	return s.Key
}

func (s *DescribeDataFlowTasksRequestFilters) GetValue() *string {
	return s.Value
}

func (s *DescribeDataFlowTasksRequestFilters) SetKey(v string) *DescribeDataFlowTasksRequestFilters {
	s.Key = &v
	return s
}

func (s *DescribeDataFlowTasksRequestFilters) SetValue(v string) *DescribeDataFlowTasksRequestFilters {
	s.Value = &v
	return s
}

func (s *DescribeDataFlowTasksRequestFilters) Validate() error {
	return dara.Validate(s)
}

type iDescribeDataFlowTasksResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetNextToken(v string) *DescribeDataFlowTasksResponseBody
	GetNextToken() *string
	SetRequestId(v string) *DescribeDataFlowTasksResponseBody
	GetRequestId() *string
	SetTaskInfo(v *DescribeDataFlowTasksResponseBodyTaskInfo) *DescribeDataFlowTasksResponseBody
	GetTaskInfo() *DescribeDataFlowTasksResponseBodyTaskInfo
}

type DescribeDataFlowTasksResponseBody struct {
	// The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.
	//
	// example:
	//
	// TGlzdFJlc291cmNlU****mVzJjE1MTI2NjY4NzY5MTAzOTEmMiZORnI4NDhVeEtrUT0=
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 2D69A58F-345C-4FDE-88E4-BF518948****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about data flow tasks.
	TaskInfo *DescribeDataFlowTasksResponseBodyTaskInfo `json:"TaskInfo,omitempty" xml:"TaskInfo,omitempty" type:"Struct"`
}

func (s DescribeDataFlowTasksResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeDataFlowTasksResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDataFlowTasksResponseBody) GetNextToken() *string {
	return s.NextToken
}

func (s *DescribeDataFlowTasksResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeDataFlowTasksResponseBody) GetTaskInfo() *DescribeDataFlowTasksResponseBodyTaskInfo {
	return s.TaskInfo
}

func (s *DescribeDataFlowTasksResponseBody) SetNextToken(v string) *DescribeDataFlowTasksResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBody) SetRequestId(v string) *DescribeDataFlowTasksResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBody) SetTaskInfo(v *DescribeDataFlowTasksResponseBodyTaskInfo) *DescribeDataFlowTasksResponseBody {
	s.TaskInfo = v
	return s
}

func (s *DescribeDataFlowTasksResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeDataFlowTasksResponseBodyTaskInfo struct {
	Task []*DescribeDataFlowTasksResponseBodyTaskInfoTask `json:"Task,omitempty" xml:"Task,omitempty" type:"Repeated"`
}

func (s DescribeDataFlowTasksResponseBodyTaskInfo) String() string {
	return dara.Prettify(s)
}

func (s DescribeDataFlowTasksResponseBodyTaskInfo) GoString() string {
	return s.String()
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfo) GetTask() []*DescribeDataFlowTasksResponseBodyTaskInfoTask {
	return s.Task
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfo) SetTask(v []*DescribeDataFlowTasksResponseBodyTaskInfoTask) *DescribeDataFlowTasksResponseBodyTaskInfo {
	s.Task = v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfo) Validate() error {
	return dara.Validate(s)
}

type DescribeDataFlowTasksResponseBodyTaskInfoTask struct {
	// The conflict policy for files with the same name. Valid values:
	//
	// 	- SKIP_THE_FILE: skips files with the same name.
	//
	// 	- KEEP_LATEST: compares the update time and keeps the latest version.
	//
	// 	- OVERWRITE_EXISTING: forcibly overwrites the existing file.
	//
	// example:
	//
	// KEEP_LATEST
	ConflictPolicy *string `json:"ConflictPolicy,omitempty" xml:"ConflictPolicy,omitempty"`
	// The time when the task was created.
	//
	// example:
	//
	// 2021-08-04 18:27:35
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the data flow.
	//
	// example:
	//
	// dfid-194433a5be3****
	DataFlowId *string `json:"DataFlowId,omitempty" xml:"DataFlowId,omitempty"`
	// The type of data on which operations are performed by the data flow task. Valid values:
	//
	// 	- Metadata: the metadata of a file, including the timestamp, ownership, and permission information of the file. If you select Metadata, only the metadata of the file is imported. You can only query the file. When you access the file data, the file is loaded from the source storage as required.
	//
	// 	- Data: the data blocks of the file.
	//
	// 	- MetaAndData: the metadata and data blocks of the file.
	//
	// >  CPFS for LINGJUN supports only the MetaAndData type.
	//
	// example:
	//
	// Metadata
	DataType *string `json:"DataType,omitempty" xml:"DataType,omitempty"`
	// The directory in which the data flow task is executed.
	//
	// example:
	//
	// /path_in_cpfs/
	Directory *string `json:"Directory,omitempty" xml:"Directory,omitempty"`
	// The directory mapped to the data flow task.
	//
	// example:
	//
	// /path_in_cpfs/
	DstDirectory *string `json:"DstDirectory,omitempty" xml:"DstDirectory,omitempty"`
	// The time when the task ended.
	//
	// example:
	//
	// 2021-08-04 18:27:35
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The cause of the task exception.
	//
	// >  If this parameter is not returned or the return value is empty, no error occurs.
	ErrorMsg *string `json:"ErrorMsg,omitempty" xml:"ErrorMsg,omitempty"`
	// The directory of the fileset in the CPFS file system.
	//
	// Limits:
	//
	// 	- The directory must be 2 to 1024 characters in length.
	//
	// 	- The directory must be encoded in UTF-8.
	//
	// 	- The directory must start and end with a forward slash (/).
	//
	// 	- The directory must be a fileset directory in the CPFS file system.
	//
	// >  Only CPFS supports this parameter.
	//
	// example:
	//
	// /a/b/c/
	FileSystemPath *string `json:"FileSystemPath,omitempty" xml:"FileSystemPath,omitempty"`
	// The ID of the file system.
	//
	// example:
	//
	// cpfs-099394bd928c****
	FilesystemId *string `json:"FilesystemId,omitempty" xml:"FilesystemId,omitempty"`
	// The path of the smart directory.
	//
	// example:
	//
	// /aa/
	FsPath *string `json:"FsPath,omitempty" xml:"FsPath,omitempty"`
	// The initiator of the data flow task. Valid values:
	//
	// 	- User: The task is initiated by a user.
	//
	// 	- System: The task is automatically initiated by CPFS based on the automatic update interval.
	//
	// >  Only CPFS supports this parameter.
	//
	// example:
	//
	// User
	Originator *string `json:"Originator,omitempty" xml:"Originator,omitempty"`
	// The progress of the data flow task. The number of operations that have been performed by the data flow task.
	//
	// example:
	//
	// 240
	Progress *int64 `json:"Progress,omitempty" xml:"Progress,omitempty"`
	// The progress of the data flow task.
	ProgressStats *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats `json:"ProgressStats,omitempty" xml:"ProgressStats,omitempty" type:"Struct"`
	// Deprecated
	//
	// The save path of data flow task reports in the CPFS file system.
	//
	// 	- The task reports for a CPFS file system are generated in the `.dataflow_report` directory of the CPFS file system.
	//
	// 	- CPFS for LINGJUN returns an OSS download link for you to download the task reports.
	//
	// example:
	//
	// /path_in_cpfs/reportfile.cvs
	ReportPath *string `json:"ReportPath,omitempty" xml:"ReportPath,omitempty"`
	// The reports.
	//
	// >  Streaming tasks do not support reports.
	Reports *DescribeDataFlowTasksResponseBodyTaskInfoTaskReports `json:"Reports,omitempty" xml:"Reports,omitempty" type:"Struct"`
	// The access path of the source storage. Format: `<storage type>://[<account id>:]<path>`.
	//
	// Parameters:
	//
	// 	- storage type: Only Object Storage Service (OSS) is supported.
	//
	// 	- account id: the UID of the account of the source storage.
	//
	// 	- path: the name of the OSS bucket. Limits:
	//
	//     	- The name can contain only lowercase letters, digits, and hyphens (-). The name must start and end with a lowercase letter or digit.
	//
	//     	- The name can be up to 128 characters in length.
	//
	//     	- The name must be encoded in UTF-8.
	//
	// >
	//
	// 	- The OSS bucket must be an existing bucket in the region.
	//
	// 	- Only CPFS for LINGJUN V2.6.0 and later support the account id parameter.
	//
	// example:
	//
	// oss://bucket1
	SourceStorage *string `json:"SourceStorage,omitempty" xml:"SourceStorage,omitempty"`
	// The time when the task started.
	//
	// example:
	//
	// 2021-08-04 18:27:35
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The status of the data flow task. Valid values:
	//
	// 	- Pending: The data flow task has been created and has not started.
	//
	// 	- Executing: The data flow task is being executed.
	//
	// 	- Failed: The data flow task failed to be executed. You can view the cause of the failure in the data flow task report.
	//
	// 	- Completed: The data flow task is completed. You can check that all the files have been correctly transferred in the data flow task report.
	//
	// 	- Canceled: The data flow task is canceled and is not completed.
	//
	// 	- Canceling: The data flow task is being canceled.
	//
	// example:
	//
	// Executing
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the data flow task. Valid values:
	//
	// 	- Import: imports data stored in the source storage to a CPFS file system.
	//
	// 	- Export: exports specified data from a CPFS file system to the source storage.
	//
	// 	- StreamImport: imports the specified data from the source storage to a CPFS file system in streaming mode.
	//
	// 	- StreamExport: exports specified data from a CPFS file system to the source storage in streaming mode.
	//
	// 	- Evict: releases the data blocks of a file in a CPFS file system. After the eviction, only the metadata of the file is retained in the CPFS file system. You can still query the file. However, the data blocks of the file are cleared and do not occupy the storage space in the CPFS file system. When you access the file data, the file is loaded from the source storage as required.
	//
	// 	- Inventory: obtains the inventory list managed by a data flow from the CPFS file system, providing the cache status of inventories in the data flow.
	//
	// >  Only CPFS for LINGJUN V2.6.0 and later support StreamImport and StreamExport.
	//
	// example:
	//
	// Import
	TaskAction *string `json:"TaskAction,omitempty" xml:"TaskAction,omitempty"`
	// The ID of the data flow task.
	//
	// example:
	//
	// taskId-12345678
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DescribeDataFlowTasksResponseBodyTaskInfoTask) String() string {
	return dara.Prettify(s)
}

func (s DescribeDataFlowTasksResponseBodyTaskInfoTask) GoString() string {
	return s.String()
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) GetConflictPolicy() *string {
	return s.ConflictPolicy
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) GetCreateTime() *string {
	return s.CreateTime
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) GetDataFlowId() *string {
	return s.DataFlowId
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) GetDataType() *string {
	return s.DataType
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) GetDirectory() *string {
	return s.Directory
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) GetDstDirectory() *string {
	return s.DstDirectory
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) GetEndTime() *string {
	return s.EndTime
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) GetErrorMsg() *string {
	return s.ErrorMsg
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) GetFileSystemPath() *string {
	return s.FileSystemPath
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) GetFilesystemId() *string {
	return s.FilesystemId
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) GetFsPath() *string {
	return s.FsPath
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) GetOriginator() *string {
	return s.Originator
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) GetProgress() *int64 {
	return s.Progress
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) GetProgressStats() *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats {
	return s.ProgressStats
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) GetReportPath() *string {
	return s.ReportPath
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) GetReports() *DescribeDataFlowTasksResponseBodyTaskInfoTaskReports {
	return s.Reports
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) GetSourceStorage() *string {
	return s.SourceStorage
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) GetStartTime() *string {
	return s.StartTime
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) GetStatus() *string {
	return s.Status
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) GetTaskAction() *string {
	return s.TaskAction
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) GetTaskId() *string {
	return s.TaskId
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) SetConflictPolicy(v string) *DescribeDataFlowTasksResponseBodyTaskInfoTask {
	s.ConflictPolicy = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) SetCreateTime(v string) *DescribeDataFlowTasksResponseBodyTaskInfoTask {
	s.CreateTime = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) SetDataFlowId(v string) *DescribeDataFlowTasksResponseBodyTaskInfoTask {
	s.DataFlowId = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) SetDataType(v string) *DescribeDataFlowTasksResponseBodyTaskInfoTask {
	s.DataType = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) SetDirectory(v string) *DescribeDataFlowTasksResponseBodyTaskInfoTask {
	s.Directory = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) SetDstDirectory(v string) *DescribeDataFlowTasksResponseBodyTaskInfoTask {
	s.DstDirectory = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) SetEndTime(v string) *DescribeDataFlowTasksResponseBodyTaskInfoTask {
	s.EndTime = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) SetErrorMsg(v string) *DescribeDataFlowTasksResponseBodyTaskInfoTask {
	s.ErrorMsg = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) SetFileSystemPath(v string) *DescribeDataFlowTasksResponseBodyTaskInfoTask {
	s.FileSystemPath = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) SetFilesystemId(v string) *DescribeDataFlowTasksResponseBodyTaskInfoTask {
	s.FilesystemId = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) SetFsPath(v string) *DescribeDataFlowTasksResponseBodyTaskInfoTask {
	s.FsPath = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) SetOriginator(v string) *DescribeDataFlowTasksResponseBodyTaskInfoTask {
	s.Originator = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) SetProgress(v int64) *DescribeDataFlowTasksResponseBodyTaskInfoTask {
	s.Progress = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) SetProgressStats(v *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats) *DescribeDataFlowTasksResponseBodyTaskInfoTask {
	s.ProgressStats = v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) SetReportPath(v string) *DescribeDataFlowTasksResponseBodyTaskInfoTask {
	s.ReportPath = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) SetReports(v *DescribeDataFlowTasksResponseBodyTaskInfoTaskReports) *DescribeDataFlowTasksResponseBodyTaskInfoTask {
	s.Reports = v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) SetSourceStorage(v string) *DescribeDataFlowTasksResponseBodyTaskInfoTask {
	s.SourceStorage = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) SetStartTime(v string) *DescribeDataFlowTasksResponseBodyTaskInfoTask {
	s.StartTime = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) SetStatus(v string) *DescribeDataFlowTasksResponseBodyTaskInfoTask {
	s.Status = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) SetTaskAction(v string) *DescribeDataFlowTasksResponseBodyTaskInfoTask {
	s.TaskAction = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) SetTaskId(v string) *DescribeDataFlowTasksResponseBodyTaskInfoTask {
	s.TaskId = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTask) Validate() error {
	return dara.Validate(s)
}

type DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats struct {
	// The actual amount of data for which the data flow task is complete. Unit: bytes.
	//
	// example:
	//
	// 131092971520
	ActualBytes *int64 `json:"ActualBytes,omitempty" xml:"ActualBytes,omitempty"`
	// The actual number of files for which the data flow task is complete.
	//
	// example:
	//
	// 3
	ActualFiles *int64 `json:"ActualFiles,omitempty" xml:"ActualFiles,omitempty"`
	// The average flow velocity. Unit: bytes/s.
	//
	// example:
	//
	// 342279299
	AverageSpeed *int64 `json:"AverageSpeed,omitempty" xml:"AverageSpeed,omitempty"`
	// The amount of data (including skipped data) for which the data flow task is complete. Unit: bytes.
	//
	// example:
	//
	// 131092971520
	BytesDone *int64 `json:"BytesDone,omitempty" xml:"BytesDone,omitempty"`
	// The amount of data scanned on the source. Unit: bytes.
	//
	// example:
	//
	// 131092971520
	BytesTotal *int64 `json:"BytesTotal,omitempty" xml:"BytesTotal,omitempty"`
	// The number of files (including skipped files) for which the data flow task is complete.
	//
	// example:
	//
	// 3
	FilesDone *int64 `json:"FilesDone,omitempty" xml:"FilesDone,omitempty"`
	// The number of files scanned on the source.
	//
	// example:
	//
	// 3
	FilesTotal *int64 `json:"FilesTotal,omitempty" xml:"FilesTotal,omitempty"`
	// The estimated remaining execution time. Unit: seconds.
	//
	// example:
	//
	// 437
	RemainTime *int64 `json:"RemainTime,omitempty" xml:"RemainTime,omitempty"`
}

func (s DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats) String() string {
	return dara.Prettify(s)
}

func (s DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats) GoString() string {
	return s.String()
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats) GetActualBytes() *int64 {
	return s.ActualBytes
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats) GetActualFiles() *int64 {
	return s.ActualFiles
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats) GetAverageSpeed() *int64 {
	return s.AverageSpeed
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats) GetBytesDone() *int64 {
	return s.BytesDone
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats) GetBytesTotal() *int64 {
	return s.BytesTotal
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats) GetFilesDone() *int64 {
	return s.FilesDone
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats) GetFilesTotal() *int64 {
	return s.FilesTotal
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats) GetRemainTime() *int64 {
	return s.RemainTime
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats) SetActualBytes(v int64) *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats {
	s.ActualBytes = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats) SetActualFiles(v int64) *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats {
	s.ActualFiles = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats) SetAverageSpeed(v int64) *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats {
	s.AverageSpeed = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats) SetBytesDone(v int64) *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats {
	s.BytesDone = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats) SetBytesTotal(v int64) *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats {
	s.BytesTotal = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats) SetFilesDone(v int64) *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats {
	s.FilesDone = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats) SetFilesTotal(v int64) *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats {
	s.FilesTotal = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats) SetRemainTime(v int64) *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats {
	s.RemainTime = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTaskProgressStats) Validate() error {
	return dara.Validate(s)
}

type DescribeDataFlowTasksResponseBodyTaskInfoTaskReports struct {
	Report []*DescribeDataFlowTasksResponseBodyTaskInfoTaskReportsReport `json:"Report,omitempty" xml:"Report,omitempty" type:"Repeated"`
}

func (s DescribeDataFlowTasksResponseBodyTaskInfoTaskReports) String() string {
	return dara.Prettify(s)
}

func (s DescribeDataFlowTasksResponseBodyTaskInfoTaskReports) GoString() string {
	return s.String()
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTaskReports) GetReport() []*DescribeDataFlowTasksResponseBodyTaskInfoTaskReportsReport {
	return s.Report
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTaskReports) SetReport(v []*DescribeDataFlowTasksResponseBodyTaskInfoTaskReportsReport) *DescribeDataFlowTasksResponseBodyTaskInfoTaskReports {
	s.Report = v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTaskReports) Validate() error {
	return dara.Validate(s)
}

type DescribeDataFlowTasksResponseBodyTaskInfoTaskReportsReport struct {
	// The name of the report.
	//
	// 	- CPFS:
	//
	//     TotalFilesReport: task reports.
	//
	// 	- CPFS for LINGJUN:
	//
	//     	- FailedFilesReport: failed file reports.
	//
	//     	- SkippedFilesReport: skipped file reports.
	//
	//     	- SuccessFilesReport: successful file reports.
	//
	// example:
	//
	// TotalFilesReport
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The report URL.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s DescribeDataFlowTasksResponseBodyTaskInfoTaskReportsReport) String() string {
	return dara.Prettify(s)
}

func (s DescribeDataFlowTasksResponseBodyTaskInfoTaskReportsReport) GoString() string {
	return s.String()
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTaskReportsReport) GetName() *string {
	return s.Name
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTaskReportsReport) GetPath() *string {
	return s.Path
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTaskReportsReport) SetName(v string) *DescribeDataFlowTasksResponseBodyTaskInfoTaskReportsReport {
	s.Name = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTaskReportsReport) SetPath(v string) *DescribeDataFlowTasksResponseBodyTaskInfoTaskReportsReport {
	s.Path = &v
	return s
}

func (s *DescribeDataFlowTasksResponseBodyTaskInfoTaskReportsReport) Validate() error {
	return dara.Validate(s)
}

type iDescribeDataFlowTasksResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeDataFlowTasksResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeDataFlowTasksResponse
	GetStatusCode() *int32
	SetBody(v *DescribeDataFlowTasksResponseBody) *DescribeDataFlowTasksResponse
	GetBody() *DescribeDataFlowTasksResponseBody
}

type DescribeDataFlowTasksResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDataFlowTasksResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDataFlowTasksResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeDataFlowTasksResponse) GoString() string {
	return s.String()
}

func (s *DescribeDataFlowTasksResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeDataFlowTasksResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeDataFlowTasksResponse) GetBody() *DescribeDataFlowTasksResponseBody {
	return s.Body
}

func (s *DescribeDataFlowTasksResponse) SetHeaders(v map[string]*string) *DescribeDataFlowTasksResponse {
	s.Headers = v
	return s
}

func (s *DescribeDataFlowTasksResponse) SetStatusCode(v int32) *DescribeDataFlowTasksResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDataFlowTasksResponse) SetBody(v *DescribeDataFlowTasksResponseBody) *DescribeDataFlowTasksResponse {
	s.Body = v
	return s
}

func (s *DescribeDataFlowTasksResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeDataFlowsRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *DescribeDataFlowsRequest
	GetFileSystemId() *string
	SetFilters(v []*DescribeDataFlowsRequestFilters) *DescribeDataFlowsRequest
	GetFilters() []*DescribeDataFlowsRequestFilters
	SetMaxResults(v int64) *DescribeDataFlowsRequest
	GetMaxResults() *int64
	SetNextToken(v string) *DescribeDataFlowsRequest
	GetNextToken() *string
}

type DescribeDataFlowsRequest struct {
	// The ID of the file system.
	//
	// 	- The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-125487\\*\\*\\*\\*.
	//
	// 	- The IDs of CPFS for LINGJUN file systems must start with `bmcpfs-`. Example: bmcpfs-0015\\*\\*\\*\\*.
	//
	// >  CPFS file systems are available only on the China site (aliyun.com).
	//
	// This parameter is required.
	//
	// example:
	//
	// bmcpfs-290w65p03ok64ya****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The filter that is used to query data flows.
	//
	// if can be null:
	// true
	Filters []*DescribeDataFlowsRequestFilters `json:"Filters,omitempty" xml:"Filters,omitempty" type:"Repeated"`
	// The number of results for each query.
	//
	// Valid values: 10 to 100. Default value: 20.
	//
	// example:
	//
	// 20
	MaxResults *int64 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.
	//
	// example:
	//
	// TGlzdFJlc291cmNlU****mVzJjE1MTI2NjY4NzY5MTAzOTEmMiZORnI4NDhVeEtrUT0=
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
}

func (s DescribeDataFlowsRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeDataFlowsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDataFlowsRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeDataFlowsRequest) GetFilters() []*DescribeDataFlowsRequestFilters {
	return s.Filters
}

func (s *DescribeDataFlowsRequest) GetMaxResults() *int64 {
	return s.MaxResults
}

func (s *DescribeDataFlowsRequest) GetNextToken() *string {
	return s.NextToken
}

func (s *DescribeDataFlowsRequest) SetFileSystemId(v string) *DescribeDataFlowsRequest {
	s.FileSystemId = &v
	return s
}

func (s *DescribeDataFlowsRequest) SetFilters(v []*DescribeDataFlowsRequestFilters) *DescribeDataFlowsRequest {
	s.Filters = v
	return s
}

func (s *DescribeDataFlowsRequest) SetMaxResults(v int64) *DescribeDataFlowsRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeDataFlowsRequest) SetNextToken(v string) *DescribeDataFlowsRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeDataFlowsRequest) Validate() error {
	return dara.Validate(s)
}

type DescribeDataFlowsRequestFilters struct {
	// The filter name. Valid values:
	//
	// 	- DataFlowIds: filters data flows by data flow ID.
	//
	// 	- FsetIds: filters data flows by fileset ID.
	//
	// 	- FileSystemPath: filters data flows based on the path of a fileset in a CPFS file system.
	//
	// 	- SourceStorage: filters data flows based on the access path of the source storage.
	//
	// 	- ThroughputList: filters data flows based on data flow throughput.
	//
	// 	- Description: filters data flows based on the fileset description.
	//
	// 	- Status: filters data flows based on data flow status.
	//
	// example:
	//
	// FsetIds
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The filter value. This parameter does not support wildcards.
	//
	// 	- If Key is set to DataFlowIds, set Value to a data flow ID or a part of the data flow ID. You can specify a data flow ID or a group of data flow IDs. You can specify a maximum of 10 data flow IDs. Example: `df-194433a5be31****` or `df-194433a5be31****,df-184433a5be31****`.
	//
	// 	- If Key is set to FsetIds, set Value to a fileset ID or a part of the fileset ID. You can specify a fileset ID or a group of fileset IDs. You can specify a maximum of 10 fileset IDs. Example: `fset-1902718ea0ae****` or `fset-1902718ea0ae****,fset-1242718ea0ae****`.
	//
	// 	- If Key is set to FileSystemPath, set Value to the path or a part of the path of a fileset in a CPFS file system. The value of the parameter must be 1 to 1,024 characters in length.
	//
	// 	- If Key is set to SourceStorage, set Value to the access path or a part of the access path of the source storage. The path can be up to 1,024 characters in length.
	//
	// 	- If Key is set to ThroughputList, set Value to the data flow throughput. Combined query is supported.
	//
	// 	- If Key is set to Description, set Value to a data flow description or a part of the data flow description.
	//
	// 	- If Key is set to Status, set Value to the data flow status.
	//
	// 	- If Key is set to SourceStoragePath, set Value to the access path or a part of the access path of the source storage. The path can be up to 1,024 characters in length.
	//
	// example:
	//
	// FsetIds
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeDataFlowsRequestFilters) String() string {
	return dara.Prettify(s)
}

func (s DescribeDataFlowsRequestFilters) GoString() string {
	return s.String()
}

func (s *DescribeDataFlowsRequestFilters) GetKey() *string {
	return s.Key
}

func (s *DescribeDataFlowsRequestFilters) GetValue() *string {
	return s.Value
}

func (s *DescribeDataFlowsRequestFilters) SetKey(v string) *DescribeDataFlowsRequestFilters {
	s.Key = &v
	return s
}

func (s *DescribeDataFlowsRequestFilters) SetValue(v string) *DescribeDataFlowsRequestFilters {
	s.Value = &v
	return s
}

func (s *DescribeDataFlowsRequestFilters) Validate() error {
	return dara.Validate(s)
}

type iDescribeDataFlowsResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetDataFlowInfo(v *DescribeDataFlowsResponseBodyDataFlowInfo) *DescribeDataFlowsResponseBody
	GetDataFlowInfo() *DescribeDataFlowsResponseBodyDataFlowInfo
	SetNextToken(v string) *DescribeDataFlowsResponseBody
	GetNextToken() *string
	SetRequestId(v string) *DescribeDataFlowsResponseBody
	GetRequestId() *string
}

type DescribeDataFlowsResponseBody struct {
	// The details about data flows.
	DataFlowInfo *DescribeDataFlowsResponseBodyDataFlowInfo `json:"DataFlowInfo,omitempty" xml:"DataFlowInfo,omitempty" type:"Struct"`
	// A pagination token. It can be used in the next request to retrieve a new page of results.
	//
	// example:
	//
	// TGlzdFJlc291cmNlU****mVzJjE1MTI2NjY4NzY5MTAzOTEmMiZORnI4NDhVeEtrUT0=
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 2D69A58F-345C-4FDE-88E4-BF518948****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDataFlowsResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeDataFlowsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDataFlowsResponseBody) GetDataFlowInfo() *DescribeDataFlowsResponseBodyDataFlowInfo {
	return s.DataFlowInfo
}

func (s *DescribeDataFlowsResponseBody) GetNextToken() *string {
	return s.NextToken
}

func (s *DescribeDataFlowsResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeDataFlowsResponseBody) SetDataFlowInfo(v *DescribeDataFlowsResponseBodyDataFlowInfo) *DescribeDataFlowsResponseBody {
	s.DataFlowInfo = v
	return s
}

func (s *DescribeDataFlowsResponseBody) SetNextToken(v string) *DescribeDataFlowsResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeDataFlowsResponseBody) SetRequestId(v string) *DescribeDataFlowsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDataFlowsResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeDataFlowsResponseBodyDataFlowInfo struct {
	DataFlow []*DescribeDataFlowsResponseBodyDataFlowInfoDataFlow `json:"DataFlow,omitempty" xml:"DataFlow,omitempty" type:"Repeated"`
}

func (s DescribeDataFlowsResponseBodyDataFlowInfo) String() string {
	return dara.Prettify(s)
}

func (s DescribeDataFlowsResponseBodyDataFlowInfo) GoString() string {
	return s.String()
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfo) GetDataFlow() []*DescribeDataFlowsResponseBodyDataFlowInfoDataFlow {
	return s.DataFlow
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfo) SetDataFlow(v []*DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) *DescribeDataFlowsResponseBodyDataFlowInfo {
	s.DataFlow = v
	return s
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfo) Validate() error {
	return dara.Validate(s)
}

type DescribeDataFlowsResponseBodyDataFlowInfoDataFlow struct {
	// The details about automatic update policies.
	//
	// >  Only CPFS supports this parameter.
	AutoRefresh *DescribeDataFlowsResponseBodyDataFlowInfoDataFlowAutoRefresh `json:"AutoRefresh,omitempty" xml:"AutoRefresh,omitempty" type:"Struct"`
	// The automatic update interval. CPFS checks whether data is updated in the directory at the interval specified by this parameter. If data is updated, CPFS starts an automatic update task. Unit: minutes.
	//
	// Valid values: 5 to 526600. Default value: 10.
	//
	// >  Only CPFS supports this parameter.
	//
	// example:
	//
	// 10
	AutoRefreshInterval *int64 `json:"AutoRefreshInterval,omitempty" xml:"AutoRefreshInterval,omitempty"`
	// The automatic update policy. The updated data in the source storage is imported into the CPFS file system based on the policy. Valid values:
	//
	// 	- None: Updated data in the source storage is not automatically imported into the CPFS file system. You can run a data flow task to import the updated data from the source storage.
	//
	// 	- ImportChanged: Updated data in the source storage is automatically imported into the CPFS file system.
	//
	// >  Only CPFS supports this parameter.
	//
	// example:
	//
	// None
	AutoRefreshPolicy *string `json:"AutoRefreshPolicy,omitempty" xml:"AutoRefreshPolicy,omitempty"`
	// The time when the fileset was created.
	//
	// The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format.
	//
	// example:
	//
	// 2021-09-30T10:08:08Z
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The dataflow ID.
	//
	// example:
	//
	// df-194433a5be31****
	DataFlowId *string `json:"DataFlowId,omitempty" xml:"DataFlowId,omitempty"`
	// The description of the dataflow.
	//
	// Limits:
	//
	// 	- The description must be 2 to 128 characters in length.
	//
	// 	- The description must start with a letter but cannot start with `http://` or `https://`.
	//
	// 	- The description can contain letters, digits, colons (:), underscores (_), and hyphens (-).
	//
	// example:
	//
	// test
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The error message returned. Valid values:
	//
	// 	- None (default): The dataflow status is normal.
	//
	// 	- SourceStorageUnreachable: The access path of the source storage is not found.
	//
	// 	- ThroughputTooLow: The dataflow throughput is low.
	//
	// example:
	//
	// SourceStorageUnreachable
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the file system.
	//
	// example:
	//
	// cpfs-099394bd928c****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The directory of the fileset in the CPFS file system.
	//
	// Limits:
	//
	// 	- The directory must be 2 to 1,024 characters in length.
	//
	// 	- The directory must be encoded in UTF-8.
	//
	// 	- The directory must start and end with a forward slash (/).
	//
	// 	- The directory must be a fileset directory in the CPFS file system.
	//
	// >  Only CPFS supports this parameter.
	//
	// example:
	//
	// /a/b/c/
	FileSystemPath *string `json:"FileSystemPath,omitempty" xml:"FileSystemPath,omitempty"`
	// The description of the automatic update.
	//
	// >  Only CPFS supports this parameter.
	//
	// example:
	//
	// FsetTest
	FsetDescription *string `json:"FsetDescription,omitempty" xml:"FsetDescription,omitempty"`
	// The fileset ID.
	//
	// example:
	//
	// fset-1902718ea0ae****
	FsetId *string `json:"FsetId,omitempty" xml:"FsetId,omitempty"`
	// The type of security mechanism for the source storage. This parameter must be specified if the source storage is accessed with a security mechanism. Valid values:
	//
	// 	- None (default): The source storage can be accessed without a security mechanism.
	//
	// 	- SSL: The source storage must be accessed with an SSL certificate.
	//
	// example:
	//
	// SSL
	SourceSecurityType *string `json:"SourceSecurityType,omitempty" xml:"SourceSecurityType,omitempty"`
	// The access path of the source storage. Format: `<storage type>://<path>`.
	//
	// Parameters:
	//
	// 	- storage type: Only Object Storage Service (OSS) is supported.
	//
	// 	- path: the name of the OSS bucket.
	//
	//     	- The name can contain only lowercase letters, digits, and hyphens (-). The name must start and end with a lowercase letter or digit.
	//
	//     	- The name must be 8 to 128 characters in length.
	//
	//     	- The name must be encoded in UTF-8.
	//
	//     	- The name cannot start with http:// or https://.
	//
	// >  The OSS bucket must be an existing bucket in the region.
	//
	// example:
	//
	// oss://bucket1
	SourceStorage *string `json:"SourceStorage,omitempty" xml:"SourceStorage,omitempty"`
	// The access path in the bucket of the source storage.
	//
	// >  Only CPFS for LINGJUN supports this parameter.
	//
	// example:
	//
	// /prefix/
	SourceStoragePath *string `json:"SourceStoragePath,omitempty" xml:"SourceStoragePath,omitempty"`
	// The dataflow status. Valid values:
	//
	// 	- Starting: The dataflow is being created or enabled.
	//
	// 	- Running: The dataflow has been created and is running properly.
	//
	// 	- Updating: The dataflow is being modified. For example, the dataflow throughput is increased and the automatic update interval is modified.
	//
	// 	- Deleting: The dataflow is being deleted.
	//
	// 	- Stopping: The dataflow is being disabled.
	//
	// 	- Stopped: The dataflow has been disabled.
	//
	// 	- Misconfigured: The dataflow configuration is abnormal. For example, the source storage is inaccessible, and the automatic update cannot be completed due to low dataflow throughput.
	//
	// example:
	//
	// Running
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The maximum dataflow throughput. Unit: MB/s. Valid values:
	//
	// 	- 600
	//
	// 	- 1,200
	//
	// 	- 1,500
	//
	// >  The dataflow throughput must be less than the I/O throughput of the file system.
	//
	// example:
	//
	// 600
	Throughput *int64 `json:"Throughput,omitempty" xml:"Throughput,omitempty"`
	// The time when the fileset was last updated.
	//
	// The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format.
	//
	// example:
	//
	// 2021-09-30T10:08:08Z
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) String() string {
	return dara.Prettify(s)
}

func (s DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) GoString() string {
	return s.String()
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) GetAutoRefresh() *DescribeDataFlowsResponseBodyDataFlowInfoDataFlowAutoRefresh {
	return s.AutoRefresh
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) GetAutoRefreshInterval() *int64 {
	return s.AutoRefreshInterval
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) GetAutoRefreshPolicy() *string {
	return s.AutoRefreshPolicy
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) GetCreateTime() *string {
	return s.CreateTime
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) GetDataFlowId() *string {
	return s.DataFlowId
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) GetDescription() *string {
	return s.Description
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) GetErrorMessage() *string {
	return s.ErrorMessage
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) GetFileSystemPath() *string {
	return s.FileSystemPath
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) GetFsetDescription() *string {
	return s.FsetDescription
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) GetFsetId() *string {
	return s.FsetId
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) GetSourceSecurityType() *string {
	return s.SourceSecurityType
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) GetSourceStorage() *string {
	return s.SourceStorage
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) GetSourceStoragePath() *string {
	return s.SourceStoragePath
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) GetStatus() *string {
	return s.Status
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) GetThroughput() *int64 {
	return s.Throughput
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) GetUpdateTime() *string {
	return s.UpdateTime
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) SetAutoRefresh(v *DescribeDataFlowsResponseBodyDataFlowInfoDataFlowAutoRefresh) *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow {
	s.AutoRefresh = v
	return s
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) SetAutoRefreshInterval(v int64) *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow {
	s.AutoRefreshInterval = &v
	return s
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) SetAutoRefreshPolicy(v string) *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow {
	s.AutoRefreshPolicy = &v
	return s
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) SetCreateTime(v string) *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow {
	s.CreateTime = &v
	return s
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) SetDataFlowId(v string) *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow {
	s.DataFlowId = &v
	return s
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) SetDescription(v string) *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow {
	s.Description = &v
	return s
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) SetErrorMessage(v string) *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow {
	s.ErrorMessage = &v
	return s
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) SetFileSystemId(v string) *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow {
	s.FileSystemId = &v
	return s
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) SetFileSystemPath(v string) *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow {
	s.FileSystemPath = &v
	return s
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) SetFsetDescription(v string) *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow {
	s.FsetDescription = &v
	return s
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) SetFsetId(v string) *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow {
	s.FsetId = &v
	return s
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) SetSourceSecurityType(v string) *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow {
	s.SourceSecurityType = &v
	return s
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) SetSourceStorage(v string) *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow {
	s.SourceStorage = &v
	return s
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) SetSourceStoragePath(v string) *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow {
	s.SourceStoragePath = &v
	return s
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) SetStatus(v string) *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow {
	s.Status = &v
	return s
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) SetThroughput(v int64) *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow {
	s.Throughput = &v
	return s
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) SetUpdateTime(v string) *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow {
	s.UpdateTime = &v
	return s
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlow) Validate() error {
	return dara.Validate(s)
}

type DescribeDataFlowsResponseBodyDataFlowInfoDataFlowAutoRefresh struct {
	AutoRefresh []*DescribeDataFlowsResponseBodyDataFlowInfoDataFlowAutoRefreshAutoRefresh `json:"AutoRefresh,omitempty" xml:"AutoRefresh,omitempty" type:"Repeated"`
}

func (s DescribeDataFlowsResponseBodyDataFlowInfoDataFlowAutoRefresh) String() string {
	return dara.Prettify(s)
}

func (s DescribeDataFlowsResponseBodyDataFlowInfoDataFlowAutoRefresh) GoString() string {
	return s.String()
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlowAutoRefresh) GetAutoRefresh() []*DescribeDataFlowsResponseBodyDataFlowInfoDataFlowAutoRefreshAutoRefresh {
	return s.AutoRefresh
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlowAutoRefresh) SetAutoRefresh(v []*DescribeDataFlowsResponseBodyDataFlowInfoDataFlowAutoRefreshAutoRefresh) *DescribeDataFlowsResponseBodyDataFlowInfoDataFlowAutoRefresh {
	s.AutoRefresh = v
	return s
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlowAutoRefresh) Validate() error {
	return dara.Validate(s)
}

type DescribeDataFlowsResponseBodyDataFlowInfoDataFlowAutoRefreshAutoRefresh struct {
	// The automatic update directory. CPFS automatically checks whether the source data only in the directory is updated and imports the updated data.
	//
	// Limits:
	//
	// 	- The directory must be 2 to 1,024 characters in length.
	//
	// 	- The directory must be encoded in UTF-8.
	//
	// 	- The directory must start and end with a forward slash (/).
	//
	// >  The directory must be an existing directory in the CPFS file system and must be in a fileset where the dataflow is enabled.
	//
	// example:
	//
	// /prefix1/prefix2/
	RefreshPath *string `json:"RefreshPath,omitempty" xml:"RefreshPath,omitempty"`
}

func (s DescribeDataFlowsResponseBodyDataFlowInfoDataFlowAutoRefreshAutoRefresh) String() string {
	return dara.Prettify(s)
}

func (s DescribeDataFlowsResponseBodyDataFlowInfoDataFlowAutoRefreshAutoRefresh) GoString() string {
	return s.String()
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlowAutoRefreshAutoRefresh) GetRefreshPath() *string {
	return s.RefreshPath
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlowAutoRefreshAutoRefresh) SetRefreshPath(v string) *DescribeDataFlowsResponseBodyDataFlowInfoDataFlowAutoRefreshAutoRefresh {
	s.RefreshPath = &v
	return s
}

func (s *DescribeDataFlowsResponseBodyDataFlowInfoDataFlowAutoRefreshAutoRefresh) Validate() error {
	return dara.Validate(s)
}

type iDescribeDataFlowsResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeDataFlowsResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeDataFlowsResponse
	GetStatusCode() *int32
	SetBody(v *DescribeDataFlowsResponseBody) *DescribeDataFlowsResponse
	GetBody() *DescribeDataFlowsResponseBody
}

type DescribeDataFlowsResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDataFlowsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDataFlowsResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeDataFlowsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDataFlowsResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeDataFlowsResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeDataFlowsResponse) GetBody() *DescribeDataFlowsResponseBody {
	return s.Body
}

func (s *DescribeDataFlowsResponse) SetHeaders(v map[string]*string) *DescribeDataFlowsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDataFlowsResponse) SetStatusCode(v int32) *DescribeDataFlowsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDataFlowsResponse) SetBody(v *DescribeDataFlowsResponseBody) *DescribeDataFlowsResponse {
	s.Body = v
	return s
}

func (s *DescribeDataFlowsResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeDirQuotasRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *DescribeDirQuotasRequest
	GetFileSystemId() *string
	SetPageNumber(v int32) *DescribeDirQuotasRequest
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeDirQuotasRequest
	GetPageSize() *int32
	SetPath(v string) *DescribeDirQuotasRequest
	GetPath() *string
}

type DescribeDirQuotasRequest struct {
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1ca404****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The page number.
	//
	// Pages start from page 1. Default value: 1.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Default value: 10.
	//
	// Valid values: 1 to 100.
	//
	// example:
	//
	// 1
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The absolute path of a directory.
	//
	// If you do not specify this parameter, all directories for which quotas are created are returned.
	//
	// example:
	//
	// /data/sub1
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s DescribeDirQuotasRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeDirQuotasRequest) GoString() string {
	return s.String()
}

func (s *DescribeDirQuotasRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeDirQuotasRequest) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeDirQuotasRequest) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeDirQuotasRequest) GetPath() *string {
	return s.Path
}

func (s *DescribeDirQuotasRequest) SetFileSystemId(v string) *DescribeDirQuotasRequest {
	s.FileSystemId = &v
	return s
}

func (s *DescribeDirQuotasRequest) SetPageNumber(v int32) *DescribeDirQuotasRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDirQuotasRequest) SetPageSize(v int32) *DescribeDirQuotasRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDirQuotasRequest) SetPath(v string) *DescribeDirQuotasRequest {
	s.Path = &v
	return s
}

func (s *DescribeDirQuotasRequest) Validate() error {
	return dara.Validate(s)
}

type iDescribeDirQuotasResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetDirQuotaInfos(v []*DescribeDirQuotasResponseBodyDirQuotaInfos) *DescribeDirQuotasResponseBody
	GetDirQuotaInfos() []*DescribeDirQuotasResponseBodyDirQuotaInfos
	SetPageNumber(v int32) *DescribeDirQuotasResponseBody
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeDirQuotasResponseBody
	GetPageSize() *int32
	SetRequestId(v string) *DescribeDirQuotasResponseBody
	GetRequestId() *string
	SetTotalCount(v int32) *DescribeDirQuotasResponseBody
	GetTotalCount() *int32
}

type DescribeDirQuotasResponseBody struct {
	// The queried directory quotas.
	DirQuotaInfos []*DescribeDirQuotasResponseBodyDirQuotaInfos `json:"DirQuotaInfos,omitempty" xml:"DirQuotaInfos,omitempty" type:"Repeated"`
	// The page number.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	//
	// example:
	//
	// 1
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 5BC5CB97-9F28-42FE-84A4-0CD0DF42****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of directories.
	//
	// example:
	//
	// 1
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDirQuotasResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeDirQuotasResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDirQuotasResponseBody) GetDirQuotaInfos() []*DescribeDirQuotasResponseBodyDirQuotaInfos {
	return s.DirQuotaInfos
}

func (s *DescribeDirQuotasResponseBody) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeDirQuotasResponseBody) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeDirQuotasResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeDirQuotasResponseBody) GetTotalCount() *int32 {
	return s.TotalCount
}

func (s *DescribeDirQuotasResponseBody) SetDirQuotaInfos(v []*DescribeDirQuotasResponseBodyDirQuotaInfos) *DescribeDirQuotasResponseBody {
	s.DirQuotaInfos = v
	return s
}

func (s *DescribeDirQuotasResponseBody) SetPageNumber(v int32) *DescribeDirQuotasResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeDirQuotasResponseBody) SetPageSize(v int32) *DescribeDirQuotasResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeDirQuotasResponseBody) SetRequestId(v string) *DescribeDirQuotasResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDirQuotasResponseBody) SetTotalCount(v int32) *DescribeDirQuotasResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeDirQuotasResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeDirQuotasResponseBodyDirQuotaInfos struct {
	// The inode number of the directory.
	//
	// example:
	//
	// 1123
	DirInode *string `json:"DirInode,omitempty" xml:"DirInode,omitempty"`
	// The absolute path of a directory.
	//
	// example:
	//
	// /data/sub1
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The status of the quota created for the directory. Valid values: Initializing and Normal. The Initializing state indicates that the quota is being created. The Normal state indicates that the quota is created.
	//
	// example:
	//
	// Normal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The information about quotas for all users.
	UserQuotaInfos []*DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos `json:"UserQuotaInfos,omitempty" xml:"UserQuotaInfos,omitempty" type:"Repeated"`
}

func (s DescribeDirQuotasResponseBodyDirQuotaInfos) String() string {
	return dara.Prettify(s)
}

func (s DescribeDirQuotasResponseBodyDirQuotaInfos) GoString() string {
	return s.String()
}

func (s *DescribeDirQuotasResponseBodyDirQuotaInfos) GetDirInode() *string {
	return s.DirInode
}

func (s *DescribeDirQuotasResponseBodyDirQuotaInfos) GetPath() *string {
	return s.Path
}

func (s *DescribeDirQuotasResponseBodyDirQuotaInfos) GetStatus() *string {
	return s.Status
}

func (s *DescribeDirQuotasResponseBodyDirQuotaInfos) GetUserQuotaInfos() []*DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos {
	return s.UserQuotaInfos
}

func (s *DescribeDirQuotasResponseBodyDirQuotaInfos) SetDirInode(v string) *DescribeDirQuotasResponseBodyDirQuotaInfos {
	s.DirInode = &v
	return s
}

func (s *DescribeDirQuotasResponseBodyDirQuotaInfos) SetPath(v string) *DescribeDirQuotasResponseBodyDirQuotaInfos {
	s.Path = &v
	return s
}

func (s *DescribeDirQuotasResponseBodyDirQuotaInfos) SetStatus(v string) *DescribeDirQuotasResponseBodyDirQuotaInfos {
	s.Status = &v
	return s
}

func (s *DescribeDirQuotasResponseBodyDirQuotaInfos) SetUserQuotaInfos(v []*DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos) *DescribeDirQuotasResponseBodyDirQuotaInfos {
	s.UserQuotaInfos = v
	return s
}

func (s *DescribeDirQuotasResponseBodyDirQuotaInfos) Validate() error {
	return dara.Validate(s)
}

type DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos struct {
	// The maximum number of files that a user can create in the directory.
	//
	// example:
	//
	// 10000
	FileCountLimit *int64 `json:"FileCountLimit,omitempty" xml:"FileCountLimit,omitempty"`
	// The total number of files that a user has created in the directory.
	//
	// example:
	//
	// 5100
	FileCountReal *int64 `json:"FileCountReal,omitempty" xml:"FileCountReal,omitempty"`
	// The type of the quota. Valid values: Accounting and Enforcement.
	//
	// example:
	//
	// Accounting
	QuotaType *string `json:"QuotaType,omitempty" xml:"QuotaType,omitempty"`
	// The maximum size of files that a user can create in the directory. Unit: GiB.
	//
	// example:
	//
	// 1024
	SizeLimit *int64 `json:"SizeLimit,omitempty" xml:"SizeLimit,omitempty"`
	// The total size of files that a user has created in the directory. Unit: GiB.
	//
	// example:
	//
	// 800
	SizeReal *int64 `json:"SizeReal,omitempty" xml:"SizeReal,omitempty"`
	// The total size of files that a user has created in the directory. Unit: bytes.
	//
	// example:
	//
	// 858995833870
	SizeRealInByte *int64 `json:"SizeRealInByte,omitempty" xml:"SizeRealInByte,omitempty"`
	// The ID of the user that you specify to create a quota for the directory. The value depends on the value of the UserType parameter. Valid values: Uid and Gid.
	//
	// example:
	//
	// 500
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The type of user. Valid values: Uid, Gid, and AllUsers.
	//
	// 	- If Uid or Gid is returned, a value is returned for UserId.
	//
	// 	- If AllUsers is returned, UserId is empty.
	//
	// example:
	//
	// Uid
	UserType *string `json:"UserType,omitempty" xml:"UserType,omitempty"`
}

func (s DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos) String() string {
	return dara.Prettify(s)
}

func (s DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos) GoString() string {
	return s.String()
}

func (s *DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos) GetFileCountLimit() *int64 {
	return s.FileCountLimit
}

func (s *DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos) GetFileCountReal() *int64 {
	return s.FileCountReal
}

func (s *DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos) GetQuotaType() *string {
	return s.QuotaType
}

func (s *DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos) GetSizeLimit() *int64 {
	return s.SizeLimit
}

func (s *DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos) GetSizeReal() *int64 {
	return s.SizeReal
}

func (s *DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos) GetSizeRealInByte() *int64 {
	return s.SizeRealInByte
}

func (s *DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos) GetUserId() *string {
	return s.UserId
}

func (s *DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos) GetUserType() *string {
	return s.UserType
}

func (s *DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos) SetFileCountLimit(v int64) *DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos {
	s.FileCountLimit = &v
	return s
}

func (s *DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos) SetFileCountReal(v int64) *DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos {
	s.FileCountReal = &v
	return s
}

func (s *DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos) SetQuotaType(v string) *DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos {
	s.QuotaType = &v
	return s
}

func (s *DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos) SetSizeLimit(v int64) *DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos {
	s.SizeLimit = &v
	return s
}

func (s *DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos) SetSizeReal(v int64) *DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos {
	s.SizeReal = &v
	return s
}

func (s *DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos) SetSizeRealInByte(v int64) *DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos {
	s.SizeRealInByte = &v
	return s
}

func (s *DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos) SetUserId(v string) *DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos {
	s.UserId = &v
	return s
}

func (s *DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos) SetUserType(v string) *DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos {
	s.UserType = &v
	return s
}

func (s *DescribeDirQuotasResponseBodyDirQuotaInfosUserQuotaInfos) Validate() error {
	return dara.Validate(s)
}

type iDescribeDirQuotasResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeDirQuotasResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeDirQuotasResponse
	GetStatusCode() *int32
	SetBody(v *DescribeDirQuotasResponseBody) *DescribeDirQuotasResponse
	GetBody() *DescribeDirQuotasResponseBody
}

type DescribeDirQuotasResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDirQuotasResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDirQuotasResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeDirQuotasResponse) GoString() string {
	return s.String()
}

func (s *DescribeDirQuotasResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeDirQuotasResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeDirQuotasResponse) GetBody() *DescribeDirQuotasResponseBody {
	return s.Body
}

func (s *DescribeDirQuotasResponse) SetHeaders(v map[string]*string) *DescribeDirQuotasResponse {
	s.Headers = v
	return s
}

func (s *DescribeDirQuotasResponse) SetStatusCode(v int32) *DescribeDirQuotasResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDirQuotasResponse) SetBody(v *DescribeDirQuotasResponseBody) *DescribeDirQuotasResponse {
	s.Body = v
	return s
}

func (s *DescribeDirQuotasResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeFileSystemBriefInfosRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *DescribeFileSystemBriefInfosRequest
	GetFileSystemId() *string
	SetFileSystemType(v string) *DescribeFileSystemBriefInfosRequest
	GetFileSystemType() *string
	SetOrderByField(v string) *DescribeFileSystemBriefInfosRequest
	GetOrderByField() *string
	SetPageNumber(v int32) *DescribeFileSystemBriefInfosRequest
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeFileSystemBriefInfosRequest
	GetPageSize() *int32
	SetSortOrder(v string) *DescribeFileSystemBriefInfosRequest
	GetSortOrder() *string
	SetStorageType(v string) *DescribeFileSystemBriefInfosRequest
	GetStorageType() *string
}

type DescribeFileSystemBriefInfosRequest struct {
	FileSystemId   *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
	OrderByField   *string `json:"OrderByField,omitempty" xml:"OrderByField,omitempty"`
	PageNumber     *int32  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize       *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	SortOrder      *string `json:"SortOrder,omitempty" xml:"SortOrder,omitempty"`
	StorageType    *string `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
}

func (s DescribeFileSystemBriefInfosRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemBriefInfosRequest) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemBriefInfosRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeFileSystemBriefInfosRequest) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *DescribeFileSystemBriefInfosRequest) GetOrderByField() *string {
	return s.OrderByField
}

func (s *DescribeFileSystemBriefInfosRequest) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeFileSystemBriefInfosRequest) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeFileSystemBriefInfosRequest) GetSortOrder() *string {
	return s.SortOrder
}

func (s *DescribeFileSystemBriefInfosRequest) GetStorageType() *string {
	return s.StorageType
}

func (s *DescribeFileSystemBriefInfosRequest) SetFileSystemId(v string) *DescribeFileSystemBriefInfosRequest {
	s.FileSystemId = &v
	return s
}

func (s *DescribeFileSystemBriefInfosRequest) SetFileSystemType(v string) *DescribeFileSystemBriefInfosRequest {
	s.FileSystemType = &v
	return s
}

func (s *DescribeFileSystemBriefInfosRequest) SetOrderByField(v string) *DescribeFileSystemBriefInfosRequest {
	s.OrderByField = &v
	return s
}

func (s *DescribeFileSystemBriefInfosRequest) SetPageNumber(v int32) *DescribeFileSystemBriefInfosRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeFileSystemBriefInfosRequest) SetPageSize(v int32) *DescribeFileSystemBriefInfosRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeFileSystemBriefInfosRequest) SetSortOrder(v string) *DescribeFileSystemBriefInfosRequest {
	s.SortOrder = &v
	return s
}

func (s *DescribeFileSystemBriefInfosRequest) SetStorageType(v string) *DescribeFileSystemBriefInfosRequest {
	s.StorageType = &v
	return s
}

func (s *DescribeFileSystemBriefInfosRequest) Validate() error {
	return dara.Validate(s)
}

type iDescribeFileSystemBriefInfosResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystems(v *DescribeFileSystemBriefInfosResponseBodyFileSystems) *DescribeFileSystemBriefInfosResponseBody
	GetFileSystems() *DescribeFileSystemBriefInfosResponseBodyFileSystems
	SetPageNumber(v int32) *DescribeFileSystemBriefInfosResponseBody
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeFileSystemBriefInfosResponseBody
	GetPageSize() *int32
	SetRequestId(v string) *DescribeFileSystemBriefInfosResponseBody
	GetRequestId() *string
	SetTotalCount(v int32) *DescribeFileSystemBriefInfosResponseBody
	GetTotalCount() *int32
}

type DescribeFileSystemBriefInfosResponseBody struct {
	FileSystems *DescribeFileSystemBriefInfosResponseBodyFileSystems `json:"FileSystems,omitempty" xml:"FileSystems,omitempty" type:"Struct"`
	PageNumber  *int32                                               `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize    *int32                                               `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RequestId   *string                                              `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TotalCount  *int32                                               `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeFileSystemBriefInfosResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemBriefInfosResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemBriefInfosResponseBody) GetFileSystems() *DescribeFileSystemBriefInfosResponseBodyFileSystems {
	return s.FileSystems
}

func (s *DescribeFileSystemBriefInfosResponseBody) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeFileSystemBriefInfosResponseBody) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeFileSystemBriefInfosResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeFileSystemBriefInfosResponseBody) GetTotalCount() *int32 {
	return s.TotalCount
}

func (s *DescribeFileSystemBriefInfosResponseBody) SetFileSystems(v *DescribeFileSystemBriefInfosResponseBodyFileSystems) *DescribeFileSystemBriefInfosResponseBody {
	s.FileSystems = v
	return s
}

func (s *DescribeFileSystemBriefInfosResponseBody) SetPageNumber(v int32) *DescribeFileSystemBriefInfosResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeFileSystemBriefInfosResponseBody) SetPageSize(v int32) *DescribeFileSystemBriefInfosResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeFileSystemBriefInfosResponseBody) SetRequestId(v string) *DescribeFileSystemBriefInfosResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeFileSystemBriefInfosResponseBody) SetTotalCount(v int32) *DescribeFileSystemBriefInfosResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeFileSystemBriefInfosResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeFileSystemBriefInfosResponseBodyFileSystems struct {
	FileSystem []*DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem `json:"FileSystem,omitempty" xml:"FileSystem,omitempty" type:"Repeated"`
}

func (s DescribeFileSystemBriefInfosResponseBodyFileSystems) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemBriefInfosResponseBodyFileSystems) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystems) GetFileSystem() []*DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem {
	return s.FileSystem
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystems) SetFileSystem(v []*DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) *DescribeFileSystemBriefInfosResponseBodyFileSystems {
	s.FileSystem = v
	return s
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystems) Validate() error {
	return dara.Validate(s)
}

type DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem struct {
	AccessPointCount      *int32                                                                          `json:"AccessPointCount,omitempty" xml:"AccessPointCount,omitempty"`
	Capacity              *int64                                                                          `json:"Capacity,omitempty" xml:"Capacity,omitempty"`
	CreateTime            *string                                                                         `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	Description           *string                                                                         `json:"Description,omitempty" xml:"Description,omitempty"`
	EncryptType           *int32                                                                          `json:"EncryptType,omitempty" xml:"EncryptType,omitempty"`
	FileSystemId          *string                                                                         `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	FileSystemType        *string                                                                         `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
	KMSKeyId              *string                                                                         `json:"KMSKeyId,omitempty" xml:"KMSKeyId,omitempty"`
	MeteredIASize         *int64                                                                          `json:"MeteredIASize,omitempty" xml:"MeteredIASize,omitempty"`
	MeteredSize           *int64                                                                          `json:"MeteredSize,omitempty" xml:"MeteredSize,omitempty"`
	MountTargetCountLimit *int64                                                                          `json:"MountTargetCountLimit,omitempty" xml:"MountTargetCountLimit,omitempty"`
	ProtocolType          *string                                                                         `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	RegionId              *string                                                                         `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	SecondaryCapacity     *int64                                                                          `json:"SecondaryCapacity,omitempty" xml:"SecondaryCapacity,omitempty"`
	Status                *string                                                                         `json:"Status,omitempty" xml:"Status,omitempty"`
	StorageType           *string                                                                         `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
	SupportedFeatures     *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystemSupportedFeatures `json:"SupportedFeatures,omitempty" xml:"SupportedFeatures,omitempty" type:"Struct"`
	Version               *string                                                                         `json:"Version,omitempty" xml:"Version,omitempty"`
	ZoneId                *string                                                                         `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) GetAccessPointCount() *int32 {
	return s.AccessPointCount
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) GetCapacity() *int64 {
	return s.Capacity
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) GetCreateTime() *string {
	return s.CreateTime
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) GetDescription() *string {
	return s.Description
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) GetEncryptType() *int32 {
	return s.EncryptType
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) GetKMSKeyId() *string {
	return s.KMSKeyId
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) GetMeteredIASize() *int64 {
	return s.MeteredIASize
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) GetMeteredSize() *int64 {
	return s.MeteredSize
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) GetMountTargetCountLimit() *int64 {
	return s.MountTargetCountLimit
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) GetProtocolType() *string {
	return s.ProtocolType
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) GetRegionId() *string {
	return s.RegionId
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) GetSecondaryCapacity() *int64 {
	return s.SecondaryCapacity
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) GetStatus() *string {
	return s.Status
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) GetStorageType() *string {
	return s.StorageType
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) GetSupportedFeatures() *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystemSupportedFeatures {
	return s.SupportedFeatures
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) GetVersion() *string {
	return s.Version
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) GetZoneId() *string {
	return s.ZoneId
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) SetAccessPointCount(v int32) *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem {
	s.AccessPointCount = &v
	return s
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) SetCapacity(v int64) *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem {
	s.Capacity = &v
	return s
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) SetCreateTime(v string) *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem {
	s.CreateTime = &v
	return s
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) SetDescription(v string) *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem {
	s.Description = &v
	return s
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) SetEncryptType(v int32) *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem {
	s.EncryptType = &v
	return s
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) SetFileSystemId(v string) *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem {
	s.FileSystemId = &v
	return s
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) SetFileSystemType(v string) *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem {
	s.FileSystemType = &v
	return s
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) SetKMSKeyId(v string) *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem {
	s.KMSKeyId = &v
	return s
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) SetMeteredIASize(v int64) *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem {
	s.MeteredIASize = &v
	return s
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) SetMeteredSize(v int64) *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem {
	s.MeteredSize = &v
	return s
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) SetMountTargetCountLimit(v int64) *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem {
	s.MountTargetCountLimit = &v
	return s
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) SetProtocolType(v string) *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem {
	s.ProtocolType = &v
	return s
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) SetRegionId(v string) *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem {
	s.RegionId = &v
	return s
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) SetSecondaryCapacity(v int64) *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem {
	s.SecondaryCapacity = &v
	return s
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) SetStatus(v string) *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem {
	s.Status = &v
	return s
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) SetStorageType(v string) *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem {
	s.StorageType = &v
	return s
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) SetSupportedFeatures(v *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystemSupportedFeatures) *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem {
	s.SupportedFeatures = v
	return s
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) SetVersion(v string) *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem {
	s.Version = &v
	return s
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) SetZoneId(v string) *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem {
	s.ZoneId = &v
	return s
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystem) Validate() error {
	return dara.Validate(s)
}

type DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystemSupportedFeatures struct {
	SupportedFeature []*string `json:"SupportedFeature,omitempty" xml:"SupportedFeature,omitempty" type:"Repeated"`
}

func (s DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystemSupportedFeatures) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystemSupportedFeatures) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystemSupportedFeatures) GetSupportedFeature() []*string {
	return s.SupportedFeature
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystemSupportedFeatures) SetSupportedFeature(v []*string) *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystemSupportedFeatures {
	s.SupportedFeature = v
	return s
}

func (s *DescribeFileSystemBriefInfosResponseBodyFileSystemsFileSystemSupportedFeatures) Validate() error {
	return dara.Validate(s)
}

type iDescribeFileSystemBriefInfosResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeFileSystemBriefInfosResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeFileSystemBriefInfosResponse
	GetStatusCode() *int32
	SetBody(v *DescribeFileSystemBriefInfosResponseBody) *DescribeFileSystemBriefInfosResponse
	GetBody() *DescribeFileSystemBriefInfosResponseBody
}

type DescribeFileSystemBriefInfosResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeFileSystemBriefInfosResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeFileSystemBriefInfosResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemBriefInfosResponse) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemBriefInfosResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeFileSystemBriefInfosResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeFileSystemBriefInfosResponse) GetBody() *DescribeFileSystemBriefInfosResponseBody {
	return s.Body
}

func (s *DescribeFileSystemBriefInfosResponse) SetHeaders(v map[string]*string) *DescribeFileSystemBriefInfosResponse {
	s.Headers = v
	return s
}

func (s *DescribeFileSystemBriefInfosResponse) SetStatusCode(v int32) *DescribeFileSystemBriefInfosResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeFileSystemBriefInfosResponse) SetBody(v *DescribeFileSystemBriefInfosResponseBody) *DescribeFileSystemBriefInfosResponse {
	s.Body = v
	return s
}

func (s *DescribeFileSystemBriefInfosResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeFileSystemStatisticsRequest interface {
	dara.Model
	String() string
	GoString() string
	SetPageNumber(v int32) *DescribeFileSystemStatisticsRequest
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeFileSystemStatisticsRequest
	GetPageSize() *int32
}

type DescribeFileSystemStatisticsRequest struct {
	// The page number.
	//
	// Pages start from page 1. Default value: 1.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	//
	// Valid values: 1 to 100.
	//
	// Default value: 10.
	//
	// example:
	//
	// 10
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribeFileSystemStatisticsRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemStatisticsRequest) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemStatisticsRequest) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeFileSystemStatisticsRequest) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeFileSystemStatisticsRequest) SetPageNumber(v int32) *DescribeFileSystemStatisticsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeFileSystemStatisticsRequest) SetPageSize(v int32) *DescribeFileSystemStatisticsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeFileSystemStatisticsRequest) Validate() error {
	return dara.Validate(s)
}

type iDescribeFileSystemStatisticsResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemStatistics(v *DescribeFileSystemStatisticsResponseBodyFileSystemStatistics) *DescribeFileSystemStatisticsResponseBody
	GetFileSystemStatistics() *DescribeFileSystemStatisticsResponseBodyFileSystemStatistics
	SetFileSystems(v *DescribeFileSystemStatisticsResponseBodyFileSystems) *DescribeFileSystemStatisticsResponseBody
	GetFileSystems() *DescribeFileSystemStatisticsResponseBodyFileSystems
	SetPageNumber(v int32) *DescribeFileSystemStatisticsResponseBody
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeFileSystemStatisticsResponseBody
	GetPageSize() *int32
	SetRequestId(v string) *DescribeFileSystemStatisticsResponseBody
	GetRequestId() *string
	SetTotalCount(v int32) *DescribeFileSystemStatisticsResponseBody
	GetTotalCount() *int32
}

type DescribeFileSystemStatisticsResponseBody struct {
	// The statistics of file systems.
	FileSystemStatistics *DescribeFileSystemStatisticsResponseBodyFileSystemStatistics `json:"FileSystemStatistics,omitempty" xml:"FileSystemStatistics,omitempty" type:"Struct"`
	// The queried file systems.
	FileSystems *DescribeFileSystemStatisticsResponseBodyFileSystems `json:"FileSystems,omitempty" xml:"FileSystems,omitempty" type:"Struct"`
	// The page number.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	//
	// example:
	//
	// 1
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 9F088138-FD73-4B68-95CC-DFAD4D85****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of file system entries.
	//
	// example:
	//
	// 100
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeFileSystemStatisticsResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemStatisticsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemStatisticsResponseBody) GetFileSystemStatistics() *DescribeFileSystemStatisticsResponseBodyFileSystemStatistics {
	return s.FileSystemStatistics
}

func (s *DescribeFileSystemStatisticsResponseBody) GetFileSystems() *DescribeFileSystemStatisticsResponseBodyFileSystems {
	return s.FileSystems
}

func (s *DescribeFileSystemStatisticsResponseBody) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeFileSystemStatisticsResponseBody) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeFileSystemStatisticsResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeFileSystemStatisticsResponseBody) GetTotalCount() *int32 {
	return s.TotalCount
}

func (s *DescribeFileSystemStatisticsResponseBody) SetFileSystemStatistics(v *DescribeFileSystemStatisticsResponseBodyFileSystemStatistics) *DescribeFileSystemStatisticsResponseBody {
	s.FileSystemStatistics = v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBody) SetFileSystems(v *DescribeFileSystemStatisticsResponseBodyFileSystems) *DescribeFileSystemStatisticsResponseBody {
	s.FileSystems = v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBody) SetPageNumber(v int32) *DescribeFileSystemStatisticsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBody) SetPageSize(v int32) *DescribeFileSystemStatisticsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBody) SetRequestId(v string) *DescribeFileSystemStatisticsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBody) SetTotalCount(v int32) *DescribeFileSystemStatisticsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeFileSystemStatisticsResponseBodyFileSystemStatistics struct {
	FileSystemStatistic []*DescribeFileSystemStatisticsResponseBodyFileSystemStatisticsFileSystemStatistic `json:"FileSystemStatistic,omitempty" xml:"FileSystemStatistic,omitempty" type:"Repeated"`
}

func (s DescribeFileSystemStatisticsResponseBodyFileSystemStatistics) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemStatisticsResponseBodyFileSystemStatistics) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemStatistics) GetFileSystemStatistic() []*DescribeFileSystemStatisticsResponseBodyFileSystemStatisticsFileSystemStatistic {
	return s.FileSystemStatistic
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemStatistics) SetFileSystemStatistic(v []*DescribeFileSystemStatisticsResponseBodyFileSystemStatisticsFileSystemStatistic) *DescribeFileSystemStatisticsResponseBodyFileSystemStatistics {
	s.FileSystemStatistic = v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemStatistics) Validate() error {
	return dara.Validate(s)
}

type DescribeFileSystemStatisticsResponseBodyFileSystemStatisticsFileSystemStatistic struct {
	// The number of expired file systems.
	//
	// example:
	//
	// 1
	ExpiredCount *int32 `json:"ExpiredCount,omitempty" xml:"ExpiredCount,omitempty"`
	// The number of expiring file systems.
	//
	// File systems whose expiration time is less than or equal to seven days away from the current time are counted.
	//
	// example:
	//
	// 1
	ExpiringCount *int32 `json:"ExpiringCount,omitempty" xml:"ExpiringCount,omitempty"`
	// The type of the file system.
	//
	// example:
	//
	// standard
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
	// The storage usage of the file system.
	//
	// The value of this parameter is the maximum storage usage of the file system over the last hour.
	//
	// Unit: bytes.
	//
	// example:
	//
	// 1611
	MeteredSize *int64 `json:"MeteredSize,omitempty" xml:"MeteredSize,omitempty"`
	// The number of file systems of the current type.
	//
	// example:
	//
	// 10
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeFileSystemStatisticsResponseBodyFileSystemStatisticsFileSystemStatistic) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemStatisticsResponseBodyFileSystemStatisticsFileSystemStatistic) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemStatisticsFileSystemStatistic) GetExpiredCount() *int32 {
	return s.ExpiredCount
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemStatisticsFileSystemStatistic) GetExpiringCount() *int32 {
	return s.ExpiringCount
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemStatisticsFileSystemStatistic) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemStatisticsFileSystemStatistic) GetMeteredSize() *int64 {
	return s.MeteredSize
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemStatisticsFileSystemStatistic) GetTotalCount() *int32 {
	return s.TotalCount
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemStatisticsFileSystemStatistic) SetExpiredCount(v int32) *DescribeFileSystemStatisticsResponseBodyFileSystemStatisticsFileSystemStatistic {
	s.ExpiredCount = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemStatisticsFileSystemStatistic) SetExpiringCount(v int32) *DescribeFileSystemStatisticsResponseBodyFileSystemStatisticsFileSystemStatistic {
	s.ExpiringCount = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemStatisticsFileSystemStatistic) SetFileSystemType(v string) *DescribeFileSystemStatisticsResponseBodyFileSystemStatisticsFileSystemStatistic {
	s.FileSystemType = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemStatisticsFileSystemStatistic) SetMeteredSize(v int64) *DescribeFileSystemStatisticsResponseBodyFileSystemStatisticsFileSystemStatistic {
	s.MeteredSize = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemStatisticsFileSystemStatistic) SetTotalCount(v int32) *DescribeFileSystemStatisticsResponseBodyFileSystemStatisticsFileSystemStatistic {
	s.TotalCount = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemStatisticsFileSystemStatistic) Validate() error {
	return dara.Validate(s)
}

type DescribeFileSystemStatisticsResponseBodyFileSystems struct {
	FileSystem []*DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem `json:"FileSystem,omitempty" xml:"FileSystem,omitempty" type:"Repeated"`
}

func (s DescribeFileSystemStatisticsResponseBodyFileSystems) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemStatisticsResponseBodyFileSystems) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystems) GetFileSystem() []*DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem {
	return s.FileSystem
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystems) SetFileSystem(v []*DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) *DescribeFileSystemStatisticsResponseBodyFileSystems {
	s.FileSystem = v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystems) Validate() error {
	return dara.Validate(s)
}

type DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem struct {
	// The capacity of the file system.
	//
	// Unit: GiB.
	//
	// example:
	//
	// 1
	Capacity *int64 `json:"Capacity,omitempty" xml:"Capacity,omitempty"`
	// The billing method.
	//
	// Valid values:
	//
	// 	- Subscription: The subscription billing method is used.
	//
	// 	- PayAsYouGo: The pay-as-you-go billing method is used.
	//
	// 	- Package: A storage plan is attached to the file system.
	//
	// example:
	//
	// PayAsYouGo
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The time when the NAS file system was created.
	//
	// example:
	//
	// 2017-05-27T15:43:06CST
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The description of the file system.
	//
	// example:
	//
	// 31a8e48eda
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The time when the file system expires.
	//
	// example:
	//
	// 2017-08-27T15:43:06CST
	ExpiredTime *string `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// The ID of the file system.
	//
	// example:
	//
	// 109c04****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The type of the file system.
	//
	// Valid values:
	//
	// 	- standard: General-purpose NAS file system
	//
	// 	- extreme: Extreme NAS file system
	//
	// 	- cpfs: CPFS file system
	//
	// example:
	//
	// standard
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
	// The storage usage of the Infrequent Access (IA) storage medium.
	//
	// Unit: bytes.
	//
	// example:
	//
	// 362832
	MeteredIASize *int64 `json:"MeteredIASize,omitempty" xml:"MeteredIASize,omitempty"`
	// The storage usage of the file system.
	//
	// The value of this parameter is the maximum storage usage of the file system over the last hour. Unit: bytes.
	//
	// example:
	//
	// 1611661312
	MeteredSize *int64 `json:"MeteredSize,omitempty" xml:"MeteredSize,omitempty"`
	// The information about storage plans.
	Packages *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackages `json:"Packages,omitempty" xml:"Packages,omitempty" type:"Struct"`
	// The protocol type of the file system.
	//
	// Valid values:
	//
	// 	- NFS: Network File System (NFS)
	//
	// 	- SMB: Server Message Block (SMB)
	//
	// 	- cpfs: the protocol type supported by the CPFS file system
	//
	// example:
	//
	// NFS
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The region ID.
	//
	// example:
	//
	// cn-hangzhou
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The status of the file system.
	//
	// This parameter is returned for Extreme NAS file systems and Cloud Parallel File Storage (CPFS) file systems. Valid values:
	//
	// 	- Pending: The file system is being created or modified.
	//
	// 	- Running: The file system is available. Before you create a mount target for the file system, make sure that the file system is in the Running state.
	//
	// 	- Stopped: The file system is unavailable.
	//
	// 	- Extending: The file system is being scaled out.
	//
	// 	- Stopping: The file system is being disabled.
	//
	// 	- Deleting: The file system is being deleted.
	//
	// example:
	//
	// Pending
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The storage type.
	//
	// Valid values:
	//
	// 	- Valid values for General-purpose NAS file systems: Capacity and Performance.
	//
	// 	- Valid values for Extreme NAS file systems: standard and advance.
	//
	// 	- Valid values for CPFS file systems: advance_100 (100 MB/s/TiB baseline) and advance_200 (200 MB/s/TiB baseline).
	//
	// example:
	//
	// Performance
	StorageType *string `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
	// The zone ID.
	//
	// example:
	//
	// cn-hangzhou-b
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) GetCapacity() *int64 {
	return s.Capacity
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) GetChargeType() *string {
	return s.ChargeType
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) GetCreateTime() *string {
	return s.CreateTime
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) GetDescription() *string {
	return s.Description
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) GetExpiredTime() *string {
	return s.ExpiredTime
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) GetMeteredIASize() *int64 {
	return s.MeteredIASize
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) GetMeteredSize() *int64 {
	return s.MeteredSize
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) GetPackages() *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackages {
	return s.Packages
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) GetProtocolType() *string {
	return s.ProtocolType
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) GetRegionId() *string {
	return s.RegionId
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) GetStatus() *string {
	return s.Status
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) GetStorageType() *string {
	return s.StorageType
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) GetZoneId() *string {
	return s.ZoneId
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) SetCapacity(v int64) *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem {
	s.Capacity = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) SetChargeType(v string) *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem {
	s.ChargeType = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) SetCreateTime(v string) *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem {
	s.CreateTime = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) SetDescription(v string) *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem {
	s.Description = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) SetExpiredTime(v string) *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem {
	s.ExpiredTime = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) SetFileSystemId(v string) *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem {
	s.FileSystemId = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) SetFileSystemType(v string) *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem {
	s.FileSystemType = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) SetMeteredIASize(v int64) *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem {
	s.MeteredIASize = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) SetMeteredSize(v int64) *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem {
	s.MeteredSize = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) SetPackages(v *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackages) *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem {
	s.Packages = v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) SetProtocolType(v string) *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem {
	s.ProtocolType = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) SetRegionId(v string) *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem {
	s.RegionId = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) SetStatus(v string) *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem {
	s.Status = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) SetStorageType(v string) *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem {
	s.StorageType = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) SetZoneId(v string) *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem {
	s.ZoneId = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystem) Validate() error {
	return dara.Validate(s)
}

type DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackages struct {
	Package []*DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackagesPackage `json:"Package,omitempty" xml:"Package,omitempty" type:"Repeated"`
}

func (s DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackages) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackages) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackages) GetPackage() []*DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackagesPackage {
	return s.Package
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackages) SetPackage(v []*DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackagesPackage) *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackages {
	s.Package = v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackages) Validate() error {
	return dara.Validate(s)
}

type DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackagesPackage struct {
	// The end time of the validity period for the storage plan.
	//
	// example:
	//
	// 2020-01-05T16:00:00Z
	ExpiredTime *string `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// The ID of the storage plan.
	//
	// example:
	//
	// naspackage-0be9c4b624-37****
	PackageId *string `json:"PackageId,omitempty" xml:"PackageId,omitempty"`
	// The capacity of the storage plan.
	//
	// example:
	//
	// 107374182400
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The start time of the validity period for the storage plan.
	//
	// example:
	//
	// 2019-12-05T01:40:56Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackagesPackage) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackagesPackage) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackagesPackage) GetExpiredTime() *string {
	return s.ExpiredTime
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackagesPackage) GetPackageId() *string {
	return s.PackageId
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackagesPackage) GetSize() *int64 {
	return s.Size
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackagesPackage) GetStartTime() *string {
	return s.StartTime
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackagesPackage) SetExpiredTime(v string) *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackagesPackage {
	s.ExpiredTime = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackagesPackage) SetPackageId(v string) *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackagesPackage {
	s.PackageId = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackagesPackage) SetSize(v int64) *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackagesPackage {
	s.Size = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackagesPackage) SetStartTime(v string) *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackagesPackage {
	s.StartTime = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponseBodyFileSystemsFileSystemPackagesPackage) Validate() error {
	return dara.Validate(s)
}

type iDescribeFileSystemStatisticsResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeFileSystemStatisticsResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeFileSystemStatisticsResponse
	GetStatusCode() *int32
	SetBody(v *DescribeFileSystemStatisticsResponseBody) *DescribeFileSystemStatisticsResponse
	GetBody() *DescribeFileSystemStatisticsResponseBody
}

type DescribeFileSystemStatisticsResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeFileSystemStatisticsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeFileSystemStatisticsResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemStatisticsResponse) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemStatisticsResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeFileSystemStatisticsResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeFileSystemStatisticsResponse) GetBody() *DescribeFileSystemStatisticsResponseBody {
	return s.Body
}

func (s *DescribeFileSystemStatisticsResponse) SetHeaders(v map[string]*string) *DescribeFileSystemStatisticsResponse {
	s.Headers = v
	return s
}

func (s *DescribeFileSystemStatisticsResponse) SetStatusCode(v int32) *DescribeFileSystemStatisticsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeFileSystemStatisticsResponse) SetBody(v *DescribeFileSystemStatisticsResponseBody) *DescribeFileSystemStatisticsResponse {
	s.Body = v
	return s
}

func (s *DescribeFileSystemStatisticsResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeFileSystemsRequest interface {
	dara.Model
	String() string
	GoString() string
	SetChargeType(v string) *DescribeFileSystemsRequest
	GetChargeType() *string
	SetDescription(v string) *DescribeFileSystemsRequest
	GetDescription() *string
	SetFileSystemId(v string) *DescribeFileSystemsRequest
	GetFileSystemId() *string
	SetFileSystemIds(v string) *DescribeFileSystemsRequest
	GetFileSystemIds() *string
	SetFileSystemType(v string) *DescribeFileSystemsRequest
	GetFileSystemType() *string
	SetOrderByField(v string) *DescribeFileSystemsRequest
	GetOrderByField() *string
	SetPackageIds(v string) *DescribeFileSystemsRequest
	GetPackageIds() *string
	SetPageNumber(v int32) *DescribeFileSystemsRequest
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeFileSystemsRequest
	GetPageSize() *int32
	SetResourceGroupId(v string) *DescribeFileSystemsRequest
	GetResourceGroupId() *string
	SetSortOrder(v string) *DescribeFileSystemsRequest
	GetSortOrder() *string
	SetStorageType(v string) *DescribeFileSystemsRequest
	GetStorageType() *string
	SetTag(v []*DescribeFileSystemsRequestTag) *DescribeFileSystemsRequest
	GetTag() []*DescribeFileSystemsRequestTag
	SetUseUTCDateTime(v bool) *DescribeFileSystemsRequest
	GetUseUTCDateTime() *bool
	SetVpcId(v string) *DescribeFileSystemsRequest
	GetVpcId() *string
}

type DescribeFileSystemsRequest struct {
	ChargeType  *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the file system.
	//
	// - Sample ID of a General-purpose NAS file system: 31a8e4****.
	//
	// - The IDs of Extreme NAS file systems must start with extreme-, for example, extreme-0015****.
	//
	// - The IDs of Cloud Parallel File Storage (CPFS) file systems must start with cpfs-, for example, cpfs-125487****.
	//
	// > CPFS file systems are available only on the China site (aliyun.com).
	//
	// example:
	//
	// 31a8e4****
	FileSystemId  *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	FileSystemIds *string `json:"FileSystemIds,omitempty" xml:"FileSystemIds,omitempty"`
	// The type of the file system.
	//
	// Valid values:
	//
	// - all (default): all types
	//
	// - standard: General-purpose NAS file system
	//
	// - extreme: Extreme NAS file system
	//
	// - cpfs: CPFS file system
	//
	// > CPFS file systems are available only on the China site (aliyun.com).
	//
	// example:
	//
	// standard
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
	OrderByField   *string `json:"OrderByField,omitempty" xml:"OrderByField,omitempty"`
	PackageIds     *string `json:"PackageIds,omitempty" xml:"PackageIds,omitempty"`
	// The page number.
	//
	// Pages start from page 1. Default value: 1.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	//
	// Valid values: 1 to 100.
	//
	// Default value: 10.
	//
	// example:
	//
	// 10
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The resource group ID.
	//
	// You can log on to the [Resource Management console](https://resourcemanager.console.aliyun.com/resource-groups?) to view resource group IDs.
	//
	// example:
	//
	// rg-acfmwavnfdf****
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	SortOrder       *string `json:"SortOrder,omitempty" xml:"SortOrder,omitempty"`
	StorageType     *string `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
	// The details about the tags.
	Tag            []*DescribeFileSystemsRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	UseUTCDateTime *bool                            `json:"UseUTCDateTime,omitempty" xml:"UseUTCDateTime,omitempty"`
	// The ID of the virtual private cloud (VPC).
	//
	// If you want to mount the file system on an Elastic Compute Service (ECS) instance, the file system and the ECS instance must reside in the same VPC.
	//
	// example:
	//
	// vpc-bp1sevsgtqvk5gxbl****
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeFileSystemsRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemsRequest) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemsRequest) GetChargeType() *string {
	return s.ChargeType
}

func (s *DescribeFileSystemsRequest) GetDescription() *string {
	return s.Description
}

func (s *DescribeFileSystemsRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeFileSystemsRequest) GetFileSystemIds() *string {
	return s.FileSystemIds
}

func (s *DescribeFileSystemsRequest) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *DescribeFileSystemsRequest) GetOrderByField() *string {
	return s.OrderByField
}

func (s *DescribeFileSystemsRequest) GetPackageIds() *string {
	return s.PackageIds
}

func (s *DescribeFileSystemsRequest) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeFileSystemsRequest) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeFileSystemsRequest) GetResourceGroupId() *string {
	return s.ResourceGroupId
}

func (s *DescribeFileSystemsRequest) GetSortOrder() *string {
	return s.SortOrder
}

func (s *DescribeFileSystemsRequest) GetStorageType() *string {
	return s.StorageType
}

func (s *DescribeFileSystemsRequest) GetTag() []*DescribeFileSystemsRequestTag {
	return s.Tag
}

func (s *DescribeFileSystemsRequest) GetUseUTCDateTime() *bool {
	return s.UseUTCDateTime
}

func (s *DescribeFileSystemsRequest) GetVpcId() *string {
	return s.VpcId
}

func (s *DescribeFileSystemsRequest) SetChargeType(v string) *DescribeFileSystemsRequest {
	s.ChargeType = &v
	return s
}

func (s *DescribeFileSystemsRequest) SetDescription(v string) *DescribeFileSystemsRequest {
	s.Description = &v
	return s
}

func (s *DescribeFileSystemsRequest) SetFileSystemId(v string) *DescribeFileSystemsRequest {
	s.FileSystemId = &v
	return s
}

func (s *DescribeFileSystemsRequest) SetFileSystemIds(v string) *DescribeFileSystemsRequest {
	s.FileSystemIds = &v
	return s
}

func (s *DescribeFileSystemsRequest) SetFileSystemType(v string) *DescribeFileSystemsRequest {
	s.FileSystemType = &v
	return s
}

func (s *DescribeFileSystemsRequest) SetOrderByField(v string) *DescribeFileSystemsRequest {
	s.OrderByField = &v
	return s
}

func (s *DescribeFileSystemsRequest) SetPackageIds(v string) *DescribeFileSystemsRequest {
	s.PackageIds = &v
	return s
}

func (s *DescribeFileSystemsRequest) SetPageNumber(v int32) *DescribeFileSystemsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeFileSystemsRequest) SetPageSize(v int32) *DescribeFileSystemsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeFileSystemsRequest) SetResourceGroupId(v string) *DescribeFileSystemsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeFileSystemsRequest) SetSortOrder(v string) *DescribeFileSystemsRequest {
	s.SortOrder = &v
	return s
}

func (s *DescribeFileSystemsRequest) SetStorageType(v string) *DescribeFileSystemsRequest {
	s.StorageType = &v
	return s
}

func (s *DescribeFileSystemsRequest) SetTag(v []*DescribeFileSystemsRequestTag) *DescribeFileSystemsRequest {
	s.Tag = v
	return s
}

func (s *DescribeFileSystemsRequest) SetUseUTCDateTime(v bool) *DescribeFileSystemsRequest {
	s.UseUTCDateTime = &v
	return s
}

func (s *DescribeFileSystemsRequest) SetVpcId(v string) *DescribeFileSystemsRequest {
	s.VpcId = &v
	return s
}

func (s *DescribeFileSystemsRequest) Validate() error {
	return dara.Validate(s)
}

type DescribeFileSystemsRequestTag struct {
	// The key of tag N to add to the resource.
	//
	// Limits:
	//
	// - Valid values of N: 1 to 20.
	//
	// - The tag key must be 1 to 128 characters in length.
	//
	// - The tag key cannot start with aliyun or acs:.
	//
	// - The tag key cannot contain http:// or https://.
	//
	// example:
	//
	// test
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of tag N to add to the resource.
	//
	// Limits:
	//
	// - Valid values of N: 1 to 20.
	//
	// - The tag value must be 1 to 128 characters in length.
	//
	// - The tag value cannot start with aliyun or acs:.
	//
	// - The tag value cannot contain http:// or https://.
	//
	// example:
	//
	// test-value
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeFileSystemsRequestTag) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemsRequestTag) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemsRequestTag) GetKey() *string {
	return s.Key
}

func (s *DescribeFileSystemsRequestTag) GetValue() *string {
	return s.Value
}

func (s *DescribeFileSystemsRequestTag) SetKey(v string) *DescribeFileSystemsRequestTag {
	s.Key = &v
	return s
}

func (s *DescribeFileSystemsRequestTag) SetValue(v string) *DescribeFileSystemsRequestTag {
	s.Value = &v
	return s
}

func (s *DescribeFileSystemsRequestTag) Validate() error {
	return dara.Validate(s)
}

type iDescribeFileSystemsResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystems(v *DescribeFileSystemsResponseBodyFileSystems) *DescribeFileSystemsResponseBody
	GetFileSystems() *DescribeFileSystemsResponseBodyFileSystems
	SetPageNumber(v int32) *DescribeFileSystemsResponseBody
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeFileSystemsResponseBody
	GetPageSize() *int32
	SetRequestId(v string) *DescribeFileSystemsResponseBody
	GetRequestId() *string
	SetTotalCount(v int32) *DescribeFileSystemsResponseBody
	GetTotalCount() *int32
}

type DescribeFileSystemsResponseBody struct {
	// The queried file systems.
	FileSystems *DescribeFileSystemsResponseBodyFileSystems `json:"FileSystems,omitempty" xml:"FileSystems,omitempty" type:"Struct"`
	// The page number.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	//
	// example:
	//
	// 1
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 035B3A3A-E514-4B41-B906-5D906CFB****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of file systems.
	//
	// example:
	//
	// 1
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeFileSystemsResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemsResponseBody) GetFileSystems() *DescribeFileSystemsResponseBodyFileSystems {
	return s.FileSystems
}

func (s *DescribeFileSystemsResponseBody) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeFileSystemsResponseBody) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeFileSystemsResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeFileSystemsResponseBody) GetTotalCount() *int32 {
	return s.TotalCount
}

func (s *DescribeFileSystemsResponseBody) SetFileSystems(v *DescribeFileSystemsResponseBodyFileSystems) *DescribeFileSystemsResponseBody {
	s.FileSystems = v
	return s
}

func (s *DescribeFileSystemsResponseBody) SetPageNumber(v int32) *DescribeFileSystemsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeFileSystemsResponseBody) SetPageSize(v int32) *DescribeFileSystemsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeFileSystemsResponseBody) SetRequestId(v string) *DescribeFileSystemsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeFileSystemsResponseBody) SetTotalCount(v int32) *DescribeFileSystemsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeFileSystemsResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeFileSystemsResponseBodyFileSystems struct {
	FileSystem []*DescribeFileSystemsResponseBodyFileSystemsFileSystem `json:"FileSystem,omitempty" xml:"FileSystem,omitempty" type:"Repeated"`
}

func (s DescribeFileSystemsResponseBodyFileSystems) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemsResponseBodyFileSystems) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemsResponseBodyFileSystems) GetFileSystem() []*DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	return s.FileSystem
}

func (s *DescribeFileSystemsResponseBodyFileSystems) SetFileSystem(v []*DescribeFileSystemsResponseBodyFileSystemsFileSystem) *DescribeFileSystemsResponseBodyFileSystems {
	s.FileSystem = v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystems) Validate() error {
	return dara.Validate(s)
}

type DescribeFileSystemsResponseBodyFileSystemsFileSystem struct {
	// Number of access points.
	//
	// example:
	//
	// 1
	AccessPointCount *string `json:"AccessPointCount,omitempty" xml:"AccessPointCount,omitempty"`
	// The ID of the automatic snapshot policy.
	//
	// example:
	//
	// sp-extreme-233e6****
	AutoSnapshotPolicyId *string `json:"AutoSnapshotPolicyId,omitempty" xml:"AutoSnapshotPolicyId,omitempty"`
	// The bandwidth of the file system.
	//
	// Unit: MB/s. This parameter is unavailable for General-purpose NAS file systems.
	//
	// example:
	//
	// 150
	Bandwidth *int64 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The capacity of the file system.
	//
	// Unit: GiB.
	//
	// example:
	//
	// 100
	Capacity *int64 `json:"Capacity,omitempty" xml:"Capacity,omitempty"`
	// The billing method.
	//
	// Valid values:
	//
	// - Subscription: The subscription billing method is used.
	//
	// - PayAsYouGo: The pay-as-you-go billing method is used.
	//
	// - Package: A storage plan is attached to the file system.
	//
	// example:
	//
	// PayAsYouGo
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The time when the file system was created.
	//
	// example:
	//
	// 2020-01-05T16:00:00Z
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The description of the file system.
	//
	// example:
	//
	// test
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The encryption type.
	//
	// Valid values:
	//
	// 	- 0: The data in the file system is not encrypted.
	//
	// 	- 1: A NAS-managed key is used to encrypt the data in the file system.
	//
	// 	- 2: A KMS-managed key is used to encrypt the data in the file system.
	//
	// example:
	//
	// 1
	EncryptType *int32 `json:"EncryptType,omitempty" xml:"EncryptType,omitempty"`
	// The time when the file system expires.
	//
	// example:
	//
	// 2020-01-05T16:00:00Z
	ExpiredTime *string `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// The ID of the file system.
	//
	// example:
	//
	// 109c04****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The type of the file system.
	//
	// Valid values:
	//
	// - standard: General-purpose NAS file system
	//
	// - extreme: Extreme NAS file system
	//
	// - cpfs: CPFS file system
	//
	// > CPFS file systems are available only on the China site (aliyun.com).
	//
	// example:
	//
	// standard
	FileSystemType *string                                                      `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
	GuiInfo        *DescribeFileSystemsResponseBodyFileSystemsFileSystemGuiInfo `json:"GuiInfo,omitempty" xml:"GuiInfo,omitempty" type:"Struct"`
	HpnZone        *string                                                      `json:"HpnZone,omitempty" xml:"HpnZone,omitempty"`
	// The ID of the key that is managed by Key Management Service (KMS).
	//
	// example:
	//
	// 0e478b7a-4262-4802-b8cb-00d3fb40****
	KMSKeyId *string `json:"KMSKeyId,omitempty" xml:"KMSKeyId,omitempty"`
	// The Lightweight Directory Access Protocol (LDAP) configurations.
	//
	// This parameter is available only for CPFS file systems.
	Ldap *DescribeFileSystemsResponseBodyFileSystemsFileSystemLdap `json:"Ldap,omitempty" xml:"Ldap,omitempty" type:"Struct"`
	// Archive storage usage.
	//
	// Unit: Byte.
	//
	// example:
	//
	// 1611661312
	MeteredArchiveSize *int64 `json:"MeteredArchiveSize,omitempty" xml:"MeteredArchiveSize,omitempty"`
	// The storage usage of the Infrequent Access (IA) storage medium.
	//
	// Unit: bytes.
	//
	// example:
	//
	// 362832
	MeteredIASize *int64 `json:"MeteredIASize,omitempty" xml:"MeteredIASize,omitempty"`
	// The storage usage of the file system.
	//
	// The value of this parameter is the maximum storage usage of the file system over the last hour. Unit: bytes.
	//
	// example:
	//
	// 1611661312
	MeteredSize           *int64 `json:"MeteredSize,omitempty" xml:"MeteredSize,omitempty"`
	MountTargetCountLimit *int64 `json:"MountTargetCountLimit,omitempty" xml:"MountTargetCountLimit,omitempty"`
	// The information about mount targets.
	MountTargets   *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargets `json:"MountTargets,omitempty" xml:"MountTargets,omitempty" type:"Struct"`
	NasNamespaceId *string                                                           `json:"NasNamespaceId,omitempty" xml:"NasNamespaceId,omitempty"`
	NodeNum        *int32                                                            `json:"NodeNum,omitempty" xml:"NodeNum,omitempty"`
	// The options.
	Options *DescribeFileSystemsResponseBodyFileSystemsFileSystemOptions `json:"Options,omitempty" xml:"Options,omitempty" type:"Struct"`
	// The information about storage plans.
	Packages *DescribeFileSystemsResponseBodyFileSystemsFileSystemPackages `json:"Packages,omitempty" xml:"Packages,omitempty" type:"Struct"`
	// The protocol type of the file system.
	//
	// Valid values:
	//
	// 	- NFS: Network File System (NFS)
	//
	// 	- SMB: Server Message Block (SMB)
	//
	// 	- cpfs: the protocol type supported by the CPFS file system
	//
	// > CPFS file systems are available only on the China site (aliyun.com).
	//
	// example:
	//
	// NFS
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The ID of the vSwitch.
	//
	// example:
	//
	// vsw-2ze37k6jh8ums2fw2****
	QuorumVswId *string `json:"QuorumVswId,omitempty" xml:"QuorumVswId,omitempty"`
	// The region ID.
	//
	// example:
	//
	// cn-hangzhou
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource group ID.
	//
	// You can log on to the [Resource Management console](https://resourcemanager.console.aliyun.com/resource-groups?) to view resource group IDs.
	//
	// example:
	//
	// rg-acfmwavnfdf****
	ResourceGroupId    *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	SecondaryBandwidth *int32  `json:"SecondaryBandwidth,omitempty" xml:"SecondaryBandwidth,omitempty"`
	SecondaryCapacity  *int64  `json:"SecondaryCapacity,omitempty" xml:"SecondaryCapacity,omitempty"`
	// The status of the file system. Valid values:
	//
	// - Pending: The file system is being created or modified.
	//
	// - Running: The file system is available. Before you create a mount target for the file system, make sure that the file system is in the Running state.
	//
	// - Stopped: The file system is unavailable.
	//
	// - Extending: The file system is being scaled up.
	//
	// - Stopping: The file system is being stopped.
	//
	// - Deleting: The file system is being deleted.
	//
	// example:
	//
	// Pending
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The storage type.
	//
	// Valid values:
	//
	// - Valid values for General-purpose NAS file systems: Capacity,Premium and Performance.
	//
	// - Valid values for Extreme NAS file systems: standard and advance.
	//
	// - Valid values for CPFS file systems: advance_100 (100 MB/s/TiB baseline) and advance_200 (200 MB/s/TiB baseline).
	//
	//  > CPFS file systems are available only on the China site (aliyun.com).
	//
	// example:
	//
	// Performance
	StorageType *string `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
	// The features that are supported by the file system.
	SupportedFeatures *DescribeFileSystemsResponseBodyFileSystemsFileSystemSupportedFeatures `json:"SupportedFeatures,omitempty" xml:"SupportedFeatures,omitempty" type:"Struct"`
	// The tags that are attached to the file system.
	Tags *DescribeFileSystemsResponseBodyFileSystemsFileSystemTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The version number of the file system.
	//
	// This parameter is available only for Extreme NAS file systems and CPFS file systems.
	//
	// example:
	//
	// 2.3.4
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
	// The ID of the virtual private cloud (VPC).
	//
	// example:
	//
	// vpc-bp1cbv1ljve4j5hlw****
	VpcId     *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	VscTarget *string `json:"VscTarget,omitempty" xml:"VscTarget,omitempty"`
	// A collection of vSwitch IDs.
	VswIds *DescribeFileSystemsResponseBodyFileSystemsFileSystemVswIds `json:"VswIds,omitempty" xml:"VswIds,omitempty" type:"Struct"`
	// The ID of the zone where the file system resides.
	//
	// example:
	//
	// cn-hangzhou-b
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystem) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystem) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetAccessPointCount() *string {
	return s.AccessPointCount
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetAutoSnapshotPolicyId() *string {
	return s.AutoSnapshotPolicyId
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetBandwidth() *int64 {
	return s.Bandwidth
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetCapacity() *int64 {
	return s.Capacity
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetChargeType() *string {
	return s.ChargeType
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetCreateTime() *string {
	return s.CreateTime
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetDescription() *string {
	return s.Description
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetEncryptType() *int32 {
	return s.EncryptType
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetExpiredTime() *string {
	return s.ExpiredTime
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetGuiInfo() *DescribeFileSystemsResponseBodyFileSystemsFileSystemGuiInfo {
	return s.GuiInfo
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetHpnZone() *string {
	return s.HpnZone
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetKMSKeyId() *string {
	return s.KMSKeyId
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetLdap() *DescribeFileSystemsResponseBodyFileSystemsFileSystemLdap {
	return s.Ldap
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetMeteredArchiveSize() *int64 {
	return s.MeteredArchiveSize
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetMeteredIASize() *int64 {
	return s.MeteredIASize
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetMeteredSize() *int64 {
	return s.MeteredSize
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetMountTargetCountLimit() *int64 {
	return s.MountTargetCountLimit
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetMountTargets() *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargets {
	return s.MountTargets
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetNasNamespaceId() *string {
	return s.NasNamespaceId
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetNodeNum() *int32 {
	return s.NodeNum
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetOptions() *DescribeFileSystemsResponseBodyFileSystemsFileSystemOptions {
	return s.Options
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetPackages() *DescribeFileSystemsResponseBodyFileSystemsFileSystemPackages {
	return s.Packages
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetProtocolType() *string {
	return s.ProtocolType
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetQuorumVswId() *string {
	return s.QuorumVswId
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetRegionId() *string {
	return s.RegionId
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetResourceGroupId() *string {
	return s.ResourceGroupId
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetSecondaryBandwidth() *int32 {
	return s.SecondaryBandwidth
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetSecondaryCapacity() *int64 {
	return s.SecondaryCapacity
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetStatus() *string {
	return s.Status
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetStorageType() *string {
	return s.StorageType
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetSupportedFeatures() *DescribeFileSystemsResponseBodyFileSystemsFileSystemSupportedFeatures {
	return s.SupportedFeatures
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetTags() *DescribeFileSystemsResponseBodyFileSystemsFileSystemTags {
	return s.Tags
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetVersion() *string {
	return s.Version
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetVpcId() *string {
	return s.VpcId
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetVscTarget() *string {
	return s.VscTarget
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetVswIds() *DescribeFileSystemsResponseBodyFileSystemsFileSystemVswIds {
	return s.VswIds
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) GetZoneId() *string {
	return s.ZoneId
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetAccessPointCount(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.AccessPointCount = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetAutoSnapshotPolicyId(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.AutoSnapshotPolicyId = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetBandwidth(v int64) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.Bandwidth = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetCapacity(v int64) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.Capacity = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetChargeType(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.ChargeType = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetCreateTime(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.CreateTime = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetDescription(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.Description = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetEncryptType(v int32) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.EncryptType = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetExpiredTime(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.ExpiredTime = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetFileSystemId(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.FileSystemId = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetFileSystemType(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.FileSystemType = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetGuiInfo(v *DescribeFileSystemsResponseBodyFileSystemsFileSystemGuiInfo) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.GuiInfo = v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetHpnZone(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.HpnZone = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetKMSKeyId(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.KMSKeyId = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetLdap(v *DescribeFileSystemsResponseBodyFileSystemsFileSystemLdap) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.Ldap = v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetMeteredArchiveSize(v int64) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.MeteredArchiveSize = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetMeteredIASize(v int64) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.MeteredIASize = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetMeteredSize(v int64) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.MeteredSize = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetMountTargetCountLimit(v int64) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.MountTargetCountLimit = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetMountTargets(v *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargets) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.MountTargets = v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetNasNamespaceId(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.NasNamespaceId = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetNodeNum(v int32) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.NodeNum = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetOptions(v *DescribeFileSystemsResponseBodyFileSystemsFileSystemOptions) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.Options = v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetPackages(v *DescribeFileSystemsResponseBodyFileSystemsFileSystemPackages) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.Packages = v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetProtocolType(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.ProtocolType = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetQuorumVswId(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.QuorumVswId = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetRegionId(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.RegionId = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetResourceGroupId(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetSecondaryBandwidth(v int32) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.SecondaryBandwidth = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetSecondaryCapacity(v int64) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.SecondaryCapacity = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetStatus(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.Status = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetStorageType(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.StorageType = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetSupportedFeatures(v *DescribeFileSystemsResponseBodyFileSystemsFileSystemSupportedFeatures) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.SupportedFeatures = v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetTags(v *DescribeFileSystemsResponseBodyFileSystemsFileSystemTags) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.Tags = v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetVersion(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.Version = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetVpcId(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.VpcId = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetVscTarget(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.VscTarget = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetVswIds(v *DescribeFileSystemsResponseBodyFileSystemsFileSystemVswIds) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.VswIds = v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) SetZoneId(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystem {
	s.ZoneId = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystem) Validate() error {
	return dara.Validate(s)
}

type DescribeFileSystemsResponseBodyFileSystemsFileSystemGuiInfo struct {
	Endpoint *string `json:"Endpoint,omitempty" xml:"Endpoint,omitempty"`
	Password *string `json:"Password,omitempty" xml:"Password,omitempty"`
	User     *string `json:"User,omitempty" xml:"User,omitempty"`
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemGuiInfo) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemGuiInfo) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemGuiInfo) GetEndpoint() *string {
	return s.Endpoint
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemGuiInfo) GetPassword() *string {
	return s.Password
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemGuiInfo) GetUser() *string {
	return s.User
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemGuiInfo) SetEndpoint(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystemGuiInfo {
	s.Endpoint = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemGuiInfo) SetPassword(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystemGuiInfo {
	s.Password = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemGuiInfo) SetUser(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystemGuiInfo {
	s.User = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemGuiInfo) Validate() error {
	return dara.Validate(s)
}

type DescribeFileSystemsResponseBodyFileSystemsFileSystemLdap struct {
	// An LDAP entry.
	//
	// example:
	//
	// cn=alibaba,dc=com
	BindDN *string `json:"BindDN,omitempty" xml:"BindDN,omitempty"`
	// An LDAP search base.
	//
	// example:
	//
	// dc=example
	SearchBase *string `json:"SearchBase,omitempty" xml:"SearchBase,omitempty"`
	// An LDAP URI.
	//
	// example:
	//
	// ldap://ldap.example.example
	URI *string `json:"URI,omitempty" xml:"URI,omitempty"`
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemLdap) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemLdap) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemLdap) GetBindDN() *string {
	return s.BindDN
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemLdap) GetSearchBase() *string {
	return s.SearchBase
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemLdap) GetURI() *string {
	return s.URI
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemLdap) SetBindDN(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystemLdap {
	s.BindDN = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemLdap) SetSearchBase(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystemLdap {
	s.SearchBase = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemLdap) SetURI(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystemLdap {
	s.URI = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemLdap) Validate() error {
	return dara.Validate(s)
}

type DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargets struct {
	MountTarget []*DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget `json:"MountTarget,omitempty" xml:"MountTarget,omitempty" type:"Repeated"`
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargets) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargets) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargets) GetMountTarget() []*DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget {
	return s.MountTarget
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargets) SetMountTarget(v []*DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget) *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargets {
	s.MountTarget = v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargets) Validate() error {
	return dara.Validate(s)
}

type DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget struct {
	// The name of the permission group that is attached to the mount target.
	//
	// example:
	//
	// test-001
	AccessGroupName *string `json:"AccessGroupName,omitempty" xml:"AccessGroupName,omitempty"`
	// The information about client management nodes.
	//
	// This parameter is available only for CPFS file systems.
	ClientMasterNodes *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetClientMasterNodes `json:"ClientMasterNodes,omitempty" xml:"ClientMasterNodes,omitempty" type:"Struct"`
	// The dual-stack (IPv4 and IPv6) domain name of the mount target.
	//
	// > Only Extreme NAS file systems that reside in the Chinese mainland support IPv6.
	//
	// example:
	//
	// 174494b666-x****.dualstack.cn-hangzhou.nas.aliyuncs.com
	DualStackMountTargetDomain *string `json:"DualStackMountTargetDomain,omitempty" xml:"DualStackMountTargetDomain,omitempty"`
	// The domain name of the mount target.
	//
	// example:
	//
	// 109c042666-w****.cn-hangzhou.nas.aliyuncs.com
	MountTargetDomain *string `json:"MountTargetDomain,omitempty" xml:"MountTargetDomain,omitempty"`
	MountTargetIp     *string `json:"MountTargetIp,omitempty" xml:"MountTargetIp,omitempty"`
	// The network type. Valid value: vpc.
	//
	// example:
	//
	// vpc
	NetworkType *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	// The status of the mount target.
	//
	// Valid values:
	//
	// 	- Active: The mount target is available.
	//
	// 	- Inactive: The mount target is unavailable.
	//
	// 	- Pending: The mount target is being processed.
	//
	// 	- Deleting: The mount target is being deleted.
	//
	// 	- Hibernating: The mount target is being hibernated.
	//
	// 	- Hibernated: The mount target is hibernated.
	//
	// example:
	//
	// Active
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tags that are attached to the mount target.
	Tags *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The ID of the VPC.
	//
	// example:
	//
	// vpc-bp1sevsgtqvk5gxbl****
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The ID of the vSwitch.
	//
	// example:
	//
	// vsw-bp1omfzsszekkvaxn****
	VswId *string `json:"VswId,omitempty" xml:"VswId,omitempty"`
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget) GetAccessGroupName() *string {
	return s.AccessGroupName
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget) GetClientMasterNodes() *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetClientMasterNodes {
	return s.ClientMasterNodes
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget) GetDualStackMountTargetDomain() *string {
	return s.DualStackMountTargetDomain
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget) GetMountTargetDomain() *string {
	return s.MountTargetDomain
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget) GetMountTargetIp() *string {
	return s.MountTargetIp
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget) GetNetworkType() *string {
	return s.NetworkType
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget) GetStatus() *string {
	return s.Status
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget) GetTags() *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetTags {
	return s.Tags
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget) GetVpcId() *string {
	return s.VpcId
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget) GetVswId() *string {
	return s.VswId
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget) SetAccessGroupName(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget {
	s.AccessGroupName = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget) SetClientMasterNodes(v *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetClientMasterNodes) *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget {
	s.ClientMasterNodes = v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget) SetDualStackMountTargetDomain(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget {
	s.DualStackMountTargetDomain = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget) SetMountTargetDomain(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget {
	s.MountTargetDomain = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget) SetMountTargetIp(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget {
	s.MountTargetIp = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget) SetNetworkType(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget {
	s.NetworkType = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget) SetStatus(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget {
	s.Status = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget) SetTags(v *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetTags) *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget {
	s.Tags = v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget) SetVpcId(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget {
	s.VpcId = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget) SetVswId(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget {
	s.VswId = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTarget) Validate() error {
	return dara.Validate(s)
}

type DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetClientMasterNodes struct {
	ClientMasterNode []*DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetClientMasterNodesClientMasterNode `json:"ClientMasterNode,omitempty" xml:"ClientMasterNode,omitempty" type:"Repeated"`
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetClientMasterNodes) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetClientMasterNodes) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetClientMasterNodes) GetClientMasterNode() []*DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetClientMasterNodesClientMasterNode {
	return s.ClientMasterNode
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetClientMasterNodes) SetClientMasterNode(v []*DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetClientMasterNodesClientMasterNode) *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetClientMasterNodes {
	s.ClientMasterNode = v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetClientMasterNodes) Validate() error {
	return dara.Validate(s)
}

type DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetClientMasterNodesClientMasterNode struct {
	// The default logon password of the ECS instance on the client management node.
	//
	// example:
	//
	// 123456
	DefaultPasswd *string `json:"DefaultPasswd,omitempty" xml:"DefaultPasswd,omitempty"`
	// The ID of the ECS instance on the client management node.
	//
	// example:
	//
	// i-hp3i3odi5ory1buo****
	EcsId *string `json:"EcsId,omitempty" xml:"EcsId,omitempty"`
	// The IP address of the ECS instance on the client management node.
	//
	// example:
	//
	// 192.168.1.0
	EcsIp *string `json:"EcsIp,omitempty" xml:"EcsIp,omitempty"`
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetClientMasterNodesClientMasterNode) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetClientMasterNodesClientMasterNode) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetClientMasterNodesClientMasterNode) GetDefaultPasswd() *string {
	return s.DefaultPasswd
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetClientMasterNodesClientMasterNode) GetEcsId() *string {
	return s.EcsId
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetClientMasterNodesClientMasterNode) GetEcsIp() *string {
	return s.EcsIp
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetClientMasterNodesClientMasterNode) SetDefaultPasswd(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetClientMasterNodesClientMasterNode {
	s.DefaultPasswd = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetClientMasterNodesClientMasterNode) SetEcsId(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetClientMasterNodesClientMasterNode {
	s.EcsId = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetClientMasterNodesClientMasterNode) SetEcsIp(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetClientMasterNodesClientMasterNode {
	s.EcsIp = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetClientMasterNodesClientMasterNode) Validate() error {
	return dara.Validate(s)
}

type DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetTags struct {
	Tag []*DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetTags) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetTags) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetTags) GetTag() []*DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetTagsTag {
	return s.Tag
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetTags) SetTag(v []*DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetTagsTag) *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetTags {
	s.Tag = v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetTags) Validate() error {
	return dara.Validate(s)
}

type DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetTagsTag struct {
	// The tag key.
	//
	// example:
	//
	// test
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	//
	// example:
	//
	// test-value
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetTagsTag) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetTagsTag) GetKey() *string {
	return s.Key
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetTagsTag) GetValue() *string {
	return s.Value
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetTagsTag) SetKey(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetTagsTag {
	s.Key = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetTagsTag) SetValue(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetTagsTag {
	s.Value = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemMountTargetsMountTargetTagsTag) Validate() error {
	return dara.Validate(s)
}

type DescribeFileSystemsResponseBodyFileSystemsFileSystemOptions struct {
	// Specifies whether to enable the oplock feature. Valid values:
	//
	// 	- true: enables the feature.
	//
	// 	- false: disables the feature.
	//
	// >  Only Server Message Block (SMB) file systems support this feature.
	//
	// example:
	//
	// true
	EnableOplock *bool `json:"EnableOplock,omitempty" xml:"EnableOplock,omitempty"`
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemOptions) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemOptions) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemOptions) GetEnableOplock() *bool {
	return s.EnableOplock
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemOptions) SetEnableOplock(v bool) *DescribeFileSystemsResponseBodyFileSystemsFileSystemOptions {
	s.EnableOplock = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemOptions) Validate() error {
	return dara.Validate(s)
}

type DescribeFileSystemsResponseBodyFileSystemsFileSystemPackages struct {
	Package []*DescribeFileSystemsResponseBodyFileSystemsFileSystemPackagesPackage `json:"Package,omitempty" xml:"Package,omitempty" type:"Repeated"`
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemPackages) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemPackages) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemPackages) GetPackage() []*DescribeFileSystemsResponseBodyFileSystemsFileSystemPackagesPackage {
	return s.Package
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemPackages) SetPackage(v []*DescribeFileSystemsResponseBodyFileSystemsFileSystemPackagesPackage) *DescribeFileSystemsResponseBodyFileSystemsFileSystemPackages {
	s.Package = v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemPackages) Validate() error {
	return dara.Validate(s)
}

type DescribeFileSystemsResponseBodyFileSystemsFileSystemPackagesPackage struct {
	// The end time of the validity period for the storage plan.
	//
	// example:
	//
	// 2020-01-05T16:00:00Z
	ExpiredTime *string `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// The ID of the storage plan.
	//
	// example:
	//
	// naspackage-0be9c4b624-37****
	PackageId *string `json:"PackageId,omitempty" xml:"PackageId,omitempty"`
	// The type of the storage plan.
	//
	// Valid values:
	//
	// - ssd: the storage plan for Performance NAS file systems.
	//
	// - hybrid: the storage plan for Capacity NAS file systems.
	//
	// example:
	//
	// hybrid
	PackageType *string `json:"PackageType,omitempty" xml:"PackageType,omitempty"`
	// The capacity of the storage plan. Unit: bytes.
	//
	// example:
	//
	// 107374182400
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The start time of the validity period for the storage plan.
	//
	// example:
	//
	// 2019-12-05T01:40:56Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemPackagesPackage) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemPackagesPackage) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemPackagesPackage) GetExpiredTime() *string {
	return s.ExpiredTime
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemPackagesPackage) GetPackageId() *string {
	return s.PackageId
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemPackagesPackage) GetPackageType() *string {
	return s.PackageType
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemPackagesPackage) GetSize() *int64 {
	return s.Size
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemPackagesPackage) GetStartTime() *string {
	return s.StartTime
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemPackagesPackage) SetExpiredTime(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystemPackagesPackage {
	s.ExpiredTime = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemPackagesPackage) SetPackageId(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystemPackagesPackage {
	s.PackageId = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemPackagesPackage) SetPackageType(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystemPackagesPackage {
	s.PackageType = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemPackagesPackage) SetSize(v int64) *DescribeFileSystemsResponseBodyFileSystemsFileSystemPackagesPackage {
	s.Size = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemPackagesPackage) SetStartTime(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystemPackagesPackage {
	s.StartTime = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemPackagesPackage) Validate() error {
	return dara.Validate(s)
}

type DescribeFileSystemsResponseBodyFileSystemsFileSystemSupportedFeatures struct {
	SupportedFeature []*string `json:"SupportedFeature,omitempty" xml:"SupportedFeature,omitempty" type:"Repeated"`
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemSupportedFeatures) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemSupportedFeatures) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemSupportedFeatures) GetSupportedFeature() []*string {
	return s.SupportedFeature
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemSupportedFeatures) SetSupportedFeature(v []*string) *DescribeFileSystemsResponseBodyFileSystemsFileSystemSupportedFeatures {
	s.SupportedFeature = v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemSupportedFeatures) Validate() error {
	return dara.Validate(s)
}

type DescribeFileSystemsResponseBodyFileSystemsFileSystemTags struct {
	Tag []*DescribeFileSystemsResponseBodyFileSystemsFileSystemTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemTags) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemTags) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemTags) GetTag() []*DescribeFileSystemsResponseBodyFileSystemsFileSystemTagsTag {
	return s.Tag
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemTags) SetTag(v []*DescribeFileSystemsResponseBodyFileSystemsFileSystemTagsTag) *DescribeFileSystemsResponseBodyFileSystemsFileSystemTags {
	s.Tag = v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemTags) Validate() error {
	return dara.Validate(s)
}

type DescribeFileSystemsResponseBodyFileSystemsFileSystemTagsTag struct {
	// The tag key.
	//
	// example:
	//
	// test
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	//
	// example:
	//
	// test-value
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemTagsTag) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemTagsTag) GetKey() *string {
	return s.Key
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemTagsTag) GetValue() *string {
	return s.Value
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemTagsTag) SetKey(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystemTagsTag {
	s.Key = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemTagsTag) SetValue(v string) *DescribeFileSystemsResponseBodyFileSystemsFileSystemTagsTag {
	s.Value = &v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemTagsTag) Validate() error {
	return dara.Validate(s)
}

type DescribeFileSystemsResponseBodyFileSystemsFileSystemVswIds struct {
	VswId []*string `json:"VswId,omitempty" xml:"VswId,omitempty" type:"Repeated"`
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemVswIds) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemsResponseBodyFileSystemsFileSystemVswIds) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemVswIds) GetVswId() []*string {
	return s.VswId
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemVswIds) SetVswId(v []*string) *DescribeFileSystemsResponseBodyFileSystemsFileSystemVswIds {
	s.VswId = v
	return s
}

func (s *DescribeFileSystemsResponseBodyFileSystemsFileSystemVswIds) Validate() error {
	return dara.Validate(s)
}

type iDescribeFileSystemsResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeFileSystemsResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeFileSystemsResponse
	GetStatusCode() *int32
	SetBody(v *DescribeFileSystemsResponseBody) *DescribeFileSystemsResponse
	GetBody() *DescribeFileSystemsResponseBody
}

type DescribeFileSystemsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeFileSystemsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeFileSystemsResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeFileSystemsResponse) GoString() string {
	return s.String()
}

func (s *DescribeFileSystemsResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeFileSystemsResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeFileSystemsResponse) GetBody() *DescribeFileSystemsResponseBody {
	return s.Body
}

func (s *DescribeFileSystemsResponse) SetHeaders(v map[string]*string) *DescribeFileSystemsResponse {
	s.Headers = v
	return s
}

func (s *DescribeFileSystemsResponse) SetStatusCode(v int32) *DescribeFileSystemsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeFileSystemsResponse) SetBody(v *DescribeFileSystemsResponseBody) *DescribeFileSystemsResponse {
	s.Body = v
	return s
}

func (s *DescribeFileSystemsResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeFilesetsRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *DescribeFilesetsRequest
	GetFileSystemId() *string
	SetFilters(v []*DescribeFilesetsRequestFilters) *DescribeFilesetsRequest
	GetFilters() []*DescribeFilesetsRequestFilters
	SetMaxResults(v int64) *DescribeFilesetsRequest
	GetMaxResults() *int64
	SetNextToken(v string) *DescribeFilesetsRequest
	GetNextToken() *string
	SetOrderByField(v string) *DescribeFilesetsRequest
	GetOrderByField() *string
	SetPageNumber(v int32) *DescribeFilesetsRequest
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeFilesetsRequest
	GetPageSize() *int32
	SetSortOrder(v string) *DescribeFilesetsRequest
	GetSortOrder() *string
}

type DescribeFilesetsRequest struct {
	// The ID of the file system.
	//
	// 	- The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-099394bd928c\\*\\*\\*\\*.
	//
	// 	- The IDs of CPFS for LINGJUN file systems must start with `bmcpfs-`. Example: bmcpfs-290w65p03ok64ya\\*\\*\\*\\*.
	//
	// >  CPFS is not supported on the international site.
	//
	// This parameter is required.
	//
	// example:
	//
	// bmcpfs-290w65p03ok64ya****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The filter that is used to query filesets.
	Filters []*DescribeFilesetsRequestFilters `json:"Filters,omitempty" xml:"Filters,omitempty" type:"Repeated"`
	// The number of results for each query.
	//
	// Valid values: 10 to 100. Default value: 20.
	//
	// example:
	//
	// 20
	MaxResults *int64 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.
	//
	// example:
	//
	// TGlzdFJlc291cmNlU****mVzJjE1MTI2NjY4NzY5MTAzOTEmMiZORnI4NDhVeEtrUT0=
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The condition by which the results are sorted. Valid values:
	//
	// 	- FileCountLimit: the file quantity quota
	//
	// 	- SizeLimit: the capacity quota
	//
	// 	- FileCountUsage: the usage of the file quantity quota
	//
	// 	- SpaceUsage: the capacity usage
	//
	// example:
	//
	// FileCountLimit
	OrderByField *string `json:"OrderByField,omitempty" xml:"OrderByField,omitempty"`
	PageNumber   *int32  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize     *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The order in which you want to sort the results. Valid values:
	//
	// 	- asc (default): ascending order
	//
	// 	- desc: descending order
	//
	// >  This parameter takes effect only if you specify the OrderByField parameter.
	//
	// example:
	//
	// asc
	SortOrder *string `json:"SortOrder,omitempty" xml:"SortOrder,omitempty"`
}

func (s DescribeFilesetsRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeFilesetsRequest) GoString() string {
	return s.String()
}

func (s *DescribeFilesetsRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeFilesetsRequest) GetFilters() []*DescribeFilesetsRequestFilters {
	return s.Filters
}

func (s *DescribeFilesetsRequest) GetMaxResults() *int64 {
	return s.MaxResults
}

func (s *DescribeFilesetsRequest) GetNextToken() *string {
	return s.NextToken
}

func (s *DescribeFilesetsRequest) GetOrderByField() *string {
	return s.OrderByField
}

func (s *DescribeFilesetsRequest) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeFilesetsRequest) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeFilesetsRequest) GetSortOrder() *string {
	return s.SortOrder
}

func (s *DescribeFilesetsRequest) SetFileSystemId(v string) *DescribeFilesetsRequest {
	s.FileSystemId = &v
	return s
}

func (s *DescribeFilesetsRequest) SetFilters(v []*DescribeFilesetsRequestFilters) *DescribeFilesetsRequest {
	s.Filters = v
	return s
}

func (s *DescribeFilesetsRequest) SetMaxResults(v int64) *DescribeFilesetsRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeFilesetsRequest) SetNextToken(v string) *DescribeFilesetsRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeFilesetsRequest) SetOrderByField(v string) *DescribeFilesetsRequest {
	s.OrderByField = &v
	return s
}

func (s *DescribeFilesetsRequest) SetPageNumber(v int32) *DescribeFilesetsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeFilesetsRequest) SetPageSize(v int32) *DescribeFilesetsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeFilesetsRequest) SetSortOrder(v string) *DescribeFilesetsRequest {
	s.SortOrder = &v
	return s
}

func (s *DescribeFilesetsRequest) Validate() error {
	return dara.Validate(s)
}

type DescribeFilesetsRequestFilters struct {
	// The filter name. Valid values:
	//
	// 	- FsetIds: filters filesets by fileset ID.
	//
	// 	- FileSystemPath: filters filesets based on the path of a fileset in a CPFS file system.
	//
	// 	- Description: filters filesets based on the fileset description.
	//
	// 	- QuotaExists: filters filesets based on whether quotas exist.
	//
	// >  Only CPFS for LINGJUN V2.7.0 and later support the QuotaExists parameter.
	//
	// example:
	//
	// FsetIds
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The filter value. This parameter does not support wildcards.
	//
	// 	- If Key is set to FsetIds, set Value to a fileset ID or a part of the fileset ID. You can specify a fileset ID or a group of fileset IDs. You can specify a maximum of 10 fileset IDs. Example: `fset-1902718ea0ae****` or `fset-1902718ea0ae****,fset-3212718ea0ae****`.
	//
	// 	- If Key is set to FileSystemPath, set Value to the path or a part of the path of a fileset in a CPFS file system. The value must be 2 to 1024 characters in length. The value must be encoded in UTF-8.
	//
	// 	- If Key is set to Description, set Value to a fileset description or a part of the fileset description.
	//
	// 	- If Key is set to QuotaExists, set Value to true or false. If you do not specify the parameter, all filesets are returned.
	//
	// example:
	//
	// fset-1902718ea0ae****,fset-3212718ea0ae****
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeFilesetsRequestFilters) String() string {
	return dara.Prettify(s)
}

func (s DescribeFilesetsRequestFilters) GoString() string {
	return s.String()
}

func (s *DescribeFilesetsRequestFilters) GetKey() *string {
	return s.Key
}

func (s *DescribeFilesetsRequestFilters) GetValue() *string {
	return s.Value
}

func (s *DescribeFilesetsRequestFilters) SetKey(v string) *DescribeFilesetsRequestFilters {
	s.Key = &v
	return s
}

func (s *DescribeFilesetsRequestFilters) SetValue(v string) *DescribeFilesetsRequestFilters {
	s.Value = &v
	return s
}

func (s *DescribeFilesetsRequestFilters) Validate() error {
	return dara.Validate(s)
}

type iDescribeFilesetsResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetEntries(v *DescribeFilesetsResponseBodyEntries) *DescribeFilesetsResponseBody
	GetEntries() *DescribeFilesetsResponseBodyEntries
	SetFileSystemId(v string) *DescribeFilesetsResponseBody
	GetFileSystemId() *string
	SetNextToken(v string) *DescribeFilesetsResponseBody
	GetNextToken() *string
	SetPageNumber(v int32) *DescribeFilesetsResponseBody
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeFilesetsResponseBody
	GetPageSize() *int32
	SetRequestId(v string) *DescribeFilesetsResponseBody
	GetRequestId() *string
	SetTotalCount(v int32) *DescribeFilesetsResponseBody
	GetTotalCount() *int32
}

type DescribeFilesetsResponseBody struct {
	// The fileset information.
	Entries *DescribeFilesetsResponseBodyEntries `json:"Entries,omitempty" xml:"Entries,omitempty" type:"Struct"`
	// Deprecated
	//
	// The ID of the file system.
	//
	// 	- The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-099394bd928c\\*\\*\\*\\*.
	//
	// 	- The IDs of CPFS for LINGJUN file systems must start with `bmcpfs-`. Example: bmcpfs-290w65p03ok64ya\\*\\*\\*\\*.
	//
	// >  CPFS is not supported on the international site.
	//
	// example:
	//
	// bmcpfs-290w65p03ok64ya****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// A pagination token. It can be used in the next request to retrieve a new page of results.
	//
	// example:
	//
	// TGlzdFJlc291cmNlU****mVzJjE1MTI2NjY4NzY5MTAzOTEmMiZORnI4NDhVeEtrUT0=
	NextToken  *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	PageNumber *int32  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 2D69A58F-345C-4FDE-88E4-BF518948****
	RequestId  *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TotalCount *int32  `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeFilesetsResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeFilesetsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeFilesetsResponseBody) GetEntries() *DescribeFilesetsResponseBodyEntries {
	return s.Entries
}

func (s *DescribeFilesetsResponseBody) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeFilesetsResponseBody) GetNextToken() *string {
	return s.NextToken
}

func (s *DescribeFilesetsResponseBody) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeFilesetsResponseBody) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeFilesetsResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeFilesetsResponseBody) GetTotalCount() *int32 {
	return s.TotalCount
}

func (s *DescribeFilesetsResponseBody) SetEntries(v *DescribeFilesetsResponseBodyEntries) *DescribeFilesetsResponseBody {
	s.Entries = v
	return s
}

func (s *DescribeFilesetsResponseBody) SetFileSystemId(v string) *DescribeFilesetsResponseBody {
	s.FileSystemId = &v
	return s
}

func (s *DescribeFilesetsResponseBody) SetNextToken(v string) *DescribeFilesetsResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeFilesetsResponseBody) SetPageNumber(v int32) *DescribeFilesetsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeFilesetsResponseBody) SetPageSize(v int32) *DescribeFilesetsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeFilesetsResponseBody) SetRequestId(v string) *DescribeFilesetsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeFilesetsResponseBody) SetTotalCount(v int32) *DescribeFilesetsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeFilesetsResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeFilesetsResponseBodyEntries struct {
	Entrie []*DescribeFilesetsResponseBodyEntriesEntrie `json:"Entrie,omitempty" xml:"Entrie,omitempty" type:"Repeated"`
}

func (s DescribeFilesetsResponseBodyEntries) String() string {
	return dara.Prettify(s)
}

func (s DescribeFilesetsResponseBodyEntries) GoString() string {
	return s.String()
}

func (s *DescribeFilesetsResponseBodyEntries) GetEntrie() []*DescribeFilesetsResponseBodyEntriesEntrie {
	return s.Entrie
}

func (s *DescribeFilesetsResponseBodyEntries) SetEntrie(v []*DescribeFilesetsResponseBodyEntriesEntrie) *DescribeFilesetsResponseBodyEntries {
	s.Entrie = v
	return s
}

func (s *DescribeFilesetsResponseBodyEntries) Validate() error {
	return dara.Validate(s)
}

type DescribeFilesetsResponseBodyEntriesEntrie struct {
	// The time when the fileset was created.
	//
	// The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format.
	//
	// example:
	//
	// 2021-09-30T10:08:08Z
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// Specifies whether to enable deletion protection to allow you to release the fileset by using the console or by calling the [DeleteFileset](https://help.aliyun.com/document_detail/2838077.html) operation. Valid values:
	//
	// 	- true
	//
	// 	- false
	//
	// >  This parameter can protect filesets only against manual releases, but not against automatic releases.
	//
	// example:
	//
	// true
	DeletionProtection *bool `json:"DeletionProtection,omitempty" xml:"DeletionProtection,omitempty"`
	// The fileset description.
	//
	// example:
	//
	// test
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The usage of the file quantity.
	//
	// >  Only CPFS for LINGJUN V2.7.0 and later support this parameter.
	//
	// example:
	//
	// 1024
	FileCountUsage *int64 `json:"FileCountUsage,omitempty" xml:"FileCountUsage,omitempty"`
	// The ID of the file system.
	//
	// 	- The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-099394bd928c\\*\\*\\*\\*.
	//
	// 	- The IDs of CPFS for LINGJUN file systems must start with `bmcpfs-`. Example: bmcpfs-290w65p03ok64ya\\*\\*\\*\\*.
	//
	// >  CPFS is not supported on the international site.
	//
	// example:
	//
	// bmcpfs-290w65p03ok64ya****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The fileset path.
	//
	// example:
	//
	// pathtoroot/fset
	FileSystemPath *string `json:"FileSystemPath,omitempty" xml:"FileSystemPath,omitempty"`
	// The fileset ID.
	//
	// example:
	//
	// fset-1902718ea0ae****
	FsetId *string `json:"FsetId,omitempty" xml:"FsetId,omitempty"`
	// The quota information.
	//
	// >  Only CPFS for Lingjun V2.7.0 and later support this parameter.
	Quota *DescribeFilesetsResponseBodyEntriesEntrieQuota `json:"Quota,omitempty" xml:"Quota,omitempty" type:"Struct"`
	// The capacity usage. Unit: bytes.
	//
	// >  Only CPFS for LINGJUN V2.7.0 and later support this parameter.
	//
	// example:
	//
	// 1024
	SpaceUsage *int64 `json:"SpaceUsage,omitempty" xml:"SpaceUsage,omitempty"`
	// The fileset status. Valid values:
	//
	// 	- CREATING: The fileset is being created.
	//
	// 	- CREATED: The fileset has been created and is running properly.
	//
	// 	- RELEASING: The fileset is being released.
	//
	// 	- RELEASED: The fileset has been deleted.
	//
	// example:
	//
	// CREATED
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The time when the fileset was last updated.
	//
	// The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format.
	//
	// example:
	//
	// 2021-09-30T10:08:08Z
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s DescribeFilesetsResponseBodyEntriesEntrie) String() string {
	return dara.Prettify(s)
}

func (s DescribeFilesetsResponseBodyEntriesEntrie) GoString() string {
	return s.String()
}

func (s *DescribeFilesetsResponseBodyEntriesEntrie) GetCreateTime() *string {
	return s.CreateTime
}

func (s *DescribeFilesetsResponseBodyEntriesEntrie) GetDeletionProtection() *bool {
	return s.DeletionProtection
}

func (s *DescribeFilesetsResponseBodyEntriesEntrie) GetDescription() *string {
	return s.Description
}

func (s *DescribeFilesetsResponseBodyEntriesEntrie) GetFileCountUsage() *int64 {
	return s.FileCountUsage
}

func (s *DescribeFilesetsResponseBodyEntriesEntrie) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeFilesetsResponseBodyEntriesEntrie) GetFileSystemPath() *string {
	return s.FileSystemPath
}

func (s *DescribeFilesetsResponseBodyEntriesEntrie) GetFsetId() *string {
	return s.FsetId
}

func (s *DescribeFilesetsResponseBodyEntriesEntrie) GetQuota() *DescribeFilesetsResponseBodyEntriesEntrieQuota {
	return s.Quota
}

func (s *DescribeFilesetsResponseBodyEntriesEntrie) GetSpaceUsage() *int64 {
	return s.SpaceUsage
}

func (s *DescribeFilesetsResponseBodyEntriesEntrie) GetStatus() *string {
	return s.Status
}

func (s *DescribeFilesetsResponseBodyEntriesEntrie) GetUpdateTime() *string {
	return s.UpdateTime
}

func (s *DescribeFilesetsResponseBodyEntriesEntrie) SetCreateTime(v string) *DescribeFilesetsResponseBodyEntriesEntrie {
	s.CreateTime = &v
	return s
}

func (s *DescribeFilesetsResponseBodyEntriesEntrie) SetDeletionProtection(v bool) *DescribeFilesetsResponseBodyEntriesEntrie {
	s.DeletionProtection = &v
	return s
}

func (s *DescribeFilesetsResponseBodyEntriesEntrie) SetDescription(v string) *DescribeFilesetsResponseBodyEntriesEntrie {
	s.Description = &v
	return s
}

func (s *DescribeFilesetsResponseBodyEntriesEntrie) SetFileCountUsage(v int64) *DescribeFilesetsResponseBodyEntriesEntrie {
	s.FileCountUsage = &v
	return s
}

func (s *DescribeFilesetsResponseBodyEntriesEntrie) SetFileSystemId(v string) *DescribeFilesetsResponseBodyEntriesEntrie {
	s.FileSystemId = &v
	return s
}

func (s *DescribeFilesetsResponseBodyEntriesEntrie) SetFileSystemPath(v string) *DescribeFilesetsResponseBodyEntriesEntrie {
	s.FileSystemPath = &v
	return s
}

func (s *DescribeFilesetsResponseBodyEntriesEntrie) SetFsetId(v string) *DescribeFilesetsResponseBodyEntriesEntrie {
	s.FsetId = &v
	return s
}

func (s *DescribeFilesetsResponseBodyEntriesEntrie) SetQuota(v *DescribeFilesetsResponseBodyEntriesEntrieQuota) *DescribeFilesetsResponseBodyEntriesEntrie {
	s.Quota = v
	return s
}

func (s *DescribeFilesetsResponseBodyEntriesEntrie) SetSpaceUsage(v int64) *DescribeFilesetsResponseBodyEntriesEntrie {
	s.SpaceUsage = &v
	return s
}

func (s *DescribeFilesetsResponseBodyEntriesEntrie) SetStatus(v string) *DescribeFilesetsResponseBodyEntriesEntrie {
	s.Status = &v
	return s
}

func (s *DescribeFilesetsResponseBodyEntriesEntrie) SetUpdateTime(v string) *DescribeFilesetsResponseBodyEntriesEntrie {
	s.UpdateTime = &v
	return s
}

func (s *DescribeFilesetsResponseBodyEntriesEntrie) Validate() error {
	return dara.Validate(s)
}

type DescribeFilesetsResponseBodyEntriesEntrieQuota struct {
	// The file quantity quota. Valid values:
	//
	// 	- Minimum value: 10000.
	//
	// 	- Maximum value: 10000000000.
	//
	// example:
	//
	// 10000
	FileCountLimit *int64 `json:"FileCountLimit,omitempty" xml:"FileCountLimit,omitempty"`
	// The capacity quota. Unit: bytes.
	//
	// 	- Minimum value: 10737418240 (10 GiB).
	//
	// 	- Step size: 1073741824 (1 GiB).
	//
	// example:
	//
	// 10737418240
	SizeLimit *int64 `json:"SizeLimit,omitempty" xml:"SizeLimit,omitempty"`
}

func (s DescribeFilesetsResponseBodyEntriesEntrieQuota) String() string {
	return dara.Prettify(s)
}

func (s DescribeFilesetsResponseBodyEntriesEntrieQuota) GoString() string {
	return s.String()
}

func (s *DescribeFilesetsResponseBodyEntriesEntrieQuota) GetFileCountLimit() *int64 {
	return s.FileCountLimit
}

func (s *DescribeFilesetsResponseBodyEntriesEntrieQuota) GetSizeLimit() *int64 {
	return s.SizeLimit
}

func (s *DescribeFilesetsResponseBodyEntriesEntrieQuota) SetFileCountLimit(v int64) *DescribeFilesetsResponseBodyEntriesEntrieQuota {
	s.FileCountLimit = &v
	return s
}

func (s *DescribeFilesetsResponseBodyEntriesEntrieQuota) SetSizeLimit(v int64) *DescribeFilesetsResponseBodyEntriesEntrieQuota {
	s.SizeLimit = &v
	return s
}

func (s *DescribeFilesetsResponseBodyEntriesEntrieQuota) Validate() error {
	return dara.Validate(s)
}

type iDescribeFilesetsResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeFilesetsResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeFilesetsResponse
	GetStatusCode() *int32
	SetBody(v *DescribeFilesetsResponseBody) *DescribeFilesetsResponse
	GetBody() *DescribeFilesetsResponseBody
}

type DescribeFilesetsResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeFilesetsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeFilesetsResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeFilesetsResponse) GoString() string {
	return s.String()
}

func (s *DescribeFilesetsResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeFilesetsResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeFilesetsResponse) GetBody() *DescribeFilesetsResponseBody {
	return s.Body
}

func (s *DescribeFilesetsResponse) SetHeaders(v map[string]*string) *DescribeFilesetsResponse {
	s.Headers = v
	return s
}

func (s *DescribeFilesetsResponse) SetStatusCode(v int32) *DescribeFilesetsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeFilesetsResponse) SetBody(v *DescribeFilesetsResponseBody) *DescribeFilesetsResponse {
	s.Body = v
	return s
}

func (s *DescribeFilesetsResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeFilesystemsVscAttachInfoRequest interface {
	dara.Model
	String() string
	GoString() string
	SetMaxResults(v int32) *DescribeFilesystemsVscAttachInfoRequest
	GetMaxResults() *int32
	SetNextToken(v string) *DescribeFilesystemsVscAttachInfoRequest
	GetNextToken() *string
	SetResourceIds(v []*DescribeFilesystemsVscAttachInfoRequestResourceIds) *DescribeFilesystemsVscAttachInfoRequest
	GetResourceIds() []*DescribeFilesystemsVscAttachInfoRequestResourceIds
}

type DescribeFilesystemsVscAttachInfoRequest struct {
	MaxResults *int32  `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	NextToken  *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// This parameter is required.
	ResourceIds []*DescribeFilesystemsVscAttachInfoRequestResourceIds `json:"ResourceIds,omitempty" xml:"ResourceIds,omitempty" type:"Repeated"`
}

func (s DescribeFilesystemsVscAttachInfoRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeFilesystemsVscAttachInfoRequest) GoString() string {
	return s.String()
}

func (s *DescribeFilesystemsVscAttachInfoRequest) GetMaxResults() *int32 {
	return s.MaxResults
}

func (s *DescribeFilesystemsVscAttachInfoRequest) GetNextToken() *string {
	return s.NextToken
}

func (s *DescribeFilesystemsVscAttachInfoRequest) GetResourceIds() []*DescribeFilesystemsVscAttachInfoRequestResourceIds {
	return s.ResourceIds
}

func (s *DescribeFilesystemsVscAttachInfoRequest) SetMaxResults(v int32) *DescribeFilesystemsVscAttachInfoRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeFilesystemsVscAttachInfoRequest) SetNextToken(v string) *DescribeFilesystemsVscAttachInfoRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeFilesystemsVscAttachInfoRequest) SetResourceIds(v []*DescribeFilesystemsVscAttachInfoRequestResourceIds) *DescribeFilesystemsVscAttachInfoRequest {
	s.ResourceIds = v
	return s
}

func (s *DescribeFilesystemsVscAttachInfoRequest) Validate() error {
	return dara.Validate(s)
}

type DescribeFilesystemsVscAttachInfoRequestResourceIds struct {
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	VscId        *string `json:"VscId,omitempty" xml:"VscId,omitempty"`
}

func (s DescribeFilesystemsVscAttachInfoRequestResourceIds) String() string {
	return dara.Prettify(s)
}

func (s DescribeFilesystemsVscAttachInfoRequestResourceIds) GoString() string {
	return s.String()
}

func (s *DescribeFilesystemsVscAttachInfoRequestResourceIds) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeFilesystemsVscAttachInfoRequestResourceIds) GetVscId() *string {
	return s.VscId
}

func (s *DescribeFilesystemsVscAttachInfoRequestResourceIds) SetFileSystemId(v string) *DescribeFilesystemsVscAttachInfoRequestResourceIds {
	s.FileSystemId = &v
	return s
}

func (s *DescribeFilesystemsVscAttachInfoRequestResourceIds) SetVscId(v string) *DescribeFilesystemsVscAttachInfoRequestResourceIds {
	s.VscId = &v
	return s
}

func (s *DescribeFilesystemsVscAttachInfoRequestResourceIds) Validate() error {
	return dara.Validate(s)
}

type iDescribeFilesystemsVscAttachInfoResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetMaxResults(v int32) *DescribeFilesystemsVscAttachInfoResponseBody
	GetMaxResults() *int32
	SetNextToken(v string) *DescribeFilesystemsVscAttachInfoResponseBody
	GetNextToken() *string
	SetRequestId(v string) *DescribeFilesystemsVscAttachInfoResponseBody
	GetRequestId() *string
	SetTotalCount(v int32) *DescribeFilesystemsVscAttachInfoResponseBody
	GetTotalCount() *int32
	SetVscAttachInfo(v *DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfo) *DescribeFilesystemsVscAttachInfoResponseBody
	GetVscAttachInfo() *DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfo
}

type DescribeFilesystemsVscAttachInfoResponseBody struct {
	MaxResults    *int32                                                     `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	NextToken     *string                                                    `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	RequestId     *string                                                    `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TotalCount    *int32                                                     `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	VscAttachInfo *DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfo `json:"VscAttachInfo,omitempty" xml:"VscAttachInfo,omitempty" type:"Struct"`
}

func (s DescribeFilesystemsVscAttachInfoResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeFilesystemsVscAttachInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeFilesystemsVscAttachInfoResponseBody) GetMaxResults() *int32 {
	return s.MaxResults
}

func (s *DescribeFilesystemsVscAttachInfoResponseBody) GetNextToken() *string {
	return s.NextToken
}

func (s *DescribeFilesystemsVscAttachInfoResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeFilesystemsVscAttachInfoResponseBody) GetTotalCount() *int32 {
	return s.TotalCount
}

func (s *DescribeFilesystemsVscAttachInfoResponseBody) GetVscAttachInfo() *DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfo {
	return s.VscAttachInfo
}

func (s *DescribeFilesystemsVscAttachInfoResponseBody) SetMaxResults(v int32) *DescribeFilesystemsVscAttachInfoResponseBody {
	s.MaxResults = &v
	return s
}

func (s *DescribeFilesystemsVscAttachInfoResponseBody) SetNextToken(v string) *DescribeFilesystemsVscAttachInfoResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeFilesystemsVscAttachInfoResponseBody) SetRequestId(v string) *DescribeFilesystemsVscAttachInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeFilesystemsVscAttachInfoResponseBody) SetTotalCount(v int32) *DescribeFilesystemsVscAttachInfoResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeFilesystemsVscAttachInfoResponseBody) SetVscAttachInfo(v *DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfo) *DescribeFilesystemsVscAttachInfoResponseBody {
	s.VscAttachInfo = v
	return s
}

func (s *DescribeFilesystemsVscAttachInfoResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfo struct {
	VscAttachInfo []*DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfoVscAttachInfo `json:"VscAttachInfo,omitempty" xml:"VscAttachInfo,omitempty" type:"Repeated"`
}

func (s DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfo) String() string {
	return dara.Prettify(s)
}

func (s DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfo) GoString() string {
	return s.String()
}

func (s *DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfo) GetVscAttachInfo() []*DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfoVscAttachInfo {
	return s.VscAttachInfo
}

func (s *DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfo) SetVscAttachInfo(v []*DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfoVscAttachInfo) *DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfo {
	s.VscAttachInfo = v
	return s
}

func (s *DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfo) Validate() error {
	return dara.Validate(s)
}

type DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfoVscAttachInfo struct {
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	Status       *string `json:"Status,omitempty" xml:"Status,omitempty"`
	VscId        *string `json:"VscId,omitempty" xml:"VscId,omitempty"`
}

func (s DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfoVscAttachInfo) String() string {
	return dara.Prettify(s)
}

func (s DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfoVscAttachInfo) GoString() string {
	return s.String()
}

func (s *DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfoVscAttachInfo) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfoVscAttachInfo) GetStatus() *string {
	return s.Status
}

func (s *DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfoVscAttachInfo) GetVscId() *string {
	return s.VscId
}

func (s *DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfoVscAttachInfo) SetFileSystemId(v string) *DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfoVscAttachInfo {
	s.FileSystemId = &v
	return s
}

func (s *DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfoVscAttachInfo) SetStatus(v string) *DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfoVscAttachInfo {
	s.Status = &v
	return s
}

func (s *DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfoVscAttachInfo) SetVscId(v string) *DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfoVscAttachInfo {
	s.VscId = &v
	return s
}

func (s *DescribeFilesystemsVscAttachInfoResponseBodyVscAttachInfoVscAttachInfo) Validate() error {
	return dara.Validate(s)
}

type iDescribeFilesystemsVscAttachInfoResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeFilesystemsVscAttachInfoResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeFilesystemsVscAttachInfoResponse
	GetStatusCode() *int32
	SetBody(v *DescribeFilesystemsVscAttachInfoResponseBody) *DescribeFilesystemsVscAttachInfoResponse
	GetBody() *DescribeFilesystemsVscAttachInfoResponseBody
}

type DescribeFilesystemsVscAttachInfoResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeFilesystemsVscAttachInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeFilesystemsVscAttachInfoResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeFilesystemsVscAttachInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribeFilesystemsVscAttachInfoResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeFilesystemsVscAttachInfoResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeFilesystemsVscAttachInfoResponse) GetBody() *DescribeFilesystemsVscAttachInfoResponseBody {
	return s.Body
}

func (s *DescribeFilesystemsVscAttachInfoResponse) SetHeaders(v map[string]*string) *DescribeFilesystemsVscAttachInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribeFilesystemsVscAttachInfoResponse) SetStatusCode(v int32) *DescribeFilesystemsVscAttachInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeFilesystemsVscAttachInfoResponse) SetBody(v *DescribeFilesystemsVscAttachInfoResponseBody) *DescribeFilesystemsVscAttachInfoResponse {
	s.Body = v
	return s
}

func (s *DescribeFilesystemsVscAttachInfoResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeLifecyclePoliciesRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *DescribeLifecyclePoliciesRequest
	GetFileSystemId() *string
	SetFileSystemType(v string) *DescribeLifecyclePoliciesRequest
	GetFileSystemType() *string
	SetFsetId(v string) *DescribeLifecyclePoliciesRequest
	GetFsetId() *string
	SetLifecyclePolicyName(v string) *DescribeLifecyclePoliciesRequest
	GetLifecyclePolicyName() *string
	SetPageNumber(v int32) *DescribeLifecyclePoliciesRequest
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeLifecyclePoliciesRequest
	GetPageSize() *int32
	SetStorageType(v string) *DescribeLifecyclePoliciesRequest
	GetStorageType() *string
}

type DescribeLifecyclePoliciesRequest struct {
	// The ID of the file system.
	//
	// example:
	//
	// 31a8e4****
	FileSystemId   *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
	FsetId         *string `json:"FsetId,omitempty" xml:"FsetId,omitempty"`
	// The name of the lifecycle policy. The name must meet the following conventions:
	//
	// The name must be 3 to 64 characters in length and must start with a letter. It can contain letters, digits, underscores (_), and hyphens (-).
	//
	// example:
	//
	// lifecyclepolicy_01
	LifecyclePolicyName *string `json:"LifecyclePolicyName,omitempty" xml:"LifecyclePolicyName,omitempty"`
	// The page number.
	//
	// Pages start from page 1. Default value: 1.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	//
	// Valid values: 1 to 100.
	//
	// Default value: 10.
	//
	// example:
	//
	// 10
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The storage class.
	//
	// 	- InfrequentAccess: the Infrequent Access (IA) storage class.
	//
	// 	- Archive: the Archive storage class.
	//
	// >  If the StorageType parameter is not specified, data retrieval tasks of all types are returned.
	//
	// if can be null:
	// true
	//
	// example:
	//
	// InfrequentAccess
	StorageType *string `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
}

func (s DescribeLifecyclePoliciesRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeLifecyclePoliciesRequest) GoString() string {
	return s.String()
}

func (s *DescribeLifecyclePoliciesRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeLifecyclePoliciesRequest) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *DescribeLifecyclePoliciesRequest) GetFsetId() *string {
	return s.FsetId
}

func (s *DescribeLifecyclePoliciesRequest) GetLifecyclePolicyName() *string {
	return s.LifecyclePolicyName
}

func (s *DescribeLifecyclePoliciesRequest) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeLifecyclePoliciesRequest) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeLifecyclePoliciesRequest) GetStorageType() *string {
	return s.StorageType
}

func (s *DescribeLifecyclePoliciesRequest) SetFileSystemId(v string) *DescribeLifecyclePoliciesRequest {
	s.FileSystemId = &v
	return s
}

func (s *DescribeLifecyclePoliciesRequest) SetFileSystemType(v string) *DescribeLifecyclePoliciesRequest {
	s.FileSystemType = &v
	return s
}

func (s *DescribeLifecyclePoliciesRequest) SetFsetId(v string) *DescribeLifecyclePoliciesRequest {
	s.FsetId = &v
	return s
}

func (s *DescribeLifecyclePoliciesRequest) SetLifecyclePolicyName(v string) *DescribeLifecyclePoliciesRequest {
	s.LifecyclePolicyName = &v
	return s
}

func (s *DescribeLifecyclePoliciesRequest) SetPageNumber(v int32) *DescribeLifecyclePoliciesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeLifecyclePoliciesRequest) SetPageSize(v int32) *DescribeLifecyclePoliciesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeLifecyclePoliciesRequest) SetStorageType(v string) *DescribeLifecyclePoliciesRequest {
	s.StorageType = &v
	return s
}

func (s *DescribeLifecyclePoliciesRequest) Validate() error {
	return dara.Validate(s)
}

type iDescribeLifecyclePoliciesResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetLifecyclePolicies(v []*DescribeLifecyclePoliciesResponseBodyLifecyclePolicies) *DescribeLifecyclePoliciesResponseBody
	GetLifecyclePolicies() []*DescribeLifecyclePoliciesResponseBodyLifecyclePolicies
	SetPageNumber(v int32) *DescribeLifecyclePoliciesResponseBody
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeLifecyclePoliciesResponseBody
	GetPageSize() *int32
	SetRequestId(v string) *DescribeLifecyclePoliciesResponseBody
	GetRequestId() *string
	SetTotalCount(v int32) *DescribeLifecyclePoliciesResponseBody
	GetTotalCount() *int32
}

type DescribeLifecyclePoliciesResponseBody struct {
	// The queried lifecycle policies.
	LifecyclePolicies []*DescribeLifecyclePoliciesResponseBodyLifecyclePolicies `json:"LifecyclePolicies,omitempty" xml:"LifecyclePolicies,omitempty" type:"Repeated"`
	// The page number.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	//
	// example:
	//
	// 10
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	//
	// example:
	//
	// BC7C825C-5F65-4B56-BEF6-98C56C7C****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of lifecycle policies.
	//
	// example:
	//
	// 10
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeLifecyclePoliciesResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeLifecyclePoliciesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeLifecyclePoliciesResponseBody) GetLifecyclePolicies() []*DescribeLifecyclePoliciesResponseBodyLifecyclePolicies {
	return s.LifecyclePolicies
}

func (s *DescribeLifecyclePoliciesResponseBody) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeLifecyclePoliciesResponseBody) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeLifecyclePoliciesResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeLifecyclePoliciesResponseBody) GetTotalCount() *int32 {
	return s.TotalCount
}

func (s *DescribeLifecyclePoliciesResponseBody) SetLifecyclePolicies(v []*DescribeLifecyclePoliciesResponseBodyLifecyclePolicies) *DescribeLifecyclePoliciesResponseBody {
	s.LifecyclePolicies = v
	return s
}

func (s *DescribeLifecyclePoliciesResponseBody) SetPageNumber(v int32) *DescribeLifecyclePoliciesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeLifecyclePoliciesResponseBody) SetPageSize(v int32) *DescribeLifecyclePoliciesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeLifecyclePoliciesResponseBody) SetRequestId(v string) *DescribeLifecyclePoliciesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeLifecyclePoliciesResponseBody) SetTotalCount(v int32) *DescribeLifecyclePoliciesResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeLifecyclePoliciesResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeLifecyclePoliciesResponseBodyLifecyclePolicies struct {
	// The time when the lifecycle policy was created.
	//
	// The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format.
	//
	// example:
	//
	// 2019-10-30T10:08:08Z
	CreateTime      *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	EnableLifecycle *bool   `json:"EnableLifecycle,omitempty" xml:"EnableLifecycle,omitempty"`
	// The ID of the file system.
	//
	// example:
	//
	// 31a8e4****
	FileSystemId *string   `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	FsetIds      []*string `json:"FsetIds,omitempty" xml:"FsetIds,omitempty" type:"Repeated"`
	// The name of the lifecycle policy.
	//
	// example:
	//
	// lifecyclepolicy_01
	LifecyclePolicyName *string `json:"LifecyclePolicyName,omitempty" xml:"LifecyclePolicyName,omitempty"`
	// The management rule that is associated with the lifecycle policy.
	//
	// Valid values:
	//
	// 	- DEFAULT_ATIME_14: Files that are not accessed in the last 14 days are dumped to the IA storage medium.
	//
	// 	- DEFAULT_ATIME_30: Files that are not accessed in the last 30 days are dumped to the IA storage medium.
	//
	// 	- DEFAULT_ATIME_60: Files that are not accessed in the last 60 days are dumped to the IA storage medium.
	//
	// 	- DEFAULT_ATIME_90: Files that are not accessed in the last 90 days are dumped to the IA storage medium.
	//
	// example:
	//
	// DEFAULT_ATIME_14
	LifecycleRuleName *string `json:"LifecycleRuleName,omitempty" xml:"LifecycleRuleName,omitempty"`
	LifecycleRuleType *string `json:"LifecycleRuleType,omitempty" xml:"LifecycleRuleType,omitempty"`
	// The absolute path of a directory with which the lifecycle policy is associated.
	//
	// example:
	//
	// /pathway/to/folder
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The absolute paths to multiple directories associated with the lifecycle policy.
	Paths  []*string `json:"Paths,omitempty" xml:"Paths,omitempty" type:"Repeated"`
	Status *string   `json:"Status,omitempty" xml:"Status,omitempty"`
	// The storage type of the data that is dumped to the IA storage medium.
	//
	// Default value: InfrequentAccess (IA).
	//
	// example:
	//
	// InfrequentAccess
	StorageType *string `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
}

func (s DescribeLifecyclePoliciesResponseBodyLifecyclePolicies) String() string {
	return dara.Prettify(s)
}

func (s DescribeLifecyclePoliciesResponseBodyLifecyclePolicies) GoString() string {
	return s.String()
}

func (s *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies) GetCreateTime() *string {
	return s.CreateTime
}

func (s *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies) GetEnableLifecycle() *bool {
	return s.EnableLifecycle
}

func (s *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies) GetFsetIds() []*string {
	return s.FsetIds
}

func (s *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies) GetLifecyclePolicyName() *string {
	return s.LifecyclePolicyName
}

func (s *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies) GetLifecycleRuleName() *string {
	return s.LifecycleRuleName
}

func (s *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies) GetLifecycleRuleType() *string {
	return s.LifecycleRuleType
}

func (s *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies) GetPath() *string {
	return s.Path
}

func (s *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies) GetPaths() []*string {
	return s.Paths
}

func (s *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies) GetStatus() *string {
	return s.Status
}

func (s *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies) GetStorageType() *string {
	return s.StorageType
}

func (s *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies) SetCreateTime(v string) *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies {
	s.CreateTime = &v
	return s
}

func (s *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies) SetEnableLifecycle(v bool) *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies {
	s.EnableLifecycle = &v
	return s
}

func (s *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies) SetFileSystemId(v string) *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies {
	s.FileSystemId = &v
	return s
}

func (s *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies) SetFsetIds(v []*string) *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies {
	s.FsetIds = v
	return s
}

func (s *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies) SetLifecyclePolicyName(v string) *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies {
	s.LifecyclePolicyName = &v
	return s
}

func (s *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies) SetLifecycleRuleName(v string) *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies {
	s.LifecycleRuleName = &v
	return s
}

func (s *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies) SetLifecycleRuleType(v string) *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies {
	s.LifecycleRuleType = &v
	return s
}

func (s *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies) SetPath(v string) *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies {
	s.Path = &v
	return s
}

func (s *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies) SetPaths(v []*string) *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies {
	s.Paths = v
	return s
}

func (s *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies) SetStatus(v string) *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies {
	s.Status = &v
	return s
}

func (s *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies) SetStorageType(v string) *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies {
	s.StorageType = &v
	return s
}

func (s *DescribeLifecyclePoliciesResponseBodyLifecyclePolicies) Validate() error {
	return dara.Validate(s)
}

type iDescribeLifecyclePoliciesResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeLifecyclePoliciesResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeLifecyclePoliciesResponse
	GetStatusCode() *int32
	SetBody(v *DescribeLifecyclePoliciesResponseBody) *DescribeLifecyclePoliciesResponse
	GetBody() *DescribeLifecyclePoliciesResponseBody
}

type DescribeLifecyclePoliciesResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeLifecyclePoliciesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeLifecyclePoliciesResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeLifecyclePoliciesResponse) GoString() string {
	return s.String()
}

func (s *DescribeLifecyclePoliciesResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeLifecyclePoliciesResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeLifecyclePoliciesResponse) GetBody() *DescribeLifecyclePoliciesResponseBody {
	return s.Body
}

func (s *DescribeLifecyclePoliciesResponse) SetHeaders(v map[string]*string) *DescribeLifecyclePoliciesResponse {
	s.Headers = v
	return s
}

func (s *DescribeLifecyclePoliciesResponse) SetStatusCode(v int32) *DescribeLifecyclePoliciesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeLifecyclePoliciesResponse) SetBody(v *DescribeLifecyclePoliciesResponseBody) *DescribeLifecyclePoliciesResponse {
	s.Body = v
	return s
}

func (s *DescribeLifecyclePoliciesResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeLogAnalysisRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemType(v string) *DescribeLogAnalysisRequest
	GetFileSystemType() *string
	SetPageNumber(v int32) *DescribeLogAnalysisRequest
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeLogAnalysisRequest
	GetPageSize() *int32
	SetRegionId(v string) *DescribeLogAnalysisRequest
	GetRegionId() *string
}

type DescribeLogAnalysisRequest struct {
	// The type of the file system.
	//
	// Valid values:
	//
	// 	- standard: General-purpose NAS file system
	//
	// 	- extreme: Extreme NAS file system
	//
	// 	- all (default): all types
	//
	// example:
	//
	// all
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
	// The page number. Default value: 1.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Valid values: 1 to 100. Default value: 10.
	//
	// example:
	//
	// 1
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// cn-hangzhou
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeLogAnalysisRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeLogAnalysisRequest) GoString() string {
	return s.String()
}

func (s *DescribeLogAnalysisRequest) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *DescribeLogAnalysisRequest) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeLogAnalysisRequest) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeLogAnalysisRequest) GetRegionId() *string {
	return s.RegionId
}

func (s *DescribeLogAnalysisRequest) SetFileSystemType(v string) *DescribeLogAnalysisRequest {
	s.FileSystemType = &v
	return s
}

func (s *DescribeLogAnalysisRequest) SetPageNumber(v int32) *DescribeLogAnalysisRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeLogAnalysisRequest) SetPageSize(v int32) *DescribeLogAnalysisRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeLogAnalysisRequest) SetRegionId(v string) *DescribeLogAnalysisRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeLogAnalysisRequest) Validate() error {
	return dara.Validate(s)
}

type iDescribeLogAnalysisResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetAnalyses(v *DescribeLogAnalysisResponseBodyAnalyses) *DescribeLogAnalysisResponseBody
	GetAnalyses() *DescribeLogAnalysisResponseBodyAnalyses
	SetCode(v string) *DescribeLogAnalysisResponseBody
	GetCode() *string
	SetPageNumber(v int32) *DescribeLogAnalysisResponseBody
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeLogAnalysisResponseBody
	GetPageSize() *int32
	SetRequestId(v string) *DescribeLogAnalysisResponseBody
	GetRequestId() *string
	SetTotalCount(v int32) *DescribeLogAnalysisResponseBody
	GetTotalCount() *int32
}

type DescribeLogAnalysisResponseBody struct {
	// The collection of log dump information.
	Analyses *DescribeLogAnalysisResponseBodyAnalyses `json:"Analyses,omitempty" xml:"Analyses,omitempty" type:"Struct"`
	// The HTTP status code.
	//
	// example:
	//
	// 200
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The page number.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of log dump entries returned per page.
	//
	// example:
	//
	// 10
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	//
	// example:
	//
	// C84F77AF-3DE5-48F1-B19B-37FCBE24****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of log dump entries in the region.
	//
	// example:
	//
	// 10
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeLogAnalysisResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeLogAnalysisResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeLogAnalysisResponseBody) GetAnalyses() *DescribeLogAnalysisResponseBodyAnalyses {
	return s.Analyses
}

func (s *DescribeLogAnalysisResponseBody) GetCode() *string {
	return s.Code
}

func (s *DescribeLogAnalysisResponseBody) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeLogAnalysisResponseBody) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeLogAnalysisResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeLogAnalysisResponseBody) GetTotalCount() *int32 {
	return s.TotalCount
}

func (s *DescribeLogAnalysisResponseBody) SetAnalyses(v *DescribeLogAnalysisResponseBodyAnalyses) *DescribeLogAnalysisResponseBody {
	s.Analyses = v
	return s
}

func (s *DescribeLogAnalysisResponseBody) SetCode(v string) *DescribeLogAnalysisResponseBody {
	s.Code = &v
	return s
}

func (s *DescribeLogAnalysisResponseBody) SetPageNumber(v int32) *DescribeLogAnalysisResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeLogAnalysisResponseBody) SetPageSize(v int32) *DescribeLogAnalysisResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeLogAnalysisResponseBody) SetRequestId(v string) *DescribeLogAnalysisResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeLogAnalysisResponseBody) SetTotalCount(v int32) *DescribeLogAnalysisResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeLogAnalysisResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeLogAnalysisResponseBodyAnalyses struct {
	Analysis []*DescribeLogAnalysisResponseBodyAnalysesAnalysis `json:"Analysis,omitempty" xml:"Analysis,omitempty" type:"Repeated"`
}

func (s DescribeLogAnalysisResponseBodyAnalyses) String() string {
	return dara.Prettify(s)
}

func (s DescribeLogAnalysisResponseBodyAnalyses) GoString() string {
	return s.String()
}

func (s *DescribeLogAnalysisResponseBodyAnalyses) GetAnalysis() []*DescribeLogAnalysisResponseBodyAnalysesAnalysis {
	return s.Analysis
}

func (s *DescribeLogAnalysisResponseBodyAnalyses) SetAnalysis(v []*DescribeLogAnalysisResponseBodyAnalysesAnalysis) *DescribeLogAnalysisResponseBodyAnalyses {
	s.Analysis = v
	return s
}

func (s *DescribeLogAnalysisResponseBodyAnalyses) Validate() error {
	return dara.Validate(s)
}

type DescribeLogAnalysisResponseBodyAnalysesAnalysis struct {
	// The ID of the file system.
	//
	// example:
	//
	// 0c7154xxxx
	MetaKey *string `json:"MetaKey,omitempty" xml:"MetaKey,omitempty"`
	// The log dump information of the file system.
	MetaValue *DescribeLogAnalysisResponseBodyAnalysesAnalysisMetaValue `json:"MetaValue,omitempty" xml:"MetaValue,omitempty" type:"Struct"`
}

func (s DescribeLogAnalysisResponseBodyAnalysesAnalysis) String() string {
	return dara.Prettify(s)
}

func (s DescribeLogAnalysisResponseBodyAnalysesAnalysis) GoString() string {
	return s.String()
}

func (s *DescribeLogAnalysisResponseBodyAnalysesAnalysis) GetMetaKey() *string {
	return s.MetaKey
}

func (s *DescribeLogAnalysisResponseBodyAnalysesAnalysis) GetMetaValue() *DescribeLogAnalysisResponseBodyAnalysesAnalysisMetaValue {
	return s.MetaValue
}

func (s *DescribeLogAnalysisResponseBodyAnalysesAnalysis) SetMetaKey(v string) *DescribeLogAnalysisResponseBodyAnalysesAnalysis {
	s.MetaKey = &v
	return s
}

func (s *DescribeLogAnalysisResponseBodyAnalysesAnalysis) SetMetaValue(v *DescribeLogAnalysisResponseBodyAnalysesAnalysisMetaValue) *DescribeLogAnalysisResponseBodyAnalysesAnalysis {
	s.MetaValue = v
	return s
}

func (s *DescribeLogAnalysisResponseBodyAnalysesAnalysis) Validate() error {
	return dara.Validate(s)
}

type DescribeLogAnalysisResponseBodyAnalysesAnalysisMetaValue struct {
	// The name of the dedicated Logstore that is used to store NAS operation logs.
	//
	// example:
	//
	// nas-nfs
	Logstore *string `json:"Logstore,omitempty" xml:"Logstore,omitempty"`
	// The name of the project where the dedicated Logstore resides.
	//
	// example:
	//
	// nas-1746495857602745-cn-hangzhou
	Project *string `json:"Project,omitempty" xml:"Project,omitempty"`
	// The region where the dedicated Logstore resides.
	//
	// example:
	//
	// cn-hangzhou
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The role that is used by NAS to access Simple Log Service.
	//
	// example:
	//
	// acs:ram::162165525211xxxx:role/aliyunnaslogarchiverole
	RoleArn *string `json:"RoleArn,omitempty" xml:"RoleArn,omitempty"`
}

func (s DescribeLogAnalysisResponseBodyAnalysesAnalysisMetaValue) String() string {
	return dara.Prettify(s)
}

func (s DescribeLogAnalysisResponseBodyAnalysesAnalysisMetaValue) GoString() string {
	return s.String()
}

func (s *DescribeLogAnalysisResponseBodyAnalysesAnalysisMetaValue) GetLogstore() *string {
	return s.Logstore
}

func (s *DescribeLogAnalysisResponseBodyAnalysesAnalysisMetaValue) GetProject() *string {
	return s.Project
}

func (s *DescribeLogAnalysisResponseBodyAnalysesAnalysisMetaValue) GetRegion() *string {
	return s.Region
}

func (s *DescribeLogAnalysisResponseBodyAnalysesAnalysisMetaValue) GetRoleArn() *string {
	return s.RoleArn
}

func (s *DescribeLogAnalysisResponseBodyAnalysesAnalysisMetaValue) SetLogstore(v string) *DescribeLogAnalysisResponseBodyAnalysesAnalysisMetaValue {
	s.Logstore = &v
	return s
}

func (s *DescribeLogAnalysisResponseBodyAnalysesAnalysisMetaValue) SetProject(v string) *DescribeLogAnalysisResponseBodyAnalysesAnalysisMetaValue {
	s.Project = &v
	return s
}

func (s *DescribeLogAnalysisResponseBodyAnalysesAnalysisMetaValue) SetRegion(v string) *DescribeLogAnalysisResponseBodyAnalysesAnalysisMetaValue {
	s.Region = &v
	return s
}

func (s *DescribeLogAnalysisResponseBodyAnalysesAnalysisMetaValue) SetRoleArn(v string) *DescribeLogAnalysisResponseBodyAnalysesAnalysisMetaValue {
	s.RoleArn = &v
	return s
}

func (s *DescribeLogAnalysisResponseBodyAnalysesAnalysisMetaValue) Validate() error {
	return dara.Validate(s)
}

type iDescribeLogAnalysisResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeLogAnalysisResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeLogAnalysisResponse
	GetStatusCode() *int32
	SetBody(v *DescribeLogAnalysisResponseBody) *DescribeLogAnalysisResponse
	GetBody() *DescribeLogAnalysisResponseBody
}

type DescribeLogAnalysisResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeLogAnalysisResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeLogAnalysisResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeLogAnalysisResponse) GoString() string {
	return s.String()
}

func (s *DescribeLogAnalysisResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeLogAnalysisResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeLogAnalysisResponse) GetBody() *DescribeLogAnalysisResponseBody {
	return s.Body
}

func (s *DescribeLogAnalysisResponse) SetHeaders(v map[string]*string) *DescribeLogAnalysisResponse {
	s.Headers = v
	return s
}

func (s *DescribeLogAnalysisResponse) SetStatusCode(v int32) *DescribeLogAnalysisResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeLogAnalysisResponse) SetBody(v *DescribeLogAnalysisResponseBody) *DescribeLogAnalysisResponse {
	s.Body = v
	return s
}

func (s *DescribeLogAnalysisResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeMountTargetsRequest interface {
	dara.Model
	String() string
	GoString() string
	SetDualStackMountTargetDomain(v string) *DescribeMountTargetsRequest
	GetDualStackMountTargetDomain() *string
	SetFileSystemId(v string) *DescribeMountTargetsRequest
	GetFileSystemId() *string
	SetMountTargetDomain(v string) *DescribeMountTargetsRequest
	GetMountTargetDomain() *string
	SetPageNumber(v int32) *DescribeMountTargetsRequest
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeMountTargetsRequest
	GetPageSize() *int32
}

type DescribeMountTargetsRequest struct {
	// The dual-stack (IPv4 and IPv6) domain name of the mount target.
	//
	// > Only Extreme NAS file systems that reside in the Chinese mainland support IPv6.
	//
	// example:
	//
	// 174494b666-x****.dualstack.cn-hangzhou.nas.aliyuncs.com
	DualStackMountTargetDomain *string `json:"DualStackMountTargetDomain,omitempty" xml:"DualStackMountTargetDomain,omitempty"`
	// The ID of the file system.
	//
	// 	- Sample ID of a General-purpose NAS file system: 31a8e4\\*\\*\\*\\*.
	//
	// 	- The IDs of Extreme NAS file systems must start with `extreme-`, for example, extreme-0015\\*\\*\\*\\*.
	//
	// 	- The IDs of Cloud Parallel File Storage (CPFS) file systems must start with `cpfs-`, for example, cpfs-125487\\*\\*\\*\\*.
	//
	// > CPFS file systems are available only on the China site (aliyun.com).
	//
	// This parameter is required.
	//
	// example:
	//
	// 1ca404****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The domain name of the mount target.
	//
	// example:
	//
	// 1ca404a666-x****.cn-hangzhou.nas.aliyuncs.com
	MountTargetDomain *string `json:"MountTargetDomain,omitempty" xml:"MountTargetDomain,omitempty"`
	// The page number.
	//
	// Pages start from page 1. Default value: 1.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	//
	// Valid values: 1 to 100.
	//
	// Default value: 10.
	//
	// example:
	//
	// 1
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribeMountTargetsRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeMountTargetsRequest) GoString() string {
	return s.String()
}

func (s *DescribeMountTargetsRequest) GetDualStackMountTargetDomain() *string {
	return s.DualStackMountTargetDomain
}

func (s *DescribeMountTargetsRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeMountTargetsRequest) GetMountTargetDomain() *string {
	return s.MountTargetDomain
}

func (s *DescribeMountTargetsRequest) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeMountTargetsRequest) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeMountTargetsRequest) SetDualStackMountTargetDomain(v string) *DescribeMountTargetsRequest {
	s.DualStackMountTargetDomain = &v
	return s
}

func (s *DescribeMountTargetsRequest) SetFileSystemId(v string) *DescribeMountTargetsRequest {
	s.FileSystemId = &v
	return s
}

func (s *DescribeMountTargetsRequest) SetMountTargetDomain(v string) *DescribeMountTargetsRequest {
	s.MountTargetDomain = &v
	return s
}

func (s *DescribeMountTargetsRequest) SetPageNumber(v int32) *DescribeMountTargetsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeMountTargetsRequest) SetPageSize(v int32) *DescribeMountTargetsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeMountTargetsRequest) Validate() error {
	return dara.Validate(s)
}

type iDescribeMountTargetsResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetMountTargets(v *DescribeMountTargetsResponseBodyMountTargets) *DescribeMountTargetsResponseBody
	GetMountTargets() *DescribeMountTargetsResponseBodyMountTargets
	SetPageNumber(v int32) *DescribeMountTargetsResponseBody
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeMountTargetsResponseBody
	GetPageSize() *int32
	SetRequestId(v string) *DescribeMountTargetsResponseBody
	GetRequestId() *string
	SetTotalCount(v int32) *DescribeMountTargetsResponseBody
	GetTotalCount() *int32
}

type DescribeMountTargetsResponseBody struct {
	// The information about mount targets.
	MountTargets *DescribeMountTargetsResponseBodyMountTargets `json:"MountTargets,omitempty" xml:"MountTargets,omitempty" type:"Struct"`
	// The page number.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	//
	// example:
	//
	// 1
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 3BAB90FD-B4A0-48DA-9F09-2B963510****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of mount targets.
	//
	// example:
	//
	// 1
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeMountTargetsResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeMountTargetsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeMountTargetsResponseBody) GetMountTargets() *DescribeMountTargetsResponseBodyMountTargets {
	return s.MountTargets
}

func (s *DescribeMountTargetsResponseBody) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeMountTargetsResponseBody) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeMountTargetsResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeMountTargetsResponseBody) GetTotalCount() *int32 {
	return s.TotalCount
}

func (s *DescribeMountTargetsResponseBody) SetMountTargets(v *DescribeMountTargetsResponseBodyMountTargets) *DescribeMountTargetsResponseBody {
	s.MountTargets = v
	return s
}

func (s *DescribeMountTargetsResponseBody) SetPageNumber(v int32) *DescribeMountTargetsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeMountTargetsResponseBody) SetPageSize(v int32) *DescribeMountTargetsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeMountTargetsResponseBody) SetRequestId(v string) *DescribeMountTargetsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeMountTargetsResponseBody) SetTotalCount(v int32) *DescribeMountTargetsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeMountTargetsResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeMountTargetsResponseBodyMountTargets struct {
	MountTarget []*DescribeMountTargetsResponseBodyMountTargetsMountTarget `json:"MountTarget,omitempty" xml:"MountTarget,omitempty" type:"Repeated"`
}

func (s DescribeMountTargetsResponseBodyMountTargets) String() string {
	return dara.Prettify(s)
}

func (s DescribeMountTargetsResponseBodyMountTargets) GoString() string {
	return s.String()
}

func (s *DescribeMountTargetsResponseBodyMountTargets) GetMountTarget() []*DescribeMountTargetsResponseBodyMountTargetsMountTarget {
	return s.MountTarget
}

func (s *DescribeMountTargetsResponseBodyMountTargets) SetMountTarget(v []*DescribeMountTargetsResponseBodyMountTargetsMountTarget) *DescribeMountTargetsResponseBodyMountTargets {
	s.MountTarget = v
	return s
}

func (s *DescribeMountTargetsResponseBodyMountTargets) Validate() error {
	return dara.Validate(s)
}

type DescribeMountTargetsResponseBodyMountTargetsMountTarget struct {
	// The name of the permission group that is attached to the mount target.
	//
	// example:
	//
	// DEFAULT_VPC_GROUP_NAME
	AccessGroup *string `json:"AccessGroup,omitempty" xml:"AccessGroup,omitempty"`
	// The information about client management nodes.
	ClientMasterNodes *DescribeMountTargetsResponseBodyMountTargetsMountTargetClientMasterNodes `json:"ClientMasterNodes,omitempty" xml:"ClientMasterNodes,omitempty" type:"Struct"`
	// The dual-stack (IPv4 and IPv6) domain name of the mount target.
	//
	// example:
	//
	// 174494b666-x****.dualstack.cn-hangzhou.nas.aliyuncs.com
	DualStackMountTargetDomain *string `json:"DualStackMountTargetDomain,omitempty" xml:"DualStackMountTargetDomain,omitempty"`
	// The type of the mount target.
	//
	// 	- IPv4: an IPv4 mount target
	//
	// 	- DualStack: a dual-stack mount target
	//
	// example:
	//
	// IPv4
	IPVersion *string `json:"IPVersion,omitempty" xml:"IPVersion,omitempty"`
	// The IPv4 domain name of the mount target.
	//
	// example:
	//
	// 1ca404a666-w****.cn-hangzhou.nas.aliyuncs.com
	MountTargetDomain *string `json:"MountTargetDomain,omitempty" xml:"MountTargetDomain,omitempty"`
	MountTargetIp     *string `json:"MountTargetIp,omitempty" xml:"MountTargetIp,omitempty"`
	// The network type. Valid value: **Vpc**.
	//
	// example:
	//
	// Vpc
	NetworkType *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	// The status of the mount target.
	//
	// Valid values:
	//
	// 	- Active: The mount target is available.
	//
	// 	- Inactive: The mount target is unavailable.
	//
	// 	- Pending: The mount target is being created or modified.
	//
	// 	- Deleting: The mount target is being deleted.
	//
	// 	- Hibernating: The mount target is being hibernated.
	//
	// 	- Hibernated: The mount target is hibernated.
	//
	// > You can mount a file system only when the mount target of the file system is in the Active state.
	//
	// example:
	//
	// Active
	Status *string                                                      `json:"Status,omitempty" xml:"Status,omitempty"`
	Tags   *DescribeMountTargetsResponseBodyMountTargetsMountTargetTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The ID of the virtual private cloud (VPC).
	//
	// example:
	//
	// vpc-2zesj9afh3y518k9o****
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The ID of the vSwitch.
	//
	// example:
	//
	// vsw-2zevmwkwyztjuoffg****
	VswId *string `json:"VswId,omitempty" xml:"VswId,omitempty"`
}

func (s DescribeMountTargetsResponseBodyMountTargetsMountTarget) String() string {
	return dara.Prettify(s)
}

func (s DescribeMountTargetsResponseBodyMountTargetsMountTarget) GoString() string {
	return s.String()
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTarget) GetAccessGroup() *string {
	return s.AccessGroup
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTarget) GetClientMasterNodes() *DescribeMountTargetsResponseBodyMountTargetsMountTargetClientMasterNodes {
	return s.ClientMasterNodes
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTarget) GetDualStackMountTargetDomain() *string {
	return s.DualStackMountTargetDomain
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTarget) GetIPVersion() *string {
	return s.IPVersion
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTarget) GetMountTargetDomain() *string {
	return s.MountTargetDomain
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTarget) GetMountTargetIp() *string {
	return s.MountTargetIp
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTarget) GetNetworkType() *string {
	return s.NetworkType
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTarget) GetStatus() *string {
	return s.Status
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTarget) GetTags() *DescribeMountTargetsResponseBodyMountTargetsMountTargetTags {
	return s.Tags
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTarget) GetVpcId() *string {
	return s.VpcId
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTarget) GetVswId() *string {
	return s.VswId
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTarget) SetAccessGroup(v string) *DescribeMountTargetsResponseBodyMountTargetsMountTarget {
	s.AccessGroup = &v
	return s
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTarget) SetClientMasterNodes(v *DescribeMountTargetsResponseBodyMountTargetsMountTargetClientMasterNodes) *DescribeMountTargetsResponseBodyMountTargetsMountTarget {
	s.ClientMasterNodes = v
	return s
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTarget) SetDualStackMountTargetDomain(v string) *DescribeMountTargetsResponseBodyMountTargetsMountTarget {
	s.DualStackMountTargetDomain = &v
	return s
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTarget) SetIPVersion(v string) *DescribeMountTargetsResponseBodyMountTargetsMountTarget {
	s.IPVersion = &v
	return s
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTarget) SetMountTargetDomain(v string) *DescribeMountTargetsResponseBodyMountTargetsMountTarget {
	s.MountTargetDomain = &v
	return s
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTarget) SetMountTargetIp(v string) *DescribeMountTargetsResponseBodyMountTargetsMountTarget {
	s.MountTargetIp = &v
	return s
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTarget) SetNetworkType(v string) *DescribeMountTargetsResponseBodyMountTargetsMountTarget {
	s.NetworkType = &v
	return s
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTarget) SetStatus(v string) *DescribeMountTargetsResponseBodyMountTargetsMountTarget {
	s.Status = &v
	return s
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTarget) SetTags(v *DescribeMountTargetsResponseBodyMountTargetsMountTargetTags) *DescribeMountTargetsResponseBodyMountTargetsMountTarget {
	s.Tags = v
	return s
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTarget) SetVpcId(v string) *DescribeMountTargetsResponseBodyMountTargetsMountTarget {
	s.VpcId = &v
	return s
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTarget) SetVswId(v string) *DescribeMountTargetsResponseBodyMountTargetsMountTarget {
	s.VswId = &v
	return s
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTarget) Validate() error {
	return dara.Validate(s)
}

type DescribeMountTargetsResponseBodyMountTargetsMountTargetClientMasterNodes struct {
	ClientMasterNode []*DescribeMountTargetsResponseBodyMountTargetsMountTargetClientMasterNodesClientMasterNode `json:"ClientMasterNode,omitempty" xml:"ClientMasterNode,omitempty" type:"Repeated"`
}

func (s DescribeMountTargetsResponseBodyMountTargetsMountTargetClientMasterNodes) String() string {
	return dara.Prettify(s)
}

func (s DescribeMountTargetsResponseBodyMountTargetsMountTargetClientMasterNodes) GoString() string {
	return s.String()
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTargetClientMasterNodes) GetClientMasterNode() []*DescribeMountTargetsResponseBodyMountTargetsMountTargetClientMasterNodesClientMasterNode {
	return s.ClientMasterNode
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTargetClientMasterNodes) SetClientMasterNode(v []*DescribeMountTargetsResponseBodyMountTargetsMountTargetClientMasterNodesClientMasterNode) *DescribeMountTargetsResponseBodyMountTargetsMountTargetClientMasterNodes {
	s.ClientMasterNode = v
	return s
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTargetClientMasterNodes) Validate() error {
	return dara.Validate(s)
}

type DescribeMountTargetsResponseBodyMountTargetsMountTargetClientMasterNodesClientMasterNode struct {
	// The default logon password of the ECS instance.
	//
	// example:
	//
	// 12****
	DefaultPasswd *string `json:"DefaultPasswd,omitempty" xml:"DefaultPasswd,omitempty"`
	// The ID of the ECS instance on the client management node.
	//
	// example:
	//
	// i-hp3i3odi5ory1buo****
	EcsId *string `json:"EcsId,omitempty" xml:"EcsId,omitempty"`
	// The IP address of the ECS instance on the client management node.
	//
	// example:
	//
	// 192.168.1.0
	EcsIp *string `json:"EcsIp,omitempty" xml:"EcsIp,omitempty"`
}

func (s DescribeMountTargetsResponseBodyMountTargetsMountTargetClientMasterNodesClientMasterNode) String() string {
	return dara.Prettify(s)
}

func (s DescribeMountTargetsResponseBodyMountTargetsMountTargetClientMasterNodesClientMasterNode) GoString() string {
	return s.String()
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTargetClientMasterNodesClientMasterNode) GetDefaultPasswd() *string {
	return s.DefaultPasswd
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTargetClientMasterNodesClientMasterNode) GetEcsId() *string {
	return s.EcsId
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTargetClientMasterNodesClientMasterNode) GetEcsIp() *string {
	return s.EcsIp
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTargetClientMasterNodesClientMasterNode) SetDefaultPasswd(v string) *DescribeMountTargetsResponseBodyMountTargetsMountTargetClientMasterNodesClientMasterNode {
	s.DefaultPasswd = &v
	return s
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTargetClientMasterNodesClientMasterNode) SetEcsId(v string) *DescribeMountTargetsResponseBodyMountTargetsMountTargetClientMasterNodesClientMasterNode {
	s.EcsId = &v
	return s
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTargetClientMasterNodesClientMasterNode) SetEcsIp(v string) *DescribeMountTargetsResponseBodyMountTargetsMountTargetClientMasterNodesClientMasterNode {
	s.EcsIp = &v
	return s
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTargetClientMasterNodesClientMasterNode) Validate() error {
	return dara.Validate(s)
}

type DescribeMountTargetsResponseBodyMountTargetsMountTargetTags struct {
	Tag []*DescribeMountTargetsResponseBodyMountTargetsMountTargetTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeMountTargetsResponseBodyMountTargetsMountTargetTags) String() string {
	return dara.Prettify(s)
}

func (s DescribeMountTargetsResponseBodyMountTargetsMountTargetTags) GoString() string {
	return s.String()
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTargetTags) GetTag() []*DescribeMountTargetsResponseBodyMountTargetsMountTargetTagsTag {
	return s.Tag
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTargetTags) SetTag(v []*DescribeMountTargetsResponseBodyMountTargetsMountTargetTagsTag) *DescribeMountTargetsResponseBodyMountTargetsMountTargetTags {
	s.Tag = v
	return s
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTargetTags) Validate() error {
	return dara.Validate(s)
}

type DescribeMountTargetsResponseBodyMountTargetsMountTargetTagsTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeMountTargetsResponseBodyMountTargetsMountTargetTagsTag) String() string {
	return dara.Prettify(s)
}

func (s DescribeMountTargetsResponseBodyMountTargetsMountTargetTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTargetTagsTag) GetKey() *string {
	return s.Key
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTargetTagsTag) GetValue() *string {
	return s.Value
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTargetTagsTag) SetKey(v string) *DescribeMountTargetsResponseBodyMountTargetsMountTargetTagsTag {
	s.Key = &v
	return s
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTargetTagsTag) SetValue(v string) *DescribeMountTargetsResponseBodyMountTargetsMountTargetTagsTag {
	s.Value = &v
	return s
}

func (s *DescribeMountTargetsResponseBodyMountTargetsMountTargetTagsTag) Validate() error {
	return dara.Validate(s)
}

type iDescribeMountTargetsResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeMountTargetsResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeMountTargetsResponse
	GetStatusCode() *int32
	SetBody(v *DescribeMountTargetsResponseBody) *DescribeMountTargetsResponse
	GetBody() *DescribeMountTargetsResponseBody
}

type DescribeMountTargetsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeMountTargetsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeMountTargetsResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeMountTargetsResponse) GoString() string {
	return s.String()
}

func (s *DescribeMountTargetsResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeMountTargetsResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeMountTargetsResponse) GetBody() *DescribeMountTargetsResponseBody {
	return s.Body
}

func (s *DescribeMountTargetsResponse) SetHeaders(v map[string]*string) *DescribeMountTargetsResponse {
	s.Headers = v
	return s
}

func (s *DescribeMountTargetsResponse) SetStatusCode(v int32) *DescribeMountTargetsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeMountTargetsResponse) SetBody(v *DescribeMountTargetsResponseBody) *DescribeMountTargetsResponse {
	s.Body = v
	return s
}

func (s *DescribeMountTargetsResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeMountedClientsRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientIP(v string) *DescribeMountedClientsRequest
	GetClientIP() *string
	SetFileSystemId(v string) *DescribeMountedClientsRequest
	GetFileSystemId() *string
	SetMountTargetDomain(v string) *DescribeMountedClientsRequest
	GetMountTargetDomain() *string
	SetPageNumber(v int32) *DescribeMountedClientsRequest
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeMountedClientsRequest
	GetPageSize() *int32
	SetRegionId(v string) *DescribeMountedClientsRequest
	GetRegionId() *string
}

type DescribeMountedClientsRequest struct {
	// The IP address of the client.
	//
	// 	- If you specify an IP address, the operation checks whether the client list includes this IP address. If the client list includes the IP address, the operation returns the IP address. If the client list does not include the IP address, the operation returns an empty list.
	//
	// 	- If you do not specify an IP address, the operation returns the IP addresses of all clients that have accessed the specified NAS file system within the last minute.
	//
	// example:
	//
	// 10.10.10.1
	ClientIP *string `json:"ClientIP,omitempty" xml:"ClientIP,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 109c****66
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The domain name of the mount target.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1111222****95.cn-hangzhou.nas.aliyuncs.com
	MountTargetDomain *string `json:"MountTargetDomain,omitempty" xml:"MountTargetDomain,omitempty"`
	// The page number.
	//
	// Pages start from page 1. Default value: 1.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of IP addresses to return on each page.
	//
	// Valid values: 1 to 100.
	//
	// Default value: 10.
	//
	// example:
	//
	// 10
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// cn-hangzhou
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeMountedClientsRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeMountedClientsRequest) GoString() string {
	return s.String()
}

func (s *DescribeMountedClientsRequest) GetClientIP() *string {
	return s.ClientIP
}

func (s *DescribeMountedClientsRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeMountedClientsRequest) GetMountTargetDomain() *string {
	return s.MountTargetDomain
}

func (s *DescribeMountedClientsRequest) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeMountedClientsRequest) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeMountedClientsRequest) GetRegionId() *string {
	return s.RegionId
}

func (s *DescribeMountedClientsRequest) SetClientIP(v string) *DescribeMountedClientsRequest {
	s.ClientIP = &v
	return s
}

func (s *DescribeMountedClientsRequest) SetFileSystemId(v string) *DescribeMountedClientsRequest {
	s.FileSystemId = &v
	return s
}

func (s *DescribeMountedClientsRequest) SetMountTargetDomain(v string) *DescribeMountedClientsRequest {
	s.MountTargetDomain = &v
	return s
}

func (s *DescribeMountedClientsRequest) SetPageNumber(v int32) *DescribeMountedClientsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeMountedClientsRequest) SetPageSize(v int32) *DescribeMountedClientsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeMountedClientsRequest) SetRegionId(v string) *DescribeMountedClientsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeMountedClientsRequest) Validate() error {
	return dara.Validate(s)
}

type iDescribeMountedClientsResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetClients(v *DescribeMountedClientsResponseBodyClients) *DescribeMountedClientsResponseBody
	GetClients() *DescribeMountedClientsResponseBodyClients
	SetPageNumber(v int32) *DescribeMountedClientsResponseBody
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeMountedClientsResponseBody
	GetPageSize() *int32
	SetRequestId(v string) *DescribeMountedClientsResponseBody
	GetRequestId() *string
	SetTotalCount(v int32) *DescribeMountedClientsResponseBody
	GetTotalCount() *int32
}

type DescribeMountedClientsResponseBody struct {
	// The queried clients.
	Clients *DescribeMountedClientsResponseBodyClients `json:"Clients,omitempty" xml:"Clients,omitempty" type:"Struct"`
	// The page number.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of IP addresses returned per page.
	//
	// example:
	//
	// 10
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	//
	// example:
	//
	// A70BEE5D-76D3-49FB-B58F-1F398211****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of IP addresses.
	//
	// example:
	//
	// 10
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeMountedClientsResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeMountedClientsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeMountedClientsResponseBody) GetClients() *DescribeMountedClientsResponseBodyClients {
	return s.Clients
}

func (s *DescribeMountedClientsResponseBody) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeMountedClientsResponseBody) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeMountedClientsResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeMountedClientsResponseBody) GetTotalCount() *int32 {
	return s.TotalCount
}

func (s *DescribeMountedClientsResponseBody) SetClients(v *DescribeMountedClientsResponseBodyClients) *DescribeMountedClientsResponseBody {
	s.Clients = v
	return s
}

func (s *DescribeMountedClientsResponseBody) SetPageNumber(v int32) *DescribeMountedClientsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeMountedClientsResponseBody) SetPageSize(v int32) *DescribeMountedClientsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeMountedClientsResponseBody) SetRequestId(v string) *DescribeMountedClientsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeMountedClientsResponseBody) SetTotalCount(v int32) *DescribeMountedClientsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeMountedClientsResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeMountedClientsResponseBodyClients struct {
	Client []*DescribeMountedClientsResponseBodyClientsClient `json:"Client,omitempty" xml:"Client,omitempty" type:"Repeated"`
}

func (s DescribeMountedClientsResponseBodyClients) String() string {
	return dara.Prettify(s)
}

func (s DescribeMountedClientsResponseBodyClients) GoString() string {
	return s.String()
}

func (s *DescribeMountedClientsResponseBodyClients) GetClient() []*DescribeMountedClientsResponseBodyClientsClient {
	return s.Client
}

func (s *DescribeMountedClientsResponseBodyClients) SetClient(v []*DescribeMountedClientsResponseBodyClientsClient) *DescribeMountedClientsResponseBodyClients {
	s.Client = v
	return s
}

func (s *DescribeMountedClientsResponseBodyClients) Validate() error {
	return dara.Validate(s)
}

type DescribeMountedClientsResponseBodyClientsClient struct {
	// The IP address of the client.
	//
	// example:
	//
	// 10.10.10.1
	ClientIP *string `json:"ClientIP,omitempty" xml:"ClientIP,omitempty"`
}

func (s DescribeMountedClientsResponseBodyClientsClient) String() string {
	return dara.Prettify(s)
}

func (s DescribeMountedClientsResponseBodyClientsClient) GoString() string {
	return s.String()
}

func (s *DescribeMountedClientsResponseBodyClientsClient) GetClientIP() *string {
	return s.ClientIP
}

func (s *DescribeMountedClientsResponseBodyClientsClient) SetClientIP(v string) *DescribeMountedClientsResponseBodyClientsClient {
	s.ClientIP = &v
	return s
}

func (s *DescribeMountedClientsResponseBodyClientsClient) Validate() error {
	return dara.Validate(s)
}

type iDescribeMountedClientsResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeMountedClientsResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeMountedClientsResponse
	GetStatusCode() *int32
	SetBody(v *DescribeMountedClientsResponseBody) *DescribeMountedClientsResponse
	GetBody() *DescribeMountedClientsResponseBody
}

type DescribeMountedClientsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeMountedClientsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeMountedClientsResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeMountedClientsResponse) GoString() string {
	return s.String()
}

func (s *DescribeMountedClientsResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeMountedClientsResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeMountedClientsResponse) GetBody() *DescribeMountedClientsResponseBody {
	return s.Body
}

func (s *DescribeMountedClientsResponse) SetHeaders(v map[string]*string) *DescribeMountedClientsResponse {
	s.Headers = v
	return s
}

func (s *DescribeMountedClientsResponse) SetStatusCode(v int32) *DescribeMountedClientsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeMountedClientsResponse) SetBody(v *DescribeMountedClientsResponseBody) *DescribeMountedClientsResponse {
	s.Body = v
	return s
}

func (s *DescribeMountedClientsResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeNfsAclRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *DescribeNfsAclRequest
	GetFileSystemId() *string
}

type DescribeNfsAclRequest struct {
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 206614xxxx
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
}

func (s DescribeNfsAclRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeNfsAclRequest) GoString() string {
	return s.String()
}

func (s *DescribeNfsAclRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeNfsAclRequest) SetFileSystemId(v string) *DescribeNfsAclRequest {
	s.FileSystemId = &v
	return s
}

func (s *DescribeNfsAclRequest) Validate() error {
	return dara.Validate(s)
}

type iDescribeNfsAclResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetAcl(v *DescribeNfsAclResponseBodyAcl) *DescribeNfsAclResponseBody
	GetAcl() *DescribeNfsAclResponseBodyAcl
	SetRequestId(v string) *DescribeNfsAclResponseBody
	GetRequestId() *string
}

type DescribeNfsAclResponseBody struct {
	// The information about the ACL feature.
	Acl *DescribeNfsAclResponseBodyAcl `json:"Acl,omitempty" xml:"Acl,omitempty" type:"Struct"`
	// The request ID.
	//
	// example:
	//
	// A1098673-1746-505E-A5F1-08527B7EDBDF
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeNfsAclResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeNfsAclResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeNfsAclResponseBody) GetAcl() *DescribeNfsAclResponseBodyAcl {
	return s.Acl
}

func (s *DescribeNfsAclResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeNfsAclResponseBody) SetAcl(v *DescribeNfsAclResponseBodyAcl) *DescribeNfsAclResponseBody {
	s.Acl = v
	return s
}

func (s *DescribeNfsAclResponseBody) SetRequestId(v string) *DescribeNfsAclResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeNfsAclResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeNfsAclResponseBodyAcl struct {
	// Indicates whether the NFS ACL feature is enabled.
	//
	// 	- true: The NFS ACL feature is enabled.
	//
	// 	- false: The NFS ACL feature is disabled.
	//
	// example:
	//
	// true
	Enabled *bool `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
}

func (s DescribeNfsAclResponseBodyAcl) String() string {
	return dara.Prettify(s)
}

func (s DescribeNfsAclResponseBodyAcl) GoString() string {
	return s.String()
}

func (s *DescribeNfsAclResponseBodyAcl) GetEnabled() *bool {
	return s.Enabled
}

func (s *DescribeNfsAclResponseBodyAcl) SetEnabled(v bool) *DescribeNfsAclResponseBodyAcl {
	s.Enabled = &v
	return s
}

func (s *DescribeNfsAclResponseBodyAcl) Validate() error {
	return dara.Validate(s)
}

type iDescribeNfsAclResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeNfsAclResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeNfsAclResponse
	GetStatusCode() *int32
	SetBody(v *DescribeNfsAclResponseBody) *DescribeNfsAclResponse
	GetBody() *DescribeNfsAclResponseBody
}

type DescribeNfsAclResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeNfsAclResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeNfsAclResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeNfsAclResponse) GoString() string {
	return s.String()
}

func (s *DescribeNfsAclResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeNfsAclResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeNfsAclResponse) GetBody() *DescribeNfsAclResponseBody {
	return s.Body
}

func (s *DescribeNfsAclResponse) SetHeaders(v map[string]*string) *DescribeNfsAclResponse {
	s.Headers = v
	return s
}

func (s *DescribeNfsAclResponse) SetStatusCode(v int32) *DescribeNfsAclResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeNfsAclResponse) SetBody(v *DescribeNfsAclResponseBody) *DescribeNfsAclResponse {
	s.Body = v
	return s
}

func (s *DescribeNfsAclResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeProtocolMountTargetRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientToken(v string) *DescribeProtocolMountTargetRequest
	GetClientToken() *string
	SetFileSystemId(v string) *DescribeProtocolMountTargetRequest
	GetFileSystemId() *string
	SetFilters(v []*DescribeProtocolMountTargetRequestFilters) *DescribeProtocolMountTargetRequest
	GetFilters() []*DescribeProtocolMountTargetRequestFilters
	SetMaxResults(v int64) *DescribeProtocolMountTargetRequest
	GetMaxResults() *int64
	SetNextToken(v string) *DescribeProtocolMountTargetRequest
	GetNextToken() *string
}

type DescribeProtocolMountTargetRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// >  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-42665544****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// cpfs-099394bd928c****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The filter that is used to query the export directories of the protocol service.
	Filters []*DescribeProtocolMountTargetRequestFilters `json:"Filters,omitempty" xml:"Filters,omitempty" type:"Repeated"`
	// The number of results for each query.
	//
	// 	- Value values: 10 to 100.
	//
	// 	- Default value: 20.
	//
	// example:
	//
	// 20
	MaxResults *int64 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.
	//
	// example:
	//
	// aBcdg==
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
}

func (s DescribeProtocolMountTargetRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeProtocolMountTargetRequest) GoString() string {
	return s.String()
}

func (s *DescribeProtocolMountTargetRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *DescribeProtocolMountTargetRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeProtocolMountTargetRequest) GetFilters() []*DescribeProtocolMountTargetRequestFilters {
	return s.Filters
}

func (s *DescribeProtocolMountTargetRequest) GetMaxResults() *int64 {
	return s.MaxResults
}

func (s *DescribeProtocolMountTargetRequest) GetNextToken() *string {
	return s.NextToken
}

func (s *DescribeProtocolMountTargetRequest) SetClientToken(v string) *DescribeProtocolMountTargetRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeProtocolMountTargetRequest) SetFileSystemId(v string) *DescribeProtocolMountTargetRequest {
	s.FileSystemId = &v
	return s
}

func (s *DescribeProtocolMountTargetRequest) SetFilters(v []*DescribeProtocolMountTargetRequestFilters) *DescribeProtocolMountTargetRequest {
	s.Filters = v
	return s
}

func (s *DescribeProtocolMountTargetRequest) SetMaxResults(v int64) *DescribeProtocolMountTargetRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeProtocolMountTargetRequest) SetNextToken(v string) *DescribeProtocolMountTargetRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeProtocolMountTargetRequest) Validate() error {
	return dara.Validate(s)
}

type DescribeProtocolMountTargetRequestFilters struct {
	// The filter name.
	//
	// 	- ProtocolServiceIds: filters export directories by protocol service ID.
	//
	// 	- ExportIds: filters export directories by export directory ID.
	//
	// 	- VpcIds: filters export directories by virtual private cloud (VPC) ID.
	//
	// 	- VSwitchIds: filters export directories by vSwitch ID.
	//
	// 	- FsetIds: filters export directories by fileset ID.
	//
	// 	- Paths: filters export directories based on the path of the file system corresponding to the mount target.
	//
	// 	- AccessGroupNames: filters export directories by permission group name.
	//
	// example:
	//
	// ExportIds
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The filter value. This parameter does not support wildcards.
	//
	// 	- If Key is set to ProtocolServiceIds, set Value to a protocol service ID. You can specify a maximum of 10 protocol service IDs. Example: `ptc-12345678` or `ptc-12345678,ptc-12345679`.
	//
	// 	- If Key is set to ExportIds, set Value to an export directory ID. You can specify a maximum of 10 export directory IDs. Example: `exp-12345678` or `exp-12345678,exp-12345679`.
	//
	// 	- If Key is set to VpcIds, set Value to a VPC ID of the protocol service. You can specify a maximum of 10 VPC IDs. Example: `vpc-12345678` or `vpc-12345678,vpc-12345679`.
	//
	// 	- If Key is set to FsetIds, set Value to a fileset ID. You can specify a maximum of 10 fileset IDs. Example: `fset-12345678` or `fset-12345678,fset-12345679`.
	//
	// 	- If Key is set to Paths, set Value to a path of the file system corresponding to the mount target. You can specify a maximum of 10 paths. Example: `/cpfs/mnt_1/` or `/cpfs/mnt_1/,/cpfs/mnt_2/`.
	//
	// 	- If Key is set to AccessGroupNames, set Value to a permission group name for the protocol service. You can specify a maximum of 10 permission group names. Example: `ag-12345678` or `ag-12345678,ag-12345679`.
	//
	// example:
	//
	// exp-19abf5beab8d****, exp-19acf6beaf7d****
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeProtocolMountTargetRequestFilters) String() string {
	return dara.Prettify(s)
}

func (s DescribeProtocolMountTargetRequestFilters) GoString() string {
	return s.String()
}

func (s *DescribeProtocolMountTargetRequestFilters) GetKey() *string {
	return s.Key
}

func (s *DescribeProtocolMountTargetRequestFilters) GetValue() *string {
	return s.Value
}

func (s *DescribeProtocolMountTargetRequestFilters) SetKey(v string) *DescribeProtocolMountTargetRequestFilters {
	s.Key = &v
	return s
}

func (s *DescribeProtocolMountTargetRequestFilters) SetValue(v string) *DescribeProtocolMountTargetRequestFilters {
	s.Value = &v
	return s
}

func (s *DescribeProtocolMountTargetRequestFilters) Validate() error {
	return dara.Validate(s)
}

type iDescribeProtocolMountTargetResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetNextToken(v string) *DescribeProtocolMountTargetResponseBody
	GetNextToken() *string
	SetProtocolMountTargets(v []*DescribeProtocolMountTargetResponseBodyProtocolMountTargets) *DescribeProtocolMountTargetResponseBody
	GetProtocolMountTargets() []*DescribeProtocolMountTargetResponseBodyProtocolMountTargets
	SetRequestId(v string) *DescribeProtocolMountTargetResponseBody
	GetRequestId() *string
}

type DescribeProtocolMountTargetResponseBody struct {
	// A pagination token. It can be used in the next request to retrieve a new page of results.
	//
	// example:
	//
	// aBcdeg==
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The export directories of the protocol service.
	ProtocolMountTargets []*DescribeProtocolMountTargetResponseBodyProtocolMountTargets `json:"ProtocolMountTargets,omitempty" xml:"ProtocolMountTargets,omitempty" type:"Repeated"`
	// The request ID.
	//
	// example:
	//
	// 473469C7-AA6F-4DC5-B3DB-A3DC0****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeProtocolMountTargetResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeProtocolMountTargetResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeProtocolMountTargetResponseBody) GetNextToken() *string {
	return s.NextToken
}

func (s *DescribeProtocolMountTargetResponseBody) GetProtocolMountTargets() []*DescribeProtocolMountTargetResponseBodyProtocolMountTargets {
	return s.ProtocolMountTargets
}

func (s *DescribeProtocolMountTargetResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeProtocolMountTargetResponseBody) SetNextToken(v string) *DescribeProtocolMountTargetResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeProtocolMountTargetResponseBody) SetProtocolMountTargets(v []*DescribeProtocolMountTargetResponseBodyProtocolMountTargets) *DescribeProtocolMountTargetResponseBody {
	s.ProtocolMountTargets = v
	return s
}

func (s *DescribeProtocolMountTargetResponseBody) SetRequestId(v string) *DescribeProtocolMountTargetResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeProtocolMountTargetResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeProtocolMountTargetResponseBodyProtocolMountTargets struct {
	// The permission group that is associated with the export directory of the protocol service.
	//
	// example:
	//
	// DEFAULT_VPC_GROUP_NAME
	AccessGroupName *string `json:"AccessGroupName,omitempty" xml:"AccessGroupName,omitempty"`
	// The time when the export directory of the protocol service was created.
	//
	// example:
	//
	// 2018-12-12T07:28:38Z
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The description of the export directory for the protocol service.
	//
	// example:
	//
	// test
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the export directory for the protocol service.
	//
	// example:
	//
	// exp-19abf5beab8d****
	ExportId *string `json:"ExportId,omitempty" xml:"ExportId,omitempty"`
	// The fileset ID of the export directory for the protocol service.
	//
	// example:
	//
	// fset-1902718ea0ae****
	FsetId *string `json:"FsetId,omitempty" xml:"FsetId,omitempty"`
	// The export directory of the protocol service.
	//
	// example:
	//
	// /path/
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The domain name of the export directory for the protocol service.
	//
	// example:
	//
	// cpfs-123****.cn-hangzhou.cpfs.aliyuncs.com
	ProtocolMountTargetDomain *string `json:"ProtocolMountTargetDomain,omitempty" xml:"ProtocolMountTargetDomain,omitempty"`
	// The ID of the protocol service.
	//
	// example:
	//
	// ptc-123****
	ProtocolServiceId *string `json:"ProtocolServiceId,omitempty" xml:"ProtocolServiceId,omitempty"`
	// The protocol type supported by the protocol service.
	//
	// example:
	//
	// NFS
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The status of the mount target.
	//
	// example:
	//
	// CREATING
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The vSwitch ID of the export directory for the protocol service.
	//
	// example:
	//
	// vsw-2vc3c2lybvdllxyq4****
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The VPC ID of the export directory for the protocol service.
	//
	// example:
	//
	// vpc-2vct297b8157bth9z****
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeProtocolMountTargetResponseBodyProtocolMountTargets) String() string {
	return dara.Prettify(s)
}

func (s DescribeProtocolMountTargetResponseBodyProtocolMountTargets) GoString() string {
	return s.String()
}

func (s *DescribeProtocolMountTargetResponseBodyProtocolMountTargets) GetAccessGroupName() *string {
	return s.AccessGroupName
}

func (s *DescribeProtocolMountTargetResponseBodyProtocolMountTargets) GetCreateTime() *string {
	return s.CreateTime
}

func (s *DescribeProtocolMountTargetResponseBodyProtocolMountTargets) GetDescription() *string {
	return s.Description
}

func (s *DescribeProtocolMountTargetResponseBodyProtocolMountTargets) GetExportId() *string {
	return s.ExportId
}

func (s *DescribeProtocolMountTargetResponseBodyProtocolMountTargets) GetFsetId() *string {
	return s.FsetId
}

func (s *DescribeProtocolMountTargetResponseBodyProtocolMountTargets) GetPath() *string {
	return s.Path
}

func (s *DescribeProtocolMountTargetResponseBodyProtocolMountTargets) GetProtocolMountTargetDomain() *string {
	return s.ProtocolMountTargetDomain
}

func (s *DescribeProtocolMountTargetResponseBodyProtocolMountTargets) GetProtocolServiceId() *string {
	return s.ProtocolServiceId
}

func (s *DescribeProtocolMountTargetResponseBodyProtocolMountTargets) GetProtocolType() *string {
	return s.ProtocolType
}

func (s *DescribeProtocolMountTargetResponseBodyProtocolMountTargets) GetStatus() *string {
	return s.Status
}

func (s *DescribeProtocolMountTargetResponseBodyProtocolMountTargets) GetVSwitchId() *string {
	return s.VSwitchId
}

func (s *DescribeProtocolMountTargetResponseBodyProtocolMountTargets) GetVpcId() *string {
	return s.VpcId
}

func (s *DescribeProtocolMountTargetResponseBodyProtocolMountTargets) SetAccessGroupName(v string) *DescribeProtocolMountTargetResponseBodyProtocolMountTargets {
	s.AccessGroupName = &v
	return s
}

func (s *DescribeProtocolMountTargetResponseBodyProtocolMountTargets) SetCreateTime(v string) *DescribeProtocolMountTargetResponseBodyProtocolMountTargets {
	s.CreateTime = &v
	return s
}

func (s *DescribeProtocolMountTargetResponseBodyProtocolMountTargets) SetDescription(v string) *DescribeProtocolMountTargetResponseBodyProtocolMountTargets {
	s.Description = &v
	return s
}

func (s *DescribeProtocolMountTargetResponseBodyProtocolMountTargets) SetExportId(v string) *DescribeProtocolMountTargetResponseBodyProtocolMountTargets {
	s.ExportId = &v
	return s
}

func (s *DescribeProtocolMountTargetResponseBodyProtocolMountTargets) SetFsetId(v string) *DescribeProtocolMountTargetResponseBodyProtocolMountTargets {
	s.FsetId = &v
	return s
}

func (s *DescribeProtocolMountTargetResponseBodyProtocolMountTargets) SetPath(v string) *DescribeProtocolMountTargetResponseBodyProtocolMountTargets {
	s.Path = &v
	return s
}

func (s *DescribeProtocolMountTargetResponseBodyProtocolMountTargets) SetProtocolMountTargetDomain(v string) *DescribeProtocolMountTargetResponseBodyProtocolMountTargets {
	s.ProtocolMountTargetDomain = &v
	return s
}

func (s *DescribeProtocolMountTargetResponseBodyProtocolMountTargets) SetProtocolServiceId(v string) *DescribeProtocolMountTargetResponseBodyProtocolMountTargets {
	s.ProtocolServiceId = &v
	return s
}

func (s *DescribeProtocolMountTargetResponseBodyProtocolMountTargets) SetProtocolType(v string) *DescribeProtocolMountTargetResponseBodyProtocolMountTargets {
	s.ProtocolType = &v
	return s
}

func (s *DescribeProtocolMountTargetResponseBodyProtocolMountTargets) SetStatus(v string) *DescribeProtocolMountTargetResponseBodyProtocolMountTargets {
	s.Status = &v
	return s
}

func (s *DescribeProtocolMountTargetResponseBodyProtocolMountTargets) SetVSwitchId(v string) *DescribeProtocolMountTargetResponseBodyProtocolMountTargets {
	s.VSwitchId = &v
	return s
}

func (s *DescribeProtocolMountTargetResponseBodyProtocolMountTargets) SetVpcId(v string) *DescribeProtocolMountTargetResponseBodyProtocolMountTargets {
	s.VpcId = &v
	return s
}

func (s *DescribeProtocolMountTargetResponseBodyProtocolMountTargets) Validate() error {
	return dara.Validate(s)
}

type iDescribeProtocolMountTargetResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeProtocolMountTargetResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeProtocolMountTargetResponse
	GetStatusCode() *int32
	SetBody(v *DescribeProtocolMountTargetResponseBody) *DescribeProtocolMountTargetResponse
	GetBody() *DescribeProtocolMountTargetResponseBody
}

type DescribeProtocolMountTargetResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeProtocolMountTargetResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeProtocolMountTargetResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeProtocolMountTargetResponse) GoString() string {
	return s.String()
}

func (s *DescribeProtocolMountTargetResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeProtocolMountTargetResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeProtocolMountTargetResponse) GetBody() *DescribeProtocolMountTargetResponseBody {
	return s.Body
}

func (s *DescribeProtocolMountTargetResponse) SetHeaders(v map[string]*string) *DescribeProtocolMountTargetResponse {
	s.Headers = v
	return s
}

func (s *DescribeProtocolMountTargetResponse) SetStatusCode(v int32) *DescribeProtocolMountTargetResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeProtocolMountTargetResponse) SetBody(v *DescribeProtocolMountTargetResponseBody) *DescribeProtocolMountTargetResponse {
	s.Body = v
	return s
}

func (s *DescribeProtocolMountTargetResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeProtocolServiceRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientToken(v string) *DescribeProtocolServiceRequest
	GetClientToken() *string
	SetDescription(v string) *DescribeProtocolServiceRequest
	GetDescription() *string
	SetFileSystemId(v string) *DescribeProtocolServiceRequest
	GetFileSystemId() *string
	SetMaxResults(v int64) *DescribeProtocolServiceRequest
	GetMaxResults() *int64
	SetNextToken(v string) *DescribeProtocolServiceRequest
	GetNextToken() *string
	SetProtocolServiceIds(v string) *DescribeProtocolServiceRequest
	GetProtocolServiceIds() *string
	SetStatus(v string) *DescribeProtocolServiceRequest
	GetStatus() *string
}

type DescribeProtocolServiceRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// >  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.
	//
	// example:
	//
	// 473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description or a part of the description of the protocol service.
	//
	// Limits:
	//
	// 	- The description must be 2 to 128 characters in length.
	//
	// 	- The description must start with a letter and cannot start with `http://` or `https://`.
	//
	// 	- The description can contain letters, digits, colons (:), underscores (_), and hyphens (-).
	//
	// example:
	//
	// test
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// cpfs-099394bd928c****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The number of results for each query.
	//
	// 	- Maximum value: 100.
	//
	// 	- Minimum value: 10.
	//
	// 	- Default value: 20.
	//
	// example:
	//
	// 20
	MaxResults *int64 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.
	//
	// example:
	//
	// aBcdg==
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the protocol service.
	//
	// 	- Format: CSV.
	//
	// 	- Limit: You can specify a maximum of 10 protocol service IDs.
	//
	// example:
	//
	// ptc-197ed6a00f2b****,ptc-196ed6a00f2b****
	ProtocolServiceIds *string `json:"ProtocolServiceIds,omitempty" xml:"ProtocolServiceIds,omitempty"`
	// The status of the protocol service.
	//
	// Format: CSV.
	//
	// Valid values:
	//
	// 	- Creating: The protocol service is being created.
	//
	// 	- Starting: The protocol service is being started.
	//
	// 	- Running: The protocol service is running.
	//
	// 	- Updating: The protocol service is being updated.
	//
	// 	- Deleting: The protocol service is being deleted.
	//
	// 	- Stopping: The protocol service is being stopped.
	//
	// 	- Stopped: The protocol service is stopped.
	//
	// example:
	//
	// Running,Updating
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeProtocolServiceRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeProtocolServiceRequest) GoString() string {
	return s.String()
}

func (s *DescribeProtocolServiceRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *DescribeProtocolServiceRequest) GetDescription() *string {
	return s.Description
}

func (s *DescribeProtocolServiceRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeProtocolServiceRequest) GetMaxResults() *int64 {
	return s.MaxResults
}

func (s *DescribeProtocolServiceRequest) GetNextToken() *string {
	return s.NextToken
}

func (s *DescribeProtocolServiceRequest) GetProtocolServiceIds() *string {
	return s.ProtocolServiceIds
}

func (s *DescribeProtocolServiceRequest) GetStatus() *string {
	return s.Status
}

func (s *DescribeProtocolServiceRequest) SetClientToken(v string) *DescribeProtocolServiceRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeProtocolServiceRequest) SetDescription(v string) *DescribeProtocolServiceRequest {
	s.Description = &v
	return s
}

func (s *DescribeProtocolServiceRequest) SetFileSystemId(v string) *DescribeProtocolServiceRequest {
	s.FileSystemId = &v
	return s
}

func (s *DescribeProtocolServiceRequest) SetMaxResults(v int64) *DescribeProtocolServiceRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeProtocolServiceRequest) SetNextToken(v string) *DescribeProtocolServiceRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeProtocolServiceRequest) SetProtocolServiceIds(v string) *DescribeProtocolServiceRequest {
	s.ProtocolServiceIds = &v
	return s
}

func (s *DescribeProtocolServiceRequest) SetStatus(v string) *DescribeProtocolServiceRequest {
	s.Status = &v
	return s
}

func (s *DescribeProtocolServiceRequest) Validate() error {
	return dara.Validate(s)
}

type iDescribeProtocolServiceResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetNextToken(v string) *DescribeProtocolServiceResponseBody
	GetNextToken() *string
	SetProtocolServices(v []*DescribeProtocolServiceResponseBodyProtocolServices) *DescribeProtocolServiceResponseBody
	GetProtocolServices() []*DescribeProtocolServiceResponseBodyProtocolServices
	SetRequestId(v string) *DescribeProtocolServiceResponseBody
	GetRequestId() *string
}

type DescribeProtocolServiceResponseBody struct {
	// A pagination token. It can be used in the next request to retrieve a new page of results.
	//
	// example:
	//
	// aBcdeg==
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The information about protocol services.
	ProtocolServices []*DescribeProtocolServiceResponseBodyProtocolServices `json:"ProtocolServices,omitempty" xml:"ProtocolServices,omitempty" type:"Repeated"`
	// The request ID.
	//
	// example:
	//
	// 473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeProtocolServiceResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeProtocolServiceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeProtocolServiceResponseBody) GetNextToken() *string {
	return s.NextToken
}

func (s *DescribeProtocolServiceResponseBody) GetProtocolServices() []*DescribeProtocolServiceResponseBodyProtocolServices {
	return s.ProtocolServices
}

func (s *DescribeProtocolServiceResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeProtocolServiceResponseBody) SetNextToken(v string) *DescribeProtocolServiceResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeProtocolServiceResponseBody) SetProtocolServices(v []*DescribeProtocolServiceResponseBodyProtocolServices) *DescribeProtocolServiceResponseBody {
	s.ProtocolServices = v
	return s
}

func (s *DescribeProtocolServiceResponseBody) SetRequestId(v string) *DescribeProtocolServiceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeProtocolServiceResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeProtocolServiceResponseBodyProtocolServices struct {
	// The time when the protocol service was created. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-12-12T07:28:38Z
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The description of the protocol service.
	//
	// Limits:
	//
	// 	- The description must be 2 to 128 characters in length.
	//
	// 	- The description must start with a letter and cannot start with `http://` or `https://`.
	//
	// 	- The description can contain letters, digits, colons (:), underscores (_), and hyphens (-).
	//
	// example:
	//
	// test
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the file system.
	//
	// example:
	//
	// cpfs-099394bd928c****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The base throughput of the protocol service. Unit: MB/s.
	//
	// example:
	//
	// 100
	InstanceBaseThroughput *int32 `json:"InstanceBaseThroughput,omitempty" xml:"InstanceBaseThroughput,omitempty"`
	// The burst throughput of the protocol service. Unit: MB/s.
	//
	// example:
	//
	// 100
	InstanceBurstThroughput *int32 `json:"InstanceBurstThroughput,omitempty" xml:"InstanceBurstThroughput,omitempty"`
	// The memory cache size of the protocol service. Unit: GiB.
	//
	// example:
	//
	// 0
	InstanceRAM *int32 `json:"InstanceRAM,omitempty" xml:"InstanceRAM,omitempty"`
	// The time when the protocol service was modified. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-12-12T07:28:38Z
	ModifyTime *string `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// The total number of CPFS directories and filesets exported in the protocol service.
	//
	// example:
	//
	// 5
	MountTargetCount *int32 `json:"MountTargetCount,omitempty" xml:"MountTargetCount,omitempty"`
	// The ID of the protocol service.
	//
	// example:
	//
	// ptc-197ed6a00f2b****
	ProtocolServiceId *string `json:"ProtocolServiceId,omitempty" xml:"ProtocolServiceId,omitempty"`
	// The specification of the protocol service.
	//
	// 	- Valid value: General.
	//
	// 	- Default value: General.
	//
	// example:
	//
	// General
	ProtocolSpec *string `json:"ProtocolSpec,omitempty" xml:"ProtocolSpec,omitempty"`
	// The throughput of the protocol service. Unit: MB/s.
	//
	// example:
	//
	// 500
	ProtocolThroughput *int32 `json:"ProtocolThroughput,omitempty" xml:"ProtocolThroughput,omitempty"`
	// The protocol type supported by the protocol service.
	//
	// Valid values:
	//
	// 	- NFS: The protocol service supports access over the Network File System (NFS) protocol.
	//
	// example:
	//
	// NFS
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The status of the protocol service.
	//
	// Valid values:
	//
	// 	- Creating: The protocol service is being created.
	//
	// 	- Starting: The protocol service is being started.
	//
	// 	- Running: The protocol service is running.
	//
	// 	- Updating: The protocol service is being updated.
	//
	// 	- Deleting: The protocol service is being deleted.
	//
	// 	- Stopping: The protocol service is being stopped.
	//
	// 	- Stopped: The protocol service is stopped.
	//
	// example:
	//
	// Running
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeProtocolServiceResponseBodyProtocolServices) String() string {
	return dara.Prettify(s)
}

func (s DescribeProtocolServiceResponseBodyProtocolServices) GoString() string {
	return s.String()
}

func (s *DescribeProtocolServiceResponseBodyProtocolServices) GetCreateTime() *string {
	return s.CreateTime
}

func (s *DescribeProtocolServiceResponseBodyProtocolServices) GetDescription() *string {
	return s.Description
}

func (s *DescribeProtocolServiceResponseBodyProtocolServices) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeProtocolServiceResponseBodyProtocolServices) GetInstanceBaseThroughput() *int32 {
	return s.InstanceBaseThroughput
}

func (s *DescribeProtocolServiceResponseBodyProtocolServices) GetInstanceBurstThroughput() *int32 {
	return s.InstanceBurstThroughput
}

func (s *DescribeProtocolServiceResponseBodyProtocolServices) GetInstanceRAM() *int32 {
	return s.InstanceRAM
}

func (s *DescribeProtocolServiceResponseBodyProtocolServices) GetModifyTime() *string {
	return s.ModifyTime
}

func (s *DescribeProtocolServiceResponseBodyProtocolServices) GetMountTargetCount() *int32 {
	return s.MountTargetCount
}

func (s *DescribeProtocolServiceResponseBodyProtocolServices) GetProtocolServiceId() *string {
	return s.ProtocolServiceId
}

func (s *DescribeProtocolServiceResponseBodyProtocolServices) GetProtocolSpec() *string {
	return s.ProtocolSpec
}

func (s *DescribeProtocolServiceResponseBodyProtocolServices) GetProtocolThroughput() *int32 {
	return s.ProtocolThroughput
}

func (s *DescribeProtocolServiceResponseBodyProtocolServices) GetProtocolType() *string {
	return s.ProtocolType
}

func (s *DescribeProtocolServiceResponseBodyProtocolServices) GetStatus() *string {
	return s.Status
}

func (s *DescribeProtocolServiceResponseBodyProtocolServices) SetCreateTime(v string) *DescribeProtocolServiceResponseBodyProtocolServices {
	s.CreateTime = &v
	return s
}

func (s *DescribeProtocolServiceResponseBodyProtocolServices) SetDescription(v string) *DescribeProtocolServiceResponseBodyProtocolServices {
	s.Description = &v
	return s
}

func (s *DescribeProtocolServiceResponseBodyProtocolServices) SetFileSystemId(v string) *DescribeProtocolServiceResponseBodyProtocolServices {
	s.FileSystemId = &v
	return s
}

func (s *DescribeProtocolServiceResponseBodyProtocolServices) SetInstanceBaseThroughput(v int32) *DescribeProtocolServiceResponseBodyProtocolServices {
	s.InstanceBaseThroughput = &v
	return s
}

func (s *DescribeProtocolServiceResponseBodyProtocolServices) SetInstanceBurstThroughput(v int32) *DescribeProtocolServiceResponseBodyProtocolServices {
	s.InstanceBurstThroughput = &v
	return s
}

func (s *DescribeProtocolServiceResponseBodyProtocolServices) SetInstanceRAM(v int32) *DescribeProtocolServiceResponseBodyProtocolServices {
	s.InstanceRAM = &v
	return s
}

func (s *DescribeProtocolServiceResponseBodyProtocolServices) SetModifyTime(v string) *DescribeProtocolServiceResponseBodyProtocolServices {
	s.ModifyTime = &v
	return s
}

func (s *DescribeProtocolServiceResponseBodyProtocolServices) SetMountTargetCount(v int32) *DescribeProtocolServiceResponseBodyProtocolServices {
	s.MountTargetCount = &v
	return s
}

func (s *DescribeProtocolServiceResponseBodyProtocolServices) SetProtocolServiceId(v string) *DescribeProtocolServiceResponseBodyProtocolServices {
	s.ProtocolServiceId = &v
	return s
}

func (s *DescribeProtocolServiceResponseBodyProtocolServices) SetProtocolSpec(v string) *DescribeProtocolServiceResponseBodyProtocolServices {
	s.ProtocolSpec = &v
	return s
}

func (s *DescribeProtocolServiceResponseBodyProtocolServices) SetProtocolThroughput(v int32) *DescribeProtocolServiceResponseBodyProtocolServices {
	s.ProtocolThroughput = &v
	return s
}

func (s *DescribeProtocolServiceResponseBodyProtocolServices) SetProtocolType(v string) *DescribeProtocolServiceResponseBodyProtocolServices {
	s.ProtocolType = &v
	return s
}

func (s *DescribeProtocolServiceResponseBodyProtocolServices) SetStatus(v string) *DescribeProtocolServiceResponseBodyProtocolServices {
	s.Status = &v
	return s
}

func (s *DescribeProtocolServiceResponseBodyProtocolServices) Validate() error {
	return dara.Validate(s)
}

type iDescribeProtocolServiceResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeProtocolServiceResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeProtocolServiceResponse
	GetStatusCode() *int32
	SetBody(v *DescribeProtocolServiceResponseBody) *DescribeProtocolServiceResponse
	GetBody() *DescribeProtocolServiceResponseBody
}

type DescribeProtocolServiceResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeProtocolServiceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeProtocolServiceResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeProtocolServiceResponse) GoString() string {
	return s.String()
}

func (s *DescribeProtocolServiceResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeProtocolServiceResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeProtocolServiceResponse) GetBody() *DescribeProtocolServiceResponseBody {
	return s.Body
}

func (s *DescribeProtocolServiceResponse) SetHeaders(v map[string]*string) *DescribeProtocolServiceResponse {
	s.Headers = v
	return s
}

func (s *DescribeProtocolServiceResponse) SetStatusCode(v int32) *DescribeProtocolServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeProtocolServiceResponse) SetBody(v *DescribeProtocolServiceResponseBody) *DescribeProtocolServiceResponse {
	s.Body = v
	return s
}

func (s *DescribeProtocolServiceResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeRegionsRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemType(v string) *DescribeRegionsRequest
	GetFileSystemType() *string
	SetPageNumber(v int32) *DescribeRegionsRequest
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeRegionsRequest
	GetPageSize() *int32
}

type DescribeRegionsRequest struct {
	// The type of the file system.
	//
	// Valid values:
	//
	// 	- all: all types of file systems
	//
	// 	- standard (default): General-purpose NAS file system
	//
	// 	- extreme: Extreme NAS file system
	//
	// 	- cpfs: Cloud Parallel File Storage (CPFS) file system
	//
	// > CPFS file systems are available only on the China site (aliyun.com).
	//
	// example:
	//
	// standard
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
	// The page number.
	//
	// Pages start from page 1. Default value: 1.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	//
	// Valid values: 1 to 100.
	//
	// Default value: 10.
	//
	// example:
	//
	// 10
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribeRegionsRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeRegionsRequest) GoString() string {
	return s.String()
}

func (s *DescribeRegionsRequest) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *DescribeRegionsRequest) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeRegionsRequest) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeRegionsRequest) SetFileSystemType(v string) *DescribeRegionsRequest {
	s.FileSystemType = &v
	return s
}

func (s *DescribeRegionsRequest) SetPageNumber(v int32) *DescribeRegionsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeRegionsRequest) SetPageSize(v int32) *DescribeRegionsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeRegionsRequest) Validate() error {
	return dara.Validate(s)
}

type iDescribeRegionsResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetPageNumber(v int32) *DescribeRegionsResponseBody
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeRegionsResponseBody
	GetPageSize() *int32
	SetRegions(v *DescribeRegionsResponseBodyRegions) *DescribeRegionsResponseBody
	GetRegions() *DescribeRegionsResponseBodyRegions
	SetRequestId(v string) *DescribeRegionsResponseBody
	GetRequestId() *string
	SetTotalCount(v int32) *DescribeRegionsResponseBody
	GetTotalCount() *int32
}

type DescribeRegionsResponseBody struct {
	// The page number.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	//
	// example:
	//
	// 10
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The queried regions.
	Regions *DescribeRegionsResponseBodyRegions `json:"Regions,omitempty" xml:"Regions,omitempty" type:"Struct"`
	// The request ID.
	//
	// example:
	//
	// A70BEE5D-76D3-49FB-B58F-1F398211****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	//
	// example:
	//
	// 1
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeRegionsResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeRegionsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponseBody) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeRegionsResponseBody) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeRegionsResponseBody) GetRegions() *DescribeRegionsResponseBodyRegions {
	return s.Regions
}

func (s *DescribeRegionsResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeRegionsResponseBody) GetTotalCount() *int32 {
	return s.TotalCount
}

func (s *DescribeRegionsResponseBody) SetPageNumber(v int32) *DescribeRegionsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeRegionsResponseBody) SetPageSize(v int32) *DescribeRegionsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeRegionsResponseBody) SetRegions(v *DescribeRegionsResponseBodyRegions) *DescribeRegionsResponseBody {
	s.Regions = v
	return s
}

func (s *DescribeRegionsResponseBody) SetRequestId(v string) *DescribeRegionsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeRegionsResponseBody) SetTotalCount(v int32) *DescribeRegionsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeRegionsResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeRegionsResponseBodyRegions struct {
	Region []*DescribeRegionsResponseBodyRegionsRegion `json:"Region,omitempty" xml:"Region,omitempty" type:"Repeated"`
}

func (s DescribeRegionsResponseBodyRegions) String() string {
	return dara.Prettify(s)
}

func (s DescribeRegionsResponseBodyRegions) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponseBodyRegions) GetRegion() []*DescribeRegionsResponseBodyRegionsRegion {
	return s.Region
}

func (s *DescribeRegionsResponseBodyRegions) SetRegion(v []*DescribeRegionsResponseBodyRegionsRegion) *DescribeRegionsResponseBodyRegions {
	s.Region = v
	return s
}

func (s *DescribeRegionsResponseBodyRegions) Validate() error {
	return dara.Validate(s)
}

type DescribeRegionsResponseBodyRegionsRegion struct {
	// The region name.
	//
	// example:
	//
	// East China 1
	LocalName *string `json:"LocalName,omitempty" xml:"LocalName,omitempty"`
	// The endpoint for the region.
	//
	// example:
	//
	// nas.cn-hangzhou.aliyuncs.com
	RegionEndpoint *string `json:"RegionEndpoint,omitempty" xml:"RegionEndpoint,omitempty"`
	// The region ID.
	//
	// example:
	//
	// cn-hangzhou
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeRegionsResponseBodyRegionsRegion) String() string {
	return dara.Prettify(s)
}

func (s DescribeRegionsResponseBodyRegionsRegion) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponseBodyRegionsRegion) GetLocalName() *string {
	return s.LocalName
}

func (s *DescribeRegionsResponseBodyRegionsRegion) GetRegionEndpoint() *string {
	return s.RegionEndpoint
}

func (s *DescribeRegionsResponseBodyRegionsRegion) GetRegionId() *string {
	return s.RegionId
}

func (s *DescribeRegionsResponseBodyRegionsRegion) SetLocalName(v string) *DescribeRegionsResponseBodyRegionsRegion {
	s.LocalName = &v
	return s
}

func (s *DescribeRegionsResponseBodyRegionsRegion) SetRegionEndpoint(v string) *DescribeRegionsResponseBodyRegionsRegion {
	s.RegionEndpoint = &v
	return s
}

func (s *DescribeRegionsResponseBodyRegionsRegion) SetRegionId(v string) *DescribeRegionsResponseBodyRegionsRegion {
	s.RegionId = &v
	return s
}

func (s *DescribeRegionsResponseBodyRegionsRegion) Validate() error {
	return dara.Validate(s)
}

type iDescribeRegionsResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeRegionsResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeRegionsResponse
	GetStatusCode() *int32
	SetBody(v *DescribeRegionsResponseBody) *DescribeRegionsResponse
	GetBody() *DescribeRegionsResponseBody
}

type DescribeRegionsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeRegionsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeRegionsResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeRegionsResponse) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeRegionsResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeRegionsResponse) GetBody() *DescribeRegionsResponseBody {
	return s.Body
}

func (s *DescribeRegionsResponse) SetHeaders(v map[string]*string) *DescribeRegionsResponse {
	s.Headers = v
	return s
}

func (s *DescribeRegionsResponse) SetStatusCode(v int32) *DescribeRegionsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRegionsResponse) SetBody(v *DescribeRegionsResponseBody) *DescribeRegionsResponse {
	s.Body = v
	return s
}

func (s *DescribeRegionsResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeResourceStatisticsRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemType(v string) *DescribeResourceStatisticsRequest
	GetFileSystemType() *string
	SetPageNumber(v int32) *DescribeResourceStatisticsRequest
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeResourceStatisticsRequest
	GetPageSize() *int32
	SetRegionId(v string) *DescribeResourceStatisticsRequest
	GetRegionId() *string
}

type DescribeResourceStatisticsRequest struct {
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
	PageNumber     *int32  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize       *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RegionId       *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeResourceStatisticsRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeResourceStatisticsRequest) GoString() string {
	return s.String()
}

func (s *DescribeResourceStatisticsRequest) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *DescribeResourceStatisticsRequest) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeResourceStatisticsRequest) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeResourceStatisticsRequest) GetRegionId() *string {
	return s.RegionId
}

func (s *DescribeResourceStatisticsRequest) SetFileSystemType(v string) *DescribeResourceStatisticsRequest {
	s.FileSystemType = &v
	return s
}

func (s *DescribeResourceStatisticsRequest) SetPageNumber(v int32) *DescribeResourceStatisticsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeResourceStatisticsRequest) SetPageSize(v int32) *DescribeResourceStatisticsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeResourceStatisticsRequest) SetRegionId(v string) *DescribeResourceStatisticsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeResourceStatisticsRequest) Validate() error {
	return dara.Validate(s)
}

type iDescribeResourceStatisticsResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemStatistics(v []*DescribeResourceStatisticsResponseBodyFileSystemStatistics) *DescribeResourceStatisticsResponseBody
	GetFileSystemStatistics() []*DescribeResourceStatisticsResponseBodyFileSystemStatistics
	SetFileSystems(v []*DescribeResourceStatisticsResponseBodyFileSystems) *DescribeResourceStatisticsResponseBody
	GetFileSystems() []*DescribeResourceStatisticsResponseBodyFileSystems
	SetPageNumber(v int32) *DescribeResourceStatisticsResponseBody
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeResourceStatisticsResponseBody
	GetPageSize() *int32
	SetRequestId(v string) *DescribeResourceStatisticsResponseBody
	GetRequestId() *string
	SetTotalCount(v int32) *DescribeResourceStatisticsResponseBody
	GetTotalCount() *int32
}

type DescribeResourceStatisticsResponseBody struct {
	FileSystemStatistics []*DescribeResourceStatisticsResponseBodyFileSystemStatistics `json:"FileSystemStatistics,omitempty" xml:"FileSystemStatistics,omitempty" type:"Repeated"`
	FileSystems          []*DescribeResourceStatisticsResponseBodyFileSystems          `json:"FileSystems,omitempty" xml:"FileSystems,omitempty" type:"Repeated"`
	PageNumber           *int32                                                        `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize             *int32                                                        `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RequestId            *string                                                       `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TotalCount           *int32                                                        `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeResourceStatisticsResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeResourceStatisticsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeResourceStatisticsResponseBody) GetFileSystemStatistics() []*DescribeResourceStatisticsResponseBodyFileSystemStatistics {
	return s.FileSystemStatistics
}

func (s *DescribeResourceStatisticsResponseBody) GetFileSystems() []*DescribeResourceStatisticsResponseBodyFileSystems {
	return s.FileSystems
}

func (s *DescribeResourceStatisticsResponseBody) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeResourceStatisticsResponseBody) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeResourceStatisticsResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeResourceStatisticsResponseBody) GetTotalCount() *int32 {
	return s.TotalCount
}

func (s *DescribeResourceStatisticsResponseBody) SetFileSystemStatistics(v []*DescribeResourceStatisticsResponseBodyFileSystemStatistics) *DescribeResourceStatisticsResponseBody {
	s.FileSystemStatistics = v
	return s
}

func (s *DescribeResourceStatisticsResponseBody) SetFileSystems(v []*DescribeResourceStatisticsResponseBodyFileSystems) *DescribeResourceStatisticsResponseBody {
	s.FileSystems = v
	return s
}

func (s *DescribeResourceStatisticsResponseBody) SetPageNumber(v int32) *DescribeResourceStatisticsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBody) SetPageSize(v int32) *DescribeResourceStatisticsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBody) SetRequestId(v string) *DescribeResourceStatisticsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBody) SetTotalCount(v int32) *DescribeResourceStatisticsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeResourceStatisticsResponseBodyFileSystemStatistics struct {
	BM_ADVANCE_400_Capacity       *int64                                                                                `json:"BM_ADVANCE_400_Capacity,omitempty" xml:"BM_ADVANCE_400_Capacity,omitempty"`
	BM_ADVANCE_400_LARGE_Capacity *int64                                                                                `json:"BM_ADVANCE_400_LARGE_Capacity,omitempty" xml:"BM_ADVANCE_400_LARGE_Capacity,omitempty"`
	CPFSProtocolServiceThroughput *int64                                                                                `json:"CPFSProtocolServiceThroughput,omitempty" xml:"CPFSProtocolServiceThroughput,omitempty"`
	CPFS_100_Capacity             *int64                                                                                `json:"CPFS_100_Capacity,omitempty" xml:"CPFS_100_Capacity,omitempty"`
	CPFS_200_Capacity             *int64                                                                                `json:"CPFS_200_Capacity,omitempty" xml:"CPFS_200_Capacity,omitempty"`
	CPFS_Throughput               *int64                                                                                `json:"CPFS_Throughput,omitempty" xml:"CPFS_Throughput,omitempty"`
	CapacityMeteredSize           *int64                                                                                `json:"CapacityMeteredSize,omitempty" xml:"CapacityMeteredSize,omitempty"`
	DcpfsExtremeNodeNum           *int32                                                                                `json:"DcpfsExtremeNodeNum,omitempty" xml:"DcpfsExtremeNodeNum,omitempty"`
	ExtremeAdvanceCapacity        *int64                                                                                `json:"ExtremeAdvanceCapacity,omitempty" xml:"ExtremeAdvanceCapacity,omitempty"`
	ExtremeCapacity               *int64                                                                                `json:"ExtremeCapacity,omitempty" xml:"ExtremeCapacity,omitempty"`
	ExtremeStandardCapacity       *int64                                                                                `json:"ExtremeStandardCapacity,omitempty" xml:"ExtremeStandardCapacity,omitempty"`
	FileSystemType                *string                                                                               `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
	MeteredArchiveSize            *int64                                                                                `json:"MeteredArchiveSize,omitempty" xml:"MeteredArchiveSize,omitempty"`
	MeteredIASize                 *int64                                                                                `json:"MeteredIASize,omitempty" xml:"MeteredIASize,omitempty"`
	MonthIArwSize                 *int64                                                                                `json:"MonthIArwSize,omitempty" xml:"MonthIArwSize,omitempty"`
	PerformanceMeteredSize        *int64                                                                                `json:"PerformanceMeteredSize,omitempty" xml:"PerformanceMeteredSize,omitempty"`
	PremiumMeteredSize            *int64                                                                                `json:"PremiumMeteredSize,omitempty" xml:"PremiumMeteredSize,omitempty"`
	StoragePackageStatistics      []*DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics `json:"StoragePackageStatistics,omitempty" xml:"StoragePackageStatistics,omitempty" type:"Repeated"`
	TotalCount                    *int32                                                                                `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeResourceStatisticsResponseBodyFileSystemStatistics) String() string {
	return dara.Prettify(s)
}

func (s DescribeResourceStatisticsResponseBodyFileSystemStatistics) GoString() string {
	return s.String()
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) GetBM_ADVANCE_400_Capacity() *int64 {
	return s.BM_ADVANCE_400_Capacity
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) GetBM_ADVANCE_400_LARGE_Capacity() *int64 {
	return s.BM_ADVANCE_400_LARGE_Capacity
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) GetCPFSProtocolServiceThroughput() *int64 {
	return s.CPFSProtocolServiceThroughput
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) GetCPFS_100_Capacity() *int64 {
	return s.CPFS_100_Capacity
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) GetCPFS_200_Capacity() *int64 {
	return s.CPFS_200_Capacity
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) GetCPFS_Throughput() *int64 {
	return s.CPFS_Throughput
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) GetCapacityMeteredSize() *int64 {
	return s.CapacityMeteredSize
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) GetDcpfsExtremeNodeNum() *int32 {
	return s.DcpfsExtremeNodeNum
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) GetExtremeAdvanceCapacity() *int64 {
	return s.ExtremeAdvanceCapacity
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) GetExtremeCapacity() *int64 {
	return s.ExtremeCapacity
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) GetExtremeStandardCapacity() *int64 {
	return s.ExtremeStandardCapacity
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) GetMeteredArchiveSize() *int64 {
	return s.MeteredArchiveSize
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) GetMeteredIASize() *int64 {
	return s.MeteredIASize
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) GetMonthIArwSize() *int64 {
	return s.MonthIArwSize
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) GetPerformanceMeteredSize() *int64 {
	return s.PerformanceMeteredSize
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) GetPremiumMeteredSize() *int64 {
	return s.PremiumMeteredSize
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) GetStoragePackageStatistics() []*DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics {
	return s.StoragePackageStatistics
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) GetTotalCount() *int32 {
	return s.TotalCount
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) SetBM_ADVANCE_400_Capacity(v int64) *DescribeResourceStatisticsResponseBodyFileSystemStatistics {
	s.BM_ADVANCE_400_Capacity = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) SetBM_ADVANCE_400_LARGE_Capacity(v int64) *DescribeResourceStatisticsResponseBodyFileSystemStatistics {
	s.BM_ADVANCE_400_LARGE_Capacity = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) SetCPFSProtocolServiceThroughput(v int64) *DescribeResourceStatisticsResponseBodyFileSystemStatistics {
	s.CPFSProtocolServiceThroughput = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) SetCPFS_100_Capacity(v int64) *DescribeResourceStatisticsResponseBodyFileSystemStatistics {
	s.CPFS_100_Capacity = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) SetCPFS_200_Capacity(v int64) *DescribeResourceStatisticsResponseBodyFileSystemStatistics {
	s.CPFS_200_Capacity = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) SetCPFS_Throughput(v int64) *DescribeResourceStatisticsResponseBodyFileSystemStatistics {
	s.CPFS_Throughput = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) SetCapacityMeteredSize(v int64) *DescribeResourceStatisticsResponseBodyFileSystemStatistics {
	s.CapacityMeteredSize = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) SetDcpfsExtremeNodeNum(v int32) *DescribeResourceStatisticsResponseBodyFileSystemStatistics {
	s.DcpfsExtremeNodeNum = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) SetExtremeAdvanceCapacity(v int64) *DescribeResourceStatisticsResponseBodyFileSystemStatistics {
	s.ExtremeAdvanceCapacity = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) SetExtremeCapacity(v int64) *DescribeResourceStatisticsResponseBodyFileSystemStatistics {
	s.ExtremeCapacity = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) SetExtremeStandardCapacity(v int64) *DescribeResourceStatisticsResponseBodyFileSystemStatistics {
	s.ExtremeStandardCapacity = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) SetFileSystemType(v string) *DescribeResourceStatisticsResponseBodyFileSystemStatistics {
	s.FileSystemType = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) SetMeteredArchiveSize(v int64) *DescribeResourceStatisticsResponseBodyFileSystemStatistics {
	s.MeteredArchiveSize = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) SetMeteredIASize(v int64) *DescribeResourceStatisticsResponseBodyFileSystemStatistics {
	s.MeteredIASize = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) SetMonthIArwSize(v int64) *DescribeResourceStatisticsResponseBodyFileSystemStatistics {
	s.MonthIArwSize = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) SetPerformanceMeteredSize(v int64) *DescribeResourceStatisticsResponseBodyFileSystemStatistics {
	s.PerformanceMeteredSize = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) SetPremiumMeteredSize(v int64) *DescribeResourceStatisticsResponseBodyFileSystemStatistics {
	s.PremiumMeteredSize = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) SetStoragePackageStatistics(v []*DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) *DescribeResourceStatisticsResponseBodyFileSystemStatistics {
	s.StoragePackageStatistics = v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) SetTotalCount(v int32) *DescribeResourceStatisticsResponseBodyFileSystemStatistics {
	s.TotalCount = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatistics) Validate() error {
	return dara.Validate(s)
}

type DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics struct {
	BoundFileSystemID       *string `json:"BoundFileSystemID,omitempty" xml:"BoundFileSystemID,omitempty"`
	BoundMeteredIASize      *int64  `json:"BoundMeteredIASize,omitempty" xml:"BoundMeteredIASize,omitempty"`
	BoundMeteredSize        *int64  `json:"BoundMeteredSize,omitempty" xml:"BoundMeteredSize,omitempty"`
	BoundMonthIArwSize      *int64  `json:"BoundMonthIArwSize,omitempty" xml:"BoundMonthIArwSize,omitempty"`
	EndTime                 *int64  `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	StartTime               *int64  `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	StoragePackageID        *string `json:"StoragePackageID,omitempty" xml:"StoragePackageID,omitempty"`
	StoragePackageSize      *int64  `json:"StoragePackageSize,omitempty" xml:"StoragePackageSize,omitempty"`
	StoragePackageStatus    *string `json:"StoragePackageStatus,omitempty" xml:"StoragePackageStatus,omitempty"`
	StoragePackageType      *string `json:"StoragePackageType,omitempty" xml:"StoragePackageType,omitempty"`
	UndeductedMeteredIASize *int64  `json:"UndeductedMeteredIASize,omitempty" xml:"UndeductedMeteredIASize,omitempty"`
	UndeductedMeteredSize   *int64  `json:"UndeductedMeteredSize,omitempty" xml:"UndeductedMeteredSize,omitempty"`
}

func (s DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) String() string {
	return dara.Prettify(s)
}

func (s DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) GoString() string {
	return s.String()
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) GetBoundFileSystemID() *string {
	return s.BoundFileSystemID
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) GetBoundMeteredIASize() *int64 {
	return s.BoundMeteredIASize
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) GetBoundMeteredSize() *int64 {
	return s.BoundMeteredSize
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) GetBoundMonthIArwSize() *int64 {
	return s.BoundMonthIArwSize
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) GetEndTime() *int64 {
	return s.EndTime
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) GetStartTime() *int64 {
	return s.StartTime
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) GetStoragePackageID() *string {
	return s.StoragePackageID
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) GetStoragePackageSize() *int64 {
	return s.StoragePackageSize
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) GetStoragePackageStatus() *string {
	return s.StoragePackageStatus
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) GetStoragePackageType() *string {
	return s.StoragePackageType
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) GetUndeductedMeteredIASize() *int64 {
	return s.UndeductedMeteredIASize
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) GetUndeductedMeteredSize() *int64 {
	return s.UndeductedMeteredSize
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) SetBoundFileSystemID(v string) *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics {
	s.BoundFileSystemID = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) SetBoundMeteredIASize(v int64) *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics {
	s.BoundMeteredIASize = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) SetBoundMeteredSize(v int64) *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics {
	s.BoundMeteredSize = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) SetBoundMonthIArwSize(v int64) *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics {
	s.BoundMonthIArwSize = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) SetEndTime(v int64) *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics {
	s.EndTime = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) SetStartTime(v int64) *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics {
	s.StartTime = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) SetStoragePackageID(v string) *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics {
	s.StoragePackageID = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) SetStoragePackageSize(v int64) *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics {
	s.StoragePackageSize = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) SetStoragePackageStatus(v string) *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics {
	s.StoragePackageStatus = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) SetStoragePackageType(v string) *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics {
	s.StoragePackageType = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) SetUndeductedMeteredIASize(v int64) *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics {
	s.UndeductedMeteredIASize = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) SetUndeductedMeteredSize(v int64) *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics {
	s.UndeductedMeteredSize = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemStatisticsStoragePackageStatistics) Validate() error {
	return dara.Validate(s)
}

type DescribeResourceStatisticsResponseBodyFileSystems struct {
	Capacity           *int64                                                       `json:"Capacity,omitempty" xml:"Capacity,omitempty"`
	ChargeType         *string                                                      `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	CreateTime         *string                                                      `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	Description        *string                                                      `json:"Description,omitempty" xml:"Description,omitempty"`
	ExpiredTime        *string                                                      `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	FileSystemId       *string                                                      `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	FileSystemType     *string                                                      `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
	MeteredArchiveSize *int64                                                       `json:"MeteredArchiveSize,omitempty" xml:"MeteredArchiveSize,omitempty"`
	MeteredIASize      *int64                                                       `json:"MeteredIASize,omitempty" xml:"MeteredIASize,omitempty"`
	MeteredSize        *int64                                                       `json:"MeteredSize,omitempty" xml:"MeteredSize,omitempty"`
	Packages           []*DescribeResourceStatisticsResponseBodyFileSystemsPackages `json:"Packages,omitempty" xml:"Packages,omitempty" type:"Repeated"`
	ProtocolType       *string                                                      `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	RegionId           *string                                                      `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	Status             *string                                                      `json:"Status,omitempty" xml:"Status,omitempty"`
	StorageType        *string                                                      `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
	ZoneId             *string                                                      `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeResourceStatisticsResponseBodyFileSystems) String() string {
	return dara.Prettify(s)
}

func (s DescribeResourceStatisticsResponseBodyFileSystems) GoString() string {
	return s.String()
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) GetCapacity() *int64 {
	return s.Capacity
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) GetChargeType() *string {
	return s.ChargeType
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) GetCreateTime() *string {
	return s.CreateTime
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) GetDescription() *string {
	return s.Description
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) GetExpiredTime() *string {
	return s.ExpiredTime
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) GetMeteredArchiveSize() *int64 {
	return s.MeteredArchiveSize
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) GetMeteredIASize() *int64 {
	return s.MeteredIASize
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) GetMeteredSize() *int64 {
	return s.MeteredSize
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) GetPackages() []*DescribeResourceStatisticsResponseBodyFileSystemsPackages {
	return s.Packages
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) GetProtocolType() *string {
	return s.ProtocolType
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) GetRegionId() *string {
	return s.RegionId
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) GetStatus() *string {
	return s.Status
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) GetStorageType() *string {
	return s.StorageType
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) GetZoneId() *string {
	return s.ZoneId
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) SetCapacity(v int64) *DescribeResourceStatisticsResponseBodyFileSystems {
	s.Capacity = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) SetChargeType(v string) *DescribeResourceStatisticsResponseBodyFileSystems {
	s.ChargeType = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) SetCreateTime(v string) *DescribeResourceStatisticsResponseBodyFileSystems {
	s.CreateTime = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) SetDescription(v string) *DescribeResourceStatisticsResponseBodyFileSystems {
	s.Description = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) SetExpiredTime(v string) *DescribeResourceStatisticsResponseBodyFileSystems {
	s.ExpiredTime = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) SetFileSystemId(v string) *DescribeResourceStatisticsResponseBodyFileSystems {
	s.FileSystemId = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) SetFileSystemType(v string) *DescribeResourceStatisticsResponseBodyFileSystems {
	s.FileSystemType = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) SetMeteredArchiveSize(v int64) *DescribeResourceStatisticsResponseBodyFileSystems {
	s.MeteredArchiveSize = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) SetMeteredIASize(v int64) *DescribeResourceStatisticsResponseBodyFileSystems {
	s.MeteredIASize = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) SetMeteredSize(v int64) *DescribeResourceStatisticsResponseBodyFileSystems {
	s.MeteredSize = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) SetPackages(v []*DescribeResourceStatisticsResponseBodyFileSystemsPackages) *DescribeResourceStatisticsResponseBodyFileSystems {
	s.Packages = v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) SetProtocolType(v string) *DescribeResourceStatisticsResponseBodyFileSystems {
	s.ProtocolType = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) SetRegionId(v string) *DescribeResourceStatisticsResponseBodyFileSystems {
	s.RegionId = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) SetStatus(v string) *DescribeResourceStatisticsResponseBodyFileSystems {
	s.Status = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) SetStorageType(v string) *DescribeResourceStatisticsResponseBodyFileSystems {
	s.StorageType = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) SetZoneId(v string) *DescribeResourceStatisticsResponseBodyFileSystems {
	s.ZoneId = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystems) Validate() error {
	return dara.Validate(s)
}

type DescribeResourceStatisticsResponseBodyFileSystemsPackages struct {
	ExpiredTime *string `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	PackageId   *string `json:"PackageId,omitempty" xml:"PackageId,omitempty"`
	Size        *int64  `json:"Size,omitempty" xml:"Size,omitempty"`
	StartTime   *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeResourceStatisticsResponseBodyFileSystemsPackages) String() string {
	return dara.Prettify(s)
}

func (s DescribeResourceStatisticsResponseBodyFileSystemsPackages) GoString() string {
	return s.String()
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemsPackages) GetExpiredTime() *string {
	return s.ExpiredTime
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemsPackages) GetPackageId() *string {
	return s.PackageId
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemsPackages) GetSize() *int64 {
	return s.Size
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemsPackages) GetStartTime() *string {
	return s.StartTime
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemsPackages) SetExpiredTime(v string) *DescribeResourceStatisticsResponseBodyFileSystemsPackages {
	s.ExpiredTime = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemsPackages) SetPackageId(v string) *DescribeResourceStatisticsResponseBodyFileSystemsPackages {
	s.PackageId = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemsPackages) SetSize(v int64) *DescribeResourceStatisticsResponseBodyFileSystemsPackages {
	s.Size = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemsPackages) SetStartTime(v string) *DescribeResourceStatisticsResponseBodyFileSystemsPackages {
	s.StartTime = &v
	return s
}

func (s *DescribeResourceStatisticsResponseBodyFileSystemsPackages) Validate() error {
	return dara.Validate(s)
}

type iDescribeResourceStatisticsResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeResourceStatisticsResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeResourceStatisticsResponse
	GetStatusCode() *int32
	SetBody(v *DescribeResourceStatisticsResponseBody) *DescribeResourceStatisticsResponse
	GetBody() *DescribeResourceStatisticsResponseBody
}

type DescribeResourceStatisticsResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeResourceStatisticsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeResourceStatisticsResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeResourceStatisticsResponse) GoString() string {
	return s.String()
}

func (s *DescribeResourceStatisticsResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeResourceStatisticsResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeResourceStatisticsResponse) GetBody() *DescribeResourceStatisticsResponseBody {
	return s.Body
}

func (s *DescribeResourceStatisticsResponse) SetHeaders(v map[string]*string) *DescribeResourceStatisticsResponse {
	s.Headers = v
	return s
}

func (s *DescribeResourceStatisticsResponse) SetStatusCode(v int32) *DescribeResourceStatisticsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeResourceStatisticsResponse) SetBody(v *DescribeResourceStatisticsResponseBody) *DescribeResourceStatisticsResponse {
	s.Body = v
	return s
}

func (s *DescribeResourceStatisticsResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeSmbAclRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *DescribeSmbAclRequest
	GetFileSystemId() *string
}

type DescribeSmbAclRequest struct {
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 31a8e4****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
}

func (s DescribeSmbAclRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeSmbAclRequest) GoString() string {
	return s.String()
}

func (s *DescribeSmbAclRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeSmbAclRequest) SetFileSystemId(v string) *DescribeSmbAclRequest {
	s.FileSystemId = &v
	return s
}

func (s *DescribeSmbAclRequest) Validate() error {
	return dara.Validate(s)
}

type iDescribeSmbAclResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetAcl(v *DescribeSmbAclResponseBodyAcl) *DescribeSmbAclResponseBody
	GetAcl() *DescribeSmbAclResponseBodyAcl
	SetRequestId(v string) *DescribeSmbAclResponseBody
	GetRequestId() *string
}

type DescribeSmbAclResponseBody struct {
	// The information about the ACL feature.
	Acl *DescribeSmbAclResponseBodyAcl `json:"Acl,omitempty" xml:"Acl,omitempty" type:"Struct"`
	// The request ID.
	//
	// example:
	//
	// 98696EF0-1607-4E9D-B01D-F20930B6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeSmbAclResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeSmbAclResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSmbAclResponseBody) GetAcl() *DescribeSmbAclResponseBodyAcl {
	return s.Acl
}

func (s *DescribeSmbAclResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeSmbAclResponseBody) SetAcl(v *DescribeSmbAclResponseBodyAcl) *DescribeSmbAclResponseBody {
	s.Acl = v
	return s
}

func (s *DescribeSmbAclResponseBody) SetRequestId(v string) *DescribeSmbAclResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSmbAclResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeSmbAclResponseBodyAcl struct {
	AuthCenter *string `json:"AuthCenter,omitempty" xml:"AuthCenter,omitempty"`
	AuthMethod *string `json:"AuthMethod,omitempty" xml:"AuthMethod,omitempty"`
	// Indicates whether the file system allows anonymous access. Valid values:
	//
	// 	- true: The file system allows anonymous access.
	//
	// 	- false: The file system does not allow anonymous access.
	//
	// example:
	//
	// true
	EnableAnonymousAccess *bool `json:"EnableAnonymousAccess,omitempty" xml:"EnableAnonymousAccess,omitempty"`
	// Indicates whether the ACL feature is enabled. Valid values:
	//
	// 	- true: The ACL feature is enabled.
	//
	// 	- false: The ACL feature is disabled.
	//
	// example:
	//
	// true
	Enabled *bool `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// Indicates whether encryption in transit is enabled. Valid values:
	//
	// 	- true: Encryption in transit is enabled.
	//
	// 	- false: Encryption in transit is disabled.
	//
	// example:
	//
	// true
	EncryptData *bool `json:"EncryptData,omitempty" xml:"EncryptData,omitempty"`
	// The home directory of each user.
	//
	// example:
	//
	// /home
	HomeDirPath *string `json:"HomeDirPath,omitempty" xml:"HomeDirPath,omitempty"`
	// Indicates whether the file system denies access from non-encrypted clients. Valid values:
	//
	// 	- true: The file system denies access from non-encrypted clients.
	//
	// 	- false: The file system allows access from non-encrypted clients.
	//
	// example:
	//
	// true
	RejectUnencryptedAccess *bool `json:"RejectUnencryptedAccess,omitempty" xml:"RejectUnencryptedAccess,omitempty"`
	// The ID of a super admin.
	//
	// example:
	//
	// S-1-0-0
	SuperAdminSid *string `json:"SuperAdminSid,omitempty" xml:"SuperAdminSid,omitempty"`
}

func (s DescribeSmbAclResponseBodyAcl) String() string {
	return dara.Prettify(s)
}

func (s DescribeSmbAclResponseBodyAcl) GoString() string {
	return s.String()
}

func (s *DescribeSmbAclResponseBodyAcl) GetAuthCenter() *string {
	return s.AuthCenter
}

func (s *DescribeSmbAclResponseBodyAcl) GetAuthMethod() *string {
	return s.AuthMethod
}

func (s *DescribeSmbAclResponseBodyAcl) GetEnableAnonymousAccess() *bool {
	return s.EnableAnonymousAccess
}

func (s *DescribeSmbAclResponseBodyAcl) GetEnabled() *bool {
	return s.Enabled
}

func (s *DescribeSmbAclResponseBodyAcl) GetEncryptData() *bool {
	return s.EncryptData
}

func (s *DescribeSmbAclResponseBodyAcl) GetHomeDirPath() *string {
	return s.HomeDirPath
}

func (s *DescribeSmbAclResponseBodyAcl) GetRejectUnencryptedAccess() *bool {
	return s.RejectUnencryptedAccess
}

func (s *DescribeSmbAclResponseBodyAcl) GetSuperAdminSid() *string {
	return s.SuperAdminSid
}

func (s *DescribeSmbAclResponseBodyAcl) SetAuthCenter(v string) *DescribeSmbAclResponseBodyAcl {
	s.AuthCenter = &v
	return s
}

func (s *DescribeSmbAclResponseBodyAcl) SetAuthMethod(v string) *DescribeSmbAclResponseBodyAcl {
	s.AuthMethod = &v
	return s
}

func (s *DescribeSmbAclResponseBodyAcl) SetEnableAnonymousAccess(v bool) *DescribeSmbAclResponseBodyAcl {
	s.EnableAnonymousAccess = &v
	return s
}

func (s *DescribeSmbAclResponseBodyAcl) SetEnabled(v bool) *DescribeSmbAclResponseBodyAcl {
	s.Enabled = &v
	return s
}

func (s *DescribeSmbAclResponseBodyAcl) SetEncryptData(v bool) *DescribeSmbAclResponseBodyAcl {
	s.EncryptData = &v
	return s
}

func (s *DescribeSmbAclResponseBodyAcl) SetHomeDirPath(v string) *DescribeSmbAclResponseBodyAcl {
	s.HomeDirPath = &v
	return s
}

func (s *DescribeSmbAclResponseBodyAcl) SetRejectUnencryptedAccess(v bool) *DescribeSmbAclResponseBodyAcl {
	s.RejectUnencryptedAccess = &v
	return s
}

func (s *DescribeSmbAclResponseBodyAcl) SetSuperAdminSid(v string) *DescribeSmbAclResponseBodyAcl {
	s.SuperAdminSid = &v
	return s
}

func (s *DescribeSmbAclResponseBodyAcl) Validate() error {
	return dara.Validate(s)
}

type iDescribeSmbAclResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeSmbAclResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeSmbAclResponse
	GetStatusCode() *int32
	SetBody(v *DescribeSmbAclResponseBody) *DescribeSmbAclResponse
	GetBody() *DescribeSmbAclResponseBody
}

type DescribeSmbAclResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeSmbAclResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeSmbAclResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeSmbAclResponse) GoString() string {
	return s.String()
}

func (s *DescribeSmbAclResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeSmbAclResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeSmbAclResponse) GetBody() *DescribeSmbAclResponseBody {
	return s.Body
}

func (s *DescribeSmbAclResponse) SetHeaders(v map[string]*string) *DescribeSmbAclResponse {
	s.Headers = v
	return s
}

func (s *DescribeSmbAclResponse) SetStatusCode(v int32) *DescribeSmbAclResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSmbAclResponse) SetBody(v *DescribeSmbAclResponseBody) *DescribeSmbAclResponse {
	s.Body = v
	return s
}

func (s *DescribeSmbAclResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeSnapshotsRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *DescribeSnapshotsRequest
	GetFileSystemId() *string
	SetFileSystemType(v string) *DescribeSnapshotsRequest
	GetFileSystemType() *string
	SetPageNumber(v int32) *DescribeSnapshotsRequest
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeSnapshotsRequest
	GetPageSize() *int32
	SetSnapshotIds(v string) *DescribeSnapshotsRequest
	GetSnapshotIds() *string
	SetSnapshotName(v string) *DescribeSnapshotsRequest
	GetSnapshotName() *string
	SetSnapshotType(v string) *DescribeSnapshotsRequest
	GetSnapshotType() *string
	SetStatus(v string) *DescribeSnapshotsRequest
	GetStatus() *string
}

type DescribeSnapshotsRequest struct {
	// The ID of the file system.
	//
	// example:
	//
	// extreme-22f****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The type of the file system.
	//
	// Valid value: extreme, which indicates Extreme File Storage NAS (NAS) file systems.
	//
	// example:
	//
	// extreme
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
	// The page number.
	//
	// Pages start from page 1. Default value: 1.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	//
	// Valid values: 1 to 100.
	//
	// Default value: 10.
	//
	// example:
	//
	// 10
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The snapshot IDs.
	//
	// You can specify a maximum of 100 snapshot IDs. You must separate snapshot IDs with commas (,).
	//
	// example:
	//
	// s-extreme-67pxwk9aevrkr****,s-extreme-snapsho****,s-extreme-6tmsbas6ljhwh****
	SnapshotIds *string `json:"SnapshotIds,omitempty" xml:"SnapshotIds,omitempty"`
	// The snapshot name.
	//
	// example:
	//
	// FinanceJoshua
	SnapshotName *string `json:"SnapshotName,omitempty" xml:"SnapshotName,omitempty"`
	// The type of the snapshot.
	//
	// Valid values:
	//
	// 	- auto: auto snapshot
	//
	// 	- user: manual snapshot
	//
	// 	- all (default): all snapshot types
	//
	// example:
	//
	// all
	SnapshotType *string `json:"SnapshotType,omitempty" xml:"SnapshotType,omitempty"`
	// The status of the snapshot.
	//
	// Valid values:
	//
	// 	- progressing: The snapshot is being created.
	//
	// 	- accomplished: The snapshot is created.
	//
	// 	- failed: The snapshot fails to be created.
	//
	// 	- all (default): all snapshot states.
	//
	// example:
	//
	// all
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeSnapshotsRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeSnapshotsRequest) GoString() string {
	return s.String()
}

func (s *DescribeSnapshotsRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeSnapshotsRequest) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *DescribeSnapshotsRequest) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeSnapshotsRequest) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeSnapshotsRequest) GetSnapshotIds() *string {
	return s.SnapshotIds
}

func (s *DescribeSnapshotsRequest) GetSnapshotName() *string {
	return s.SnapshotName
}

func (s *DescribeSnapshotsRequest) GetSnapshotType() *string {
	return s.SnapshotType
}

func (s *DescribeSnapshotsRequest) GetStatus() *string {
	return s.Status
}

func (s *DescribeSnapshotsRequest) SetFileSystemId(v string) *DescribeSnapshotsRequest {
	s.FileSystemId = &v
	return s
}

func (s *DescribeSnapshotsRequest) SetFileSystemType(v string) *DescribeSnapshotsRequest {
	s.FileSystemType = &v
	return s
}

func (s *DescribeSnapshotsRequest) SetPageNumber(v int32) *DescribeSnapshotsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeSnapshotsRequest) SetPageSize(v int32) *DescribeSnapshotsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeSnapshotsRequest) SetSnapshotIds(v string) *DescribeSnapshotsRequest {
	s.SnapshotIds = &v
	return s
}

func (s *DescribeSnapshotsRequest) SetSnapshotName(v string) *DescribeSnapshotsRequest {
	s.SnapshotName = &v
	return s
}

func (s *DescribeSnapshotsRequest) SetSnapshotType(v string) *DescribeSnapshotsRequest {
	s.SnapshotType = &v
	return s
}

func (s *DescribeSnapshotsRequest) SetStatus(v string) *DescribeSnapshotsRequest {
	s.Status = &v
	return s
}

func (s *DescribeSnapshotsRequest) Validate() error {
	return dara.Validate(s)
}

type iDescribeSnapshotsResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetPageNumber(v int32) *DescribeSnapshotsResponseBody
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeSnapshotsResponseBody
	GetPageSize() *int32
	SetRequestId(v string) *DescribeSnapshotsResponseBody
	GetRequestId() *string
	SetSnapshots(v *DescribeSnapshotsResponseBodySnapshots) *DescribeSnapshotsResponseBody
	GetSnapshots() *DescribeSnapshotsResponseBodySnapshots
	SetTotalCount(v int32) *DescribeSnapshotsResponseBody
	GetTotalCount() *int32
}

type DescribeSnapshotsResponseBody struct {
	// The page number.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	//
	// example:
	//
	// 10
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 473469C7-AA6F-4DC5-B3DB-A3DC0DE3****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The details about snapshots.
	Snapshots *DescribeSnapshotsResponseBodySnapshots `json:"Snapshots,omitempty" xml:"Snapshots,omitempty" type:"Struct"`
	// The total number of snapshots returned.
	//
	// example:
	//
	// 36
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeSnapshotsResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeSnapshotsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSnapshotsResponseBody) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeSnapshotsResponseBody) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeSnapshotsResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeSnapshotsResponseBody) GetSnapshots() *DescribeSnapshotsResponseBodySnapshots {
	return s.Snapshots
}

func (s *DescribeSnapshotsResponseBody) GetTotalCount() *int32 {
	return s.TotalCount
}

func (s *DescribeSnapshotsResponseBody) SetPageNumber(v int32) *DescribeSnapshotsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeSnapshotsResponseBody) SetPageSize(v int32) *DescribeSnapshotsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeSnapshotsResponseBody) SetRequestId(v string) *DescribeSnapshotsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSnapshotsResponseBody) SetSnapshots(v *DescribeSnapshotsResponseBodySnapshots) *DescribeSnapshotsResponseBody {
	s.Snapshots = v
	return s
}

func (s *DescribeSnapshotsResponseBody) SetTotalCount(v int32) *DescribeSnapshotsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeSnapshotsResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeSnapshotsResponseBodySnapshots struct {
	Snapshot []*DescribeSnapshotsResponseBodySnapshotsSnapshot `json:"Snapshot,omitempty" xml:"Snapshot,omitempty" type:"Repeated"`
}

func (s DescribeSnapshotsResponseBodySnapshots) String() string {
	return dara.Prettify(s)
}

func (s DescribeSnapshotsResponseBodySnapshots) GoString() string {
	return s.String()
}

func (s *DescribeSnapshotsResponseBodySnapshots) GetSnapshot() []*DescribeSnapshotsResponseBodySnapshotsSnapshot {
	return s.Snapshot
}

func (s *DescribeSnapshotsResponseBodySnapshots) SetSnapshot(v []*DescribeSnapshotsResponseBodySnapshotsSnapshot) *DescribeSnapshotsResponseBodySnapshots {
	s.Snapshot = v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshots) Validate() error {
	return dara.Validate(s)
}

type DescribeSnapshotsResponseBodySnapshotsSnapshot struct {
	// The time when snapshot creation was complete.
	//
	// The time follows the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) standard in UTC. The time is displayed in the `yyyy-MM-ddThh:mmZ` format.
	//
	// >  This parameter is valid only when the snapshot is created. During snapshot creation, the value of this parameter is the same as that of CreateTime.
	//
	// example:
	//
	// 2014-07-24T13:10:52Z
	CompletedTime *string `json:"CompletedTime,omitempty" xml:"CompletedTime,omitempty"`
	// The time when the snapshot was created.
	//
	// The time follows the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) standard in UTC. The time is displayed in the `yyyy-MM-ddThh:mmZ` format.
	//
	// example:
	//
	// 2014-07-24T13:00:52Z
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The description of the snapshot.
	//
	// example:
	//
	// FinanceDept
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether the snapshot is encrypted.
	//
	// Valid values:
	//
	// 	- 0: The snapshot is not encrypted.
	//
	// 	- 1: The snapshot is encrypted.
	//
	// example:
	//
	// 1
	EncryptType *int32 `json:"EncryptType,omitempty" xml:"EncryptType,omitempty"`
	// The type of the file system.
	//
	// example:
	//
	// extreme
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
	// The progress of the snapshot creation. The value of this parameter is expressed as a percentage.
	//
	// example:
	//
	// 100
	Progress *string `json:"Progress,omitempty" xml:"Progress,omitempty"`
	// The remaining time that is required to create the snapshot.
	//
	// Unit: seconds.
	//
	// example:
	//
	// 38
	RemainTime *int32 `json:"RemainTime,omitempty" xml:"RemainTime,omitempty"`
	// The retention period of the auto snapshot.
	//
	// Unit: days.
	//
	// Valid values:
	//
	// 	- \\-1: Auto snapshots are permanently retained. After the number of auto snapshots exceeds the upper limit, the earliest auto snapshot is automatically deleted.
	//
	// 	- 1 to 65536: Auto snapshots are retained for the specified days. After the retention period of auto snapshots expires, the auto snapshots are automatically deleted.
	//
	// example:
	//
	// 30
	RetentionDays *int32 `json:"RetentionDays,omitempty" xml:"RetentionDays,omitempty"`
	// The snapshot ID.
	//
	// example:
	//
	// s-extreme-snapsho****
	SnapshotId *string `json:"SnapshotId,omitempty" xml:"SnapshotId,omitempty"`
	// The snapshot name.
	//
	// If you specify a name to create a snapshot, the name of the snapshot is returned. Otherwise, no value is returned for this parameter.
	//
	// example:
	//
	// FinanceJoshua
	SnapshotName *string `json:"SnapshotName,omitempty" xml:"SnapshotName,omitempty"`
	// The snapshot type. Valid values:
	//
	// 	- auto: automatically created snapshots
	//
	// 	- user: manually created snapshots
	//
	// example:
	//
	// user
	SnapshotType *string `json:"SnapshotType,omitempty" xml:"SnapshotType,omitempty"`
	// The ID of the source file system.
	//
	// This parameter is retained even if the source file system of the snapshot is deleted.
	//
	// example:
	//
	// extreme-012****
	SourceFileSystemId *string `json:"SourceFileSystemId,omitempty" xml:"SourceFileSystemId,omitempty"`
	// The capacity of the source file system.
	//
	// Unit: GiB.
	//
	// example:
	//
	// 2000
	SourceFileSystemSize *int64 `json:"SourceFileSystemSize,omitempty" xml:"SourceFileSystemSize,omitempty"`
	// The version of the source file system.
	//
	// example:
	//
	// 1
	SourceFileSystemVersion *string `json:"SourceFileSystemVersion,omitempty" xml:"SourceFileSystemVersion,omitempty"`
	// The status of the snapshot.
	//
	// Valid values:
	//
	// 	- progressing: The snapshot is being created.
	//
	// 	- accomplished: The snapshot is created.
	//
	// 	- failed: The snapshot fails to be created.
	//
	// example:
	//
	// accomplished
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeSnapshotsResponseBodySnapshotsSnapshot) String() string {
	return dara.Prettify(s)
}

func (s DescribeSnapshotsResponseBodySnapshotsSnapshot) GoString() string {
	return s.String()
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) GetCompletedTime() *string {
	return s.CompletedTime
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) GetCreateTime() *string {
	return s.CreateTime
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) GetDescription() *string {
	return s.Description
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) GetEncryptType() *int32 {
	return s.EncryptType
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) GetProgress() *string {
	return s.Progress
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) GetRemainTime() *int32 {
	return s.RemainTime
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) GetRetentionDays() *int32 {
	return s.RetentionDays
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) GetSnapshotId() *string {
	return s.SnapshotId
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) GetSnapshotName() *string {
	return s.SnapshotName
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) GetSnapshotType() *string {
	return s.SnapshotType
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) GetSourceFileSystemId() *string {
	return s.SourceFileSystemId
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) GetSourceFileSystemSize() *int64 {
	return s.SourceFileSystemSize
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) GetSourceFileSystemVersion() *string {
	return s.SourceFileSystemVersion
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) GetStatus() *string {
	return s.Status
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) SetCompletedTime(v string) *DescribeSnapshotsResponseBodySnapshotsSnapshot {
	s.CompletedTime = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) SetCreateTime(v string) *DescribeSnapshotsResponseBodySnapshotsSnapshot {
	s.CreateTime = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) SetDescription(v string) *DescribeSnapshotsResponseBodySnapshotsSnapshot {
	s.Description = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) SetEncryptType(v int32) *DescribeSnapshotsResponseBodySnapshotsSnapshot {
	s.EncryptType = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) SetFileSystemType(v string) *DescribeSnapshotsResponseBodySnapshotsSnapshot {
	s.FileSystemType = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) SetProgress(v string) *DescribeSnapshotsResponseBodySnapshotsSnapshot {
	s.Progress = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) SetRemainTime(v int32) *DescribeSnapshotsResponseBodySnapshotsSnapshot {
	s.RemainTime = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) SetRetentionDays(v int32) *DescribeSnapshotsResponseBodySnapshotsSnapshot {
	s.RetentionDays = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) SetSnapshotId(v string) *DescribeSnapshotsResponseBodySnapshotsSnapshot {
	s.SnapshotId = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) SetSnapshotName(v string) *DescribeSnapshotsResponseBodySnapshotsSnapshot {
	s.SnapshotName = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) SetSnapshotType(v string) *DescribeSnapshotsResponseBodySnapshotsSnapshot {
	s.SnapshotType = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) SetSourceFileSystemId(v string) *DescribeSnapshotsResponseBodySnapshotsSnapshot {
	s.SourceFileSystemId = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) SetSourceFileSystemSize(v int64) *DescribeSnapshotsResponseBodySnapshotsSnapshot {
	s.SourceFileSystemSize = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) SetSourceFileSystemVersion(v string) *DescribeSnapshotsResponseBodySnapshotsSnapshot {
	s.SourceFileSystemVersion = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) SetStatus(v string) *DescribeSnapshotsResponseBodySnapshotsSnapshot {
	s.Status = &v
	return s
}

func (s *DescribeSnapshotsResponseBodySnapshotsSnapshot) Validate() error {
	return dara.Validate(s)
}

type iDescribeSnapshotsResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeSnapshotsResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeSnapshotsResponse
	GetStatusCode() *int32
	SetBody(v *DescribeSnapshotsResponseBody) *DescribeSnapshotsResponse
	GetBody() *DescribeSnapshotsResponseBody
}

type DescribeSnapshotsResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeSnapshotsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeSnapshotsResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeSnapshotsResponse) GoString() string {
	return s.String()
}

func (s *DescribeSnapshotsResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeSnapshotsResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeSnapshotsResponse) GetBody() *DescribeSnapshotsResponseBody {
	return s.Body
}

func (s *DescribeSnapshotsResponse) SetHeaders(v map[string]*string) *DescribeSnapshotsResponse {
	s.Headers = v
	return s
}

func (s *DescribeSnapshotsResponse) SetStatusCode(v int32) *DescribeSnapshotsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSnapshotsResponse) SetBody(v *DescribeSnapshotsResponseBody) *DescribeSnapshotsResponse {
	s.Body = v
	return s
}

func (s *DescribeSnapshotsResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeStoragePackagesRequest interface {
	dara.Model
	String() string
	GoString() string
	SetPageNumber(v int32) *DescribeStoragePackagesRequest
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeStoragePackagesRequest
	GetPageSize() *int32
	SetRegionId(v string) *DescribeStoragePackagesRequest
	GetRegionId() *string
	SetUseUTCDateTime(v bool) *DescribeStoragePackagesRequest
	GetUseUTCDateTime() *bool
}

type DescribeStoragePackagesRequest struct {
	// The number of the page to return.
	//
	// Pages start from page 1. Default value: 1.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of storage plans to return on each page.
	//
	// Valid values: 1 to 100.
	//
	// Default value: 10.
	//
	// example:
	//
	// 10
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// cn-hangzhou
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Specifies whether the time to return is in UTC.
	//
	// Valid values:
	//
	// 	- true (default): returns UTC time.
	//
	// 	- false: returns UNIX timestamp.
	//
	// example:
	//
	// true
	UseUTCDateTime *bool `json:"UseUTCDateTime,omitempty" xml:"UseUTCDateTime,omitempty"`
}

func (s DescribeStoragePackagesRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeStoragePackagesRequest) GoString() string {
	return s.String()
}

func (s *DescribeStoragePackagesRequest) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeStoragePackagesRequest) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeStoragePackagesRequest) GetRegionId() *string {
	return s.RegionId
}

func (s *DescribeStoragePackagesRequest) GetUseUTCDateTime() *bool {
	return s.UseUTCDateTime
}

func (s *DescribeStoragePackagesRequest) SetPageNumber(v int32) *DescribeStoragePackagesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeStoragePackagesRequest) SetPageSize(v int32) *DescribeStoragePackagesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeStoragePackagesRequest) SetRegionId(v string) *DescribeStoragePackagesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeStoragePackagesRequest) SetUseUTCDateTime(v bool) *DescribeStoragePackagesRequest {
	s.UseUTCDateTime = &v
	return s
}

func (s *DescribeStoragePackagesRequest) Validate() error {
	return dara.Validate(s)
}

type iDescribeStoragePackagesResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetPackages(v *DescribeStoragePackagesResponseBodyPackages) *DescribeStoragePackagesResponseBody
	GetPackages() *DescribeStoragePackagesResponseBodyPackages
	SetPageNumber(v int32) *DescribeStoragePackagesResponseBody
	GetPageNumber() *int32
	SetPageSize(v int32) *DescribeStoragePackagesResponseBody
	GetPageSize() *int32
	SetRequestId(v string) *DescribeStoragePackagesResponseBody
	GetRequestId() *string
	SetTotalCount(v int32) *DescribeStoragePackagesResponseBody
	GetTotalCount() *int32
}

type DescribeStoragePackagesResponseBody struct {
	// The list of storage plans.
	Packages *DescribeStoragePackagesResponseBodyPackages `json:"Packages,omitempty" xml:"Packages,omitempty" type:"Struct"`
	// The page number of the returned page.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of storage plans returned per page.
	//
	// example:
	//
	// 1
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 035B3A3A-E514-4B41-B906-5D906CFB****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of storage plans.
	//
	// example:
	//
	// 3
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeStoragePackagesResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeStoragePackagesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeStoragePackagesResponseBody) GetPackages() *DescribeStoragePackagesResponseBodyPackages {
	return s.Packages
}

func (s *DescribeStoragePackagesResponseBody) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *DescribeStoragePackagesResponseBody) GetPageSize() *int32 {
	return s.PageSize
}

func (s *DescribeStoragePackagesResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeStoragePackagesResponseBody) GetTotalCount() *int32 {
	return s.TotalCount
}

func (s *DescribeStoragePackagesResponseBody) SetPackages(v *DescribeStoragePackagesResponseBodyPackages) *DescribeStoragePackagesResponseBody {
	s.Packages = v
	return s
}

func (s *DescribeStoragePackagesResponseBody) SetPageNumber(v int32) *DescribeStoragePackagesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeStoragePackagesResponseBody) SetPageSize(v int32) *DescribeStoragePackagesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeStoragePackagesResponseBody) SetRequestId(v string) *DescribeStoragePackagesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeStoragePackagesResponseBody) SetTotalCount(v int32) *DescribeStoragePackagesResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeStoragePackagesResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeStoragePackagesResponseBodyPackages struct {
	Package []*DescribeStoragePackagesResponseBodyPackagesPackage `json:"Package,omitempty" xml:"Package,omitempty" type:"Repeated"`
}

func (s DescribeStoragePackagesResponseBodyPackages) String() string {
	return dara.Prettify(s)
}

func (s DescribeStoragePackagesResponseBodyPackages) GoString() string {
	return s.String()
}

func (s *DescribeStoragePackagesResponseBodyPackages) GetPackage() []*DescribeStoragePackagesResponseBodyPackagesPackage {
	return s.Package
}

func (s *DescribeStoragePackagesResponseBodyPackages) SetPackage(v []*DescribeStoragePackagesResponseBodyPackagesPackage) *DescribeStoragePackagesResponseBodyPackages {
	s.Package = v
	return s
}

func (s *DescribeStoragePackagesResponseBodyPackages) Validate() error {
	return dara.Validate(s)
}

type DescribeStoragePackagesResponseBodyPackagesPackage struct {
	// The end time of the validity period for the storage plan.
	//
	// example:
	//
	// 2020-01-05T16:00:00Z
	ExpiredTime *string `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// The ID of the file system that is bound to the storage plan.
	//
	// example:
	//
	// 109c****66
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The ID of the storage plan.
	//
	// example:
	//
	// naspackage-@string(\\"*****\\", *)-@string(\\"*****\\", *)
	PackageId *string `json:"PackageId,omitempty" xml:"PackageId,omitempty"`
	// The capacity of the storage plan.
	//
	// Unit: bytes.
	//
	// example:
	//
	// 10
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The start time of the validity period for the storage plan.
	//
	// example:
	//
	// 2019-12-05T01:40:56Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The status of the storage plan.
	//
	// Valid values:
	//
	// 	- free: The storage plan is not bound to a file system. You can bind the storage plan to a file system of the same storage type.
	//
	// 	- bound: The storage plan is bound to a file system.
	//
	// example:
	//
	// free
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the storage plan.
	//
	// Valid values:
	//
	// 	- Performance
	//
	// 	- Capacity
	//
	// example:
	//
	// Capacity
	StorageType *string `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
}

func (s DescribeStoragePackagesResponseBodyPackagesPackage) String() string {
	return dara.Prettify(s)
}

func (s DescribeStoragePackagesResponseBodyPackagesPackage) GoString() string {
	return s.String()
}

func (s *DescribeStoragePackagesResponseBodyPackagesPackage) GetExpiredTime() *string {
	return s.ExpiredTime
}

func (s *DescribeStoragePackagesResponseBodyPackagesPackage) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeStoragePackagesResponseBodyPackagesPackage) GetPackageId() *string {
	return s.PackageId
}

func (s *DescribeStoragePackagesResponseBodyPackagesPackage) GetSize() *int64 {
	return s.Size
}

func (s *DescribeStoragePackagesResponseBodyPackagesPackage) GetStartTime() *string {
	return s.StartTime
}

func (s *DescribeStoragePackagesResponseBodyPackagesPackage) GetStatus() *string {
	return s.Status
}

func (s *DescribeStoragePackagesResponseBodyPackagesPackage) GetStorageType() *string {
	return s.StorageType
}

func (s *DescribeStoragePackagesResponseBodyPackagesPackage) SetExpiredTime(v string) *DescribeStoragePackagesResponseBodyPackagesPackage {
	s.ExpiredTime = &v
	return s
}

func (s *DescribeStoragePackagesResponseBodyPackagesPackage) SetFileSystemId(v string) *DescribeStoragePackagesResponseBodyPackagesPackage {
	s.FileSystemId = &v
	return s
}

func (s *DescribeStoragePackagesResponseBodyPackagesPackage) SetPackageId(v string) *DescribeStoragePackagesResponseBodyPackagesPackage {
	s.PackageId = &v
	return s
}

func (s *DescribeStoragePackagesResponseBodyPackagesPackage) SetSize(v int64) *DescribeStoragePackagesResponseBodyPackagesPackage {
	s.Size = &v
	return s
}

func (s *DescribeStoragePackagesResponseBodyPackagesPackage) SetStartTime(v string) *DescribeStoragePackagesResponseBodyPackagesPackage {
	s.StartTime = &v
	return s
}

func (s *DescribeStoragePackagesResponseBodyPackagesPackage) SetStatus(v string) *DescribeStoragePackagesResponseBodyPackagesPackage {
	s.Status = &v
	return s
}

func (s *DescribeStoragePackagesResponseBodyPackagesPackage) SetStorageType(v string) *DescribeStoragePackagesResponseBodyPackagesPackage {
	s.StorageType = &v
	return s
}

func (s *DescribeStoragePackagesResponseBodyPackagesPackage) Validate() error {
	return dara.Validate(s)
}

type iDescribeStoragePackagesResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeStoragePackagesResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeStoragePackagesResponse
	GetStatusCode() *int32
	SetBody(v *DescribeStoragePackagesResponseBody) *DescribeStoragePackagesResponse
	GetBody() *DescribeStoragePackagesResponseBody
}

type DescribeStoragePackagesResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeStoragePackagesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeStoragePackagesResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeStoragePackagesResponse) GoString() string {
	return s.String()
}

func (s *DescribeStoragePackagesResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeStoragePackagesResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeStoragePackagesResponse) GetBody() *DescribeStoragePackagesResponseBody {
	return s.Body
}

func (s *DescribeStoragePackagesResponse) SetHeaders(v map[string]*string) *DescribeStoragePackagesResponse {
	s.Headers = v
	return s
}

func (s *DescribeStoragePackagesResponse) SetStatusCode(v int32) *DescribeStoragePackagesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeStoragePackagesResponse) SetBody(v *DescribeStoragePackagesResponseBody) *DescribeStoragePackagesResponse {
	s.Body = v
	return s
}

func (s *DescribeStoragePackagesResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeVscMountPointAttachInfoRequest interface {
	dara.Model
	String() string
	GoString() string
	SetInstanceIds(v []*string) *DescribeVscMountPointAttachInfoRequest
	GetInstanceIds() []*string
	SetMaxResults(v int32) *DescribeVscMountPointAttachInfoRequest
	GetMaxResults() *int32
	SetMountPointDomain(v string) *DescribeVscMountPointAttachInfoRequest
	GetMountPointDomain() *string
	SetNextToken(v string) *DescribeVscMountPointAttachInfoRequest
	GetNextToken() *string
	SetVscIds(v []*string) *DescribeVscMountPointAttachInfoRequest
	GetVscIds() []*string
}

type DescribeVscMountPointAttachInfoRequest struct {
	InstanceIds      []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	MaxResults       *int32    `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	MountPointDomain *string   `json:"MountPointDomain,omitempty" xml:"MountPointDomain,omitempty"`
	NextToken        *string   `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	VscIds           []*string `json:"VscIds,omitempty" xml:"VscIds,omitempty" type:"Repeated"`
}

func (s DescribeVscMountPointAttachInfoRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeVscMountPointAttachInfoRequest) GoString() string {
	return s.String()
}

func (s *DescribeVscMountPointAttachInfoRequest) GetInstanceIds() []*string {
	return s.InstanceIds
}

func (s *DescribeVscMountPointAttachInfoRequest) GetMaxResults() *int32 {
	return s.MaxResults
}

func (s *DescribeVscMountPointAttachInfoRequest) GetMountPointDomain() *string {
	return s.MountPointDomain
}

func (s *DescribeVscMountPointAttachInfoRequest) GetNextToken() *string {
	return s.NextToken
}

func (s *DescribeVscMountPointAttachInfoRequest) GetVscIds() []*string {
	return s.VscIds
}

func (s *DescribeVscMountPointAttachInfoRequest) SetInstanceIds(v []*string) *DescribeVscMountPointAttachInfoRequest {
	s.InstanceIds = v
	return s
}

func (s *DescribeVscMountPointAttachInfoRequest) SetMaxResults(v int32) *DescribeVscMountPointAttachInfoRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeVscMountPointAttachInfoRequest) SetMountPointDomain(v string) *DescribeVscMountPointAttachInfoRequest {
	s.MountPointDomain = &v
	return s
}

func (s *DescribeVscMountPointAttachInfoRequest) SetNextToken(v string) *DescribeVscMountPointAttachInfoRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeVscMountPointAttachInfoRequest) SetVscIds(v []*string) *DescribeVscMountPointAttachInfoRequest {
	s.VscIds = v
	return s
}

func (s *DescribeVscMountPointAttachInfoRequest) Validate() error {
	return dara.Validate(s)
}

type iDescribeVscMountPointAttachInfoResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetDescVscAttachInfos(v *DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfos) *DescribeVscMountPointAttachInfoResponseBody
	GetDescVscAttachInfos() *DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfos
	SetNextToken(v string) *DescribeVscMountPointAttachInfoResponseBody
	GetNextToken() *string
	SetRequestId(v string) *DescribeVscMountPointAttachInfoResponseBody
	GetRequestId() *string
	SetTotalCount(v int32) *DescribeVscMountPointAttachInfoResponseBody
	GetTotalCount() *int32
}

type DescribeVscMountPointAttachInfoResponseBody struct {
	DescVscAttachInfos *DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfos `json:"DescVscAttachInfos,omitempty" xml:"DescVscAttachInfos,omitempty" type:"Struct"`
	NextToken          *string                                                        `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	RequestId          *string                                                        `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TotalCount         *int32                                                         `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeVscMountPointAttachInfoResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeVscMountPointAttachInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVscMountPointAttachInfoResponseBody) GetDescVscAttachInfos() *DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfos {
	return s.DescVscAttachInfos
}

func (s *DescribeVscMountPointAttachInfoResponseBody) GetNextToken() *string {
	return s.NextToken
}

func (s *DescribeVscMountPointAttachInfoResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeVscMountPointAttachInfoResponseBody) GetTotalCount() *int32 {
	return s.TotalCount
}

func (s *DescribeVscMountPointAttachInfoResponseBody) SetDescVscAttachInfos(v *DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfos) *DescribeVscMountPointAttachInfoResponseBody {
	s.DescVscAttachInfos = v
	return s
}

func (s *DescribeVscMountPointAttachInfoResponseBody) SetNextToken(v string) *DescribeVscMountPointAttachInfoResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeVscMountPointAttachInfoResponseBody) SetRequestId(v string) *DescribeVscMountPointAttachInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVscMountPointAttachInfoResponseBody) SetTotalCount(v int32) *DescribeVscMountPointAttachInfoResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeVscMountPointAttachInfoResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfos struct {
	DescVscAttachInfo []*DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfosDescVscAttachInfo `json:"DescVscAttachInfo,omitempty" xml:"DescVscAttachInfo,omitempty" type:"Repeated"`
}

func (s DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfos) String() string {
	return dara.Prettify(s)
}

func (s DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfos) GoString() string {
	return s.String()
}

func (s *DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfos) GetDescVscAttachInfo() []*DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfosDescVscAttachInfo {
	return s.DescVscAttachInfo
}

func (s *DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfos) SetDescVscAttachInfo(v []*DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfosDescVscAttachInfo) *DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfos {
	s.DescVscAttachInfo = v
	return s
}

func (s *DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfos) Validate() error {
	return dara.Validate(s)
}

type DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfosDescVscAttachInfo struct {
	InstanceId       *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	MountPointDomain *string `json:"MountPointDomain,omitempty" xml:"MountPointDomain,omitempty"`
	Status           *string `json:"Status,omitempty" xml:"Status,omitempty"`
	VscId            *string `json:"VscId,omitempty" xml:"VscId,omitempty"`
	VscType          *string `json:"VscType,omitempty" xml:"VscType,omitempty"`
}

func (s DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfosDescVscAttachInfo) String() string {
	return dara.Prettify(s)
}

func (s DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfosDescVscAttachInfo) GoString() string {
	return s.String()
}

func (s *DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfosDescVscAttachInfo) GetInstanceId() *string {
	return s.InstanceId
}

func (s *DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfosDescVscAttachInfo) GetMountPointDomain() *string {
	return s.MountPointDomain
}

func (s *DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfosDescVscAttachInfo) GetStatus() *string {
	return s.Status
}

func (s *DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfosDescVscAttachInfo) GetVscId() *string {
	return s.VscId
}

func (s *DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfosDescVscAttachInfo) GetVscType() *string {
	return s.VscType
}

func (s *DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfosDescVscAttachInfo) SetInstanceId(v string) *DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfosDescVscAttachInfo {
	s.InstanceId = &v
	return s
}

func (s *DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfosDescVscAttachInfo) SetMountPointDomain(v string) *DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfosDescVscAttachInfo {
	s.MountPointDomain = &v
	return s
}

func (s *DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfosDescVscAttachInfo) SetStatus(v string) *DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfosDescVscAttachInfo {
	s.Status = &v
	return s
}

func (s *DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfosDescVscAttachInfo) SetVscId(v string) *DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfosDescVscAttachInfo {
	s.VscId = &v
	return s
}

func (s *DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfosDescVscAttachInfo) SetVscType(v string) *DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfosDescVscAttachInfo {
	s.VscType = &v
	return s
}

func (s *DescribeVscMountPointAttachInfoResponseBodyDescVscAttachInfosDescVscAttachInfo) Validate() error {
	return dara.Validate(s)
}

type iDescribeVscMountPointAttachInfoResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeVscMountPointAttachInfoResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeVscMountPointAttachInfoResponse
	GetStatusCode() *int32
	SetBody(v *DescribeVscMountPointAttachInfoResponseBody) *DescribeVscMountPointAttachInfoResponse
	GetBody() *DescribeVscMountPointAttachInfoResponseBody
}

type DescribeVscMountPointAttachInfoResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVscMountPointAttachInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVscMountPointAttachInfoResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeVscMountPointAttachInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribeVscMountPointAttachInfoResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeVscMountPointAttachInfoResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeVscMountPointAttachInfoResponse) GetBody() *DescribeVscMountPointAttachInfoResponseBody {
	return s.Body
}

func (s *DescribeVscMountPointAttachInfoResponse) SetHeaders(v map[string]*string) *DescribeVscMountPointAttachInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribeVscMountPointAttachInfoResponse) SetStatusCode(v int32) *DescribeVscMountPointAttachInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVscMountPointAttachInfoResponse) SetBody(v *DescribeVscMountPointAttachInfoResponseBody) *DescribeVscMountPointAttachInfoResponse {
	s.Body = v
	return s
}

func (s *DescribeVscMountPointAttachInfoResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeVscMountPointsRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *DescribeVscMountPointsRequest
	GetFileSystemId() *string
	SetMaxResults(v int32) *DescribeVscMountPointsRequest
	GetMaxResults() *int32
	SetMountPointDomain(v string) *DescribeVscMountPointsRequest
	GetMountPointDomain() *string
	SetNextToken(v string) *DescribeVscMountPointsRequest
	GetNextToken() *string
}

type DescribeVscMountPointsRequest struct {
	// This parameter is required.
	FileSystemId     *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	MaxResults       *int32  `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	MountPointDomain *string `json:"MountPointDomain,omitempty" xml:"MountPointDomain,omitempty"`
	NextToken        *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
}

func (s DescribeVscMountPointsRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeVscMountPointsRequest) GoString() string {
	return s.String()
}

func (s *DescribeVscMountPointsRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DescribeVscMountPointsRequest) GetMaxResults() *int32 {
	return s.MaxResults
}

func (s *DescribeVscMountPointsRequest) GetMountPointDomain() *string {
	return s.MountPointDomain
}

func (s *DescribeVscMountPointsRequest) GetNextToken() *string {
	return s.NextToken
}

func (s *DescribeVscMountPointsRequest) SetFileSystemId(v string) *DescribeVscMountPointsRequest {
	s.FileSystemId = &v
	return s
}

func (s *DescribeVscMountPointsRequest) SetMaxResults(v int32) *DescribeVscMountPointsRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeVscMountPointsRequest) SetMountPointDomain(v string) *DescribeVscMountPointsRequest {
	s.MountPointDomain = &v
	return s
}

func (s *DescribeVscMountPointsRequest) SetNextToken(v string) *DescribeVscMountPointsRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeVscMountPointsRequest) Validate() error {
	return dara.Validate(s)
}

type iDescribeVscMountPointsResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetNextToken(v string) *DescribeVscMountPointsResponseBody
	GetNextToken() *string
	SetRequestId(v string) *DescribeVscMountPointsResponseBody
	GetRequestId() *string
	SetTotalCount(v int32) *DescribeVscMountPointsResponseBody
	GetTotalCount() *int32
	SetVscMountPoints(v *DescribeVscMountPointsResponseBodyVscMountPoints) *DescribeVscMountPointsResponseBody
	GetVscMountPoints() *DescribeVscMountPointsResponseBodyVscMountPoints
}

type DescribeVscMountPointsResponseBody struct {
	NextToken      *string                                           `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	RequestId      *string                                           `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TotalCount     *int32                                            `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	VscMountPoints *DescribeVscMountPointsResponseBodyVscMountPoints `json:"VscMountPoints,omitempty" xml:"VscMountPoints,omitempty" type:"Struct"`
}

func (s DescribeVscMountPointsResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeVscMountPointsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVscMountPointsResponseBody) GetNextToken() *string {
	return s.NextToken
}

func (s *DescribeVscMountPointsResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeVscMountPointsResponseBody) GetTotalCount() *int32 {
	return s.TotalCount
}

func (s *DescribeVscMountPointsResponseBody) GetVscMountPoints() *DescribeVscMountPointsResponseBodyVscMountPoints {
	return s.VscMountPoints
}

func (s *DescribeVscMountPointsResponseBody) SetNextToken(v string) *DescribeVscMountPointsResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeVscMountPointsResponseBody) SetRequestId(v string) *DescribeVscMountPointsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVscMountPointsResponseBody) SetTotalCount(v int32) *DescribeVscMountPointsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeVscMountPointsResponseBody) SetVscMountPoints(v *DescribeVscMountPointsResponseBodyVscMountPoints) *DescribeVscMountPointsResponseBody {
	s.VscMountPoints = v
	return s
}

func (s *DescribeVscMountPointsResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeVscMountPointsResponseBodyVscMountPoints struct {
	VscMountPoint []*DescribeVscMountPointsResponseBodyVscMountPointsVscMountPoint `json:"VscMountPoint,omitempty" xml:"VscMountPoint,omitempty" type:"Repeated"`
}

func (s DescribeVscMountPointsResponseBodyVscMountPoints) String() string {
	return dara.Prettify(s)
}

func (s DescribeVscMountPointsResponseBodyVscMountPoints) GoString() string {
	return s.String()
}

func (s *DescribeVscMountPointsResponseBodyVscMountPoints) GetVscMountPoint() []*DescribeVscMountPointsResponseBodyVscMountPointsVscMountPoint {
	return s.VscMountPoint
}

func (s *DescribeVscMountPointsResponseBodyVscMountPoints) SetVscMountPoint(v []*DescribeVscMountPointsResponseBodyVscMountPointsVscMountPoint) *DescribeVscMountPointsResponseBodyVscMountPoints {
	s.VscMountPoint = v
	return s
}

func (s *DescribeVscMountPointsResponseBodyVscMountPoints) Validate() error {
	return dara.Validate(s)
}

type DescribeVscMountPointsResponseBodyVscMountPointsVscMountPoint struct {
	Description      *string `json:"Description,omitempty" xml:"Description,omitempty"`
	MountPointAlias  *string `json:"MountPointAlias,omitempty" xml:"MountPointAlias,omitempty"`
	MountPointDomain *string `json:"MountPointDomain,omitempty" xml:"MountPointDomain,omitempty"`
	Status           *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeVscMountPointsResponseBodyVscMountPointsVscMountPoint) String() string {
	return dara.Prettify(s)
}

func (s DescribeVscMountPointsResponseBodyVscMountPointsVscMountPoint) GoString() string {
	return s.String()
}

func (s *DescribeVscMountPointsResponseBodyVscMountPointsVscMountPoint) GetDescription() *string {
	return s.Description
}

func (s *DescribeVscMountPointsResponseBodyVscMountPointsVscMountPoint) GetMountPointAlias() *string {
	return s.MountPointAlias
}

func (s *DescribeVscMountPointsResponseBodyVscMountPointsVscMountPoint) GetMountPointDomain() *string {
	return s.MountPointDomain
}

func (s *DescribeVscMountPointsResponseBodyVscMountPointsVscMountPoint) GetStatus() *string {
	return s.Status
}

func (s *DescribeVscMountPointsResponseBodyVscMountPointsVscMountPoint) SetDescription(v string) *DescribeVscMountPointsResponseBodyVscMountPointsVscMountPoint {
	s.Description = &v
	return s
}

func (s *DescribeVscMountPointsResponseBodyVscMountPointsVscMountPoint) SetMountPointAlias(v string) *DescribeVscMountPointsResponseBodyVscMountPointsVscMountPoint {
	s.MountPointAlias = &v
	return s
}

func (s *DescribeVscMountPointsResponseBodyVscMountPointsVscMountPoint) SetMountPointDomain(v string) *DescribeVscMountPointsResponseBodyVscMountPointsVscMountPoint {
	s.MountPointDomain = &v
	return s
}

func (s *DescribeVscMountPointsResponseBodyVscMountPointsVscMountPoint) SetStatus(v string) *DescribeVscMountPointsResponseBodyVscMountPointsVscMountPoint {
	s.Status = &v
	return s
}

func (s *DescribeVscMountPointsResponseBodyVscMountPointsVscMountPoint) Validate() error {
	return dara.Validate(s)
}

type iDescribeVscMountPointsResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeVscMountPointsResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeVscMountPointsResponse
	GetStatusCode() *int32
	SetBody(v *DescribeVscMountPointsResponseBody) *DescribeVscMountPointsResponse
	GetBody() *DescribeVscMountPointsResponseBody
}

type DescribeVscMountPointsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVscMountPointsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVscMountPointsResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeVscMountPointsResponse) GoString() string {
	return s.String()
}

func (s *DescribeVscMountPointsResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeVscMountPointsResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeVscMountPointsResponse) GetBody() *DescribeVscMountPointsResponseBody {
	return s.Body
}

func (s *DescribeVscMountPointsResponse) SetHeaders(v map[string]*string) *DescribeVscMountPointsResponse {
	s.Headers = v
	return s
}

func (s *DescribeVscMountPointsResponse) SetStatusCode(v int32) *DescribeVscMountPointsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVscMountPointsResponse) SetBody(v *DescribeVscMountPointsResponseBody) *DescribeVscMountPointsResponse {
	s.Body = v
	return s
}

func (s *DescribeVscMountPointsResponse) Validate() error {
	return dara.Validate(s)
}

type iDescribeZonesRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemType(v string) *DescribeZonesRequest
	GetFileSystemType() *string
	SetRegionId(v string) *DescribeZonesRequest
	GetRegionId() *string
}

type DescribeZonesRequest struct {
	// The type of the file system.
	//
	// Valid values:
	//
	// 	- standard (default): General-purpose NAS file system
	//
	// 	- extreme: Extreme NAS file system
	//
	// 	- cpfs: Cloud Parallel File Storage (CPFS) file system
	//
	// > CPFS file systems are available only on the China site (aliyun.com).
	//
	// example:
	//
	// standard
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
	// The ID of the region where you want to query zones.
	//
	// You can call the DescribeRegions operation to query the latest region list.
	//
	// This parameter is required.
	//
	// example:
	//
	// cn-hangzhou
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeZonesRequest) String() string {
	return dara.Prettify(s)
}

func (s DescribeZonesRequest) GoString() string {
	return s.String()
}

func (s *DescribeZonesRequest) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *DescribeZonesRequest) GetRegionId() *string {
	return s.RegionId
}

func (s *DescribeZonesRequest) SetFileSystemType(v string) *DescribeZonesRequest {
	s.FileSystemType = &v
	return s
}

func (s *DescribeZonesRequest) SetRegionId(v string) *DescribeZonesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeZonesRequest) Validate() error {
	return dara.Validate(s)
}

type iDescribeZonesResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *DescribeZonesResponseBody
	GetRequestId() *string
	SetZones(v *DescribeZonesResponseBodyZones) *DescribeZonesResponseBody
	GetZones() *DescribeZonesResponseBodyZones
}

type DescribeZonesResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// A70BEE5D-76D3-49FB-B58F-1F398211****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The queried zones.
	Zones *DescribeZonesResponseBodyZones `json:"Zones,omitempty" xml:"Zones,omitempty" type:"Struct"`
}

func (s DescribeZonesResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DescribeZonesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeZonesResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DescribeZonesResponseBody) GetZones() *DescribeZonesResponseBodyZones {
	return s.Zones
}

func (s *DescribeZonesResponseBody) SetRequestId(v string) *DescribeZonesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeZonesResponseBody) SetZones(v *DescribeZonesResponseBodyZones) *DescribeZonesResponseBody {
	s.Zones = v
	return s
}

func (s *DescribeZonesResponseBody) Validate() error {
	return dara.Validate(s)
}

type DescribeZonesResponseBodyZones struct {
	Zone []*DescribeZonesResponseBodyZonesZone `json:"Zone,omitempty" xml:"Zone,omitempty" type:"Repeated"`
}

func (s DescribeZonesResponseBodyZones) String() string {
	return dara.Prettify(s)
}

func (s DescribeZonesResponseBodyZones) GoString() string {
	return s.String()
}

func (s *DescribeZonesResponseBodyZones) GetZone() []*DescribeZonesResponseBodyZonesZone {
	return s.Zone
}

func (s *DescribeZonesResponseBodyZones) SetZone(v []*DescribeZonesResponseBodyZonesZone) *DescribeZonesResponseBodyZones {
	s.Zone = v
	return s
}

func (s *DescribeZonesResponseBodyZones) Validate() error {
	return dara.Validate(s)
}

type DescribeZonesResponseBodyZonesZone struct {
	// This parameter is reserved. You can ignore this parameter.
	Capacity *DescribeZonesResponseBodyZonesZoneCapacity `json:"Capacity,omitempty" xml:"Capacity,omitempty" type:"Struct"`
	// The details about file system types.
	InstanceTypes *DescribeZonesResponseBodyZonesZoneInstanceTypes `json:"InstanceTypes,omitempty" xml:"InstanceTypes,omitempty" type:"Struct"`
	// This parameter is reserved. You can ignore this parameter.
	Performance *DescribeZonesResponseBodyZonesZonePerformance `json:"Performance,omitempty" xml:"Performance,omitempty" type:"Struct"`
	// The zone ID.
	//
	// example:
	//
	// cn-hangzhou-b
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeZonesResponseBodyZonesZone) String() string {
	return dara.Prettify(s)
}

func (s DescribeZonesResponseBodyZonesZone) GoString() string {
	return s.String()
}

func (s *DescribeZonesResponseBodyZonesZone) GetCapacity() *DescribeZonesResponseBodyZonesZoneCapacity {
	return s.Capacity
}

func (s *DescribeZonesResponseBodyZonesZone) GetInstanceTypes() *DescribeZonesResponseBodyZonesZoneInstanceTypes {
	return s.InstanceTypes
}

func (s *DescribeZonesResponseBodyZonesZone) GetPerformance() *DescribeZonesResponseBodyZonesZonePerformance {
	return s.Performance
}

func (s *DescribeZonesResponseBodyZonesZone) GetZoneId() *string {
	return s.ZoneId
}

func (s *DescribeZonesResponseBodyZonesZone) SetCapacity(v *DescribeZonesResponseBodyZonesZoneCapacity) *DescribeZonesResponseBodyZonesZone {
	s.Capacity = v
	return s
}

func (s *DescribeZonesResponseBodyZonesZone) SetInstanceTypes(v *DescribeZonesResponseBodyZonesZoneInstanceTypes) *DescribeZonesResponseBodyZonesZone {
	s.InstanceTypes = v
	return s
}

func (s *DescribeZonesResponseBodyZonesZone) SetPerformance(v *DescribeZonesResponseBodyZonesZonePerformance) *DescribeZonesResponseBodyZonesZone {
	s.Performance = v
	return s
}

func (s *DescribeZonesResponseBodyZonesZone) SetZoneId(v string) *DescribeZonesResponseBodyZonesZone {
	s.ZoneId = &v
	return s
}

func (s *DescribeZonesResponseBodyZonesZone) Validate() error {
	return dara.Validate(s)
}

type DescribeZonesResponseBodyZonesZoneCapacity struct {
	Protocol []*string `json:"Protocol,omitempty" xml:"Protocol,omitempty" type:"Repeated"`
}

func (s DescribeZonesResponseBodyZonesZoneCapacity) String() string {
	return dara.Prettify(s)
}

func (s DescribeZonesResponseBodyZonesZoneCapacity) GoString() string {
	return s.String()
}

func (s *DescribeZonesResponseBodyZonesZoneCapacity) GetProtocol() []*string {
	return s.Protocol
}

func (s *DescribeZonesResponseBodyZonesZoneCapacity) SetProtocol(v []*string) *DescribeZonesResponseBodyZonesZoneCapacity {
	s.Protocol = v
	return s
}

func (s *DescribeZonesResponseBodyZonesZoneCapacity) Validate() error {
	return dara.Validate(s)
}

type DescribeZonesResponseBodyZonesZoneInstanceTypes struct {
	InstanceType []*DescribeZonesResponseBodyZonesZoneInstanceTypesInstanceType `json:"InstanceType,omitempty" xml:"InstanceType,omitempty" type:"Repeated"`
}

func (s DescribeZonesResponseBodyZonesZoneInstanceTypes) String() string {
	return dara.Prettify(s)
}

func (s DescribeZonesResponseBodyZonesZoneInstanceTypes) GoString() string {
	return s.String()
}

func (s *DescribeZonesResponseBodyZonesZoneInstanceTypes) GetInstanceType() []*DescribeZonesResponseBodyZonesZoneInstanceTypesInstanceType {
	return s.InstanceType
}

func (s *DescribeZonesResponseBodyZonesZoneInstanceTypes) SetInstanceType(v []*DescribeZonesResponseBodyZonesZoneInstanceTypesInstanceType) *DescribeZonesResponseBodyZonesZoneInstanceTypes {
	s.InstanceType = v
	return s
}

func (s *DescribeZonesResponseBodyZonesZoneInstanceTypes) Validate() error {
	return dara.Validate(s)
}

type DescribeZonesResponseBodyZonesZoneInstanceTypesInstanceType struct {
	// The protocol type.
	//
	// 	- If the FileSystemType parameter is set to standard, the protocol type is nfs or smb.
	//
	// 	- If the FileSystemType parameter is set to extreme, the protocol type is nfs.
	//
	// 	- If the FileSystemType parameter is set to cpfs, the protocol type is cpfs.
	//
	// > CPFS file systems are available only on the China site (aliyun.com).
	//
	// example:
	//
	// nfs
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The storage type.
	//
	// 	- If the FileSystemType parameter is set to standard, the storage type is Performance or Capacity.
	//
	// 	- If the FileSystemType parameter is set to extreme, the storage type is standard or advance.
	//
	// 	- If the FileSystemType parameter is set to cpfs, the storage type is advance_100 (100 MB/s/TiB baseline) or advance_200 (200 MB/s/TiB baseline).
	//
	// > CPFS file systems are available only on the China site (aliyun.com).
	//
	// example:
	//
	// Capacity
	StorageType *string `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
}

func (s DescribeZonesResponseBodyZonesZoneInstanceTypesInstanceType) String() string {
	return dara.Prettify(s)
}

func (s DescribeZonesResponseBodyZonesZoneInstanceTypesInstanceType) GoString() string {
	return s.String()
}

func (s *DescribeZonesResponseBodyZonesZoneInstanceTypesInstanceType) GetProtocolType() *string {
	return s.ProtocolType
}

func (s *DescribeZonesResponseBodyZonesZoneInstanceTypesInstanceType) GetStorageType() *string {
	return s.StorageType
}

func (s *DescribeZonesResponseBodyZonesZoneInstanceTypesInstanceType) SetProtocolType(v string) *DescribeZonesResponseBodyZonesZoneInstanceTypesInstanceType {
	s.ProtocolType = &v
	return s
}

func (s *DescribeZonesResponseBodyZonesZoneInstanceTypesInstanceType) SetStorageType(v string) *DescribeZonesResponseBodyZonesZoneInstanceTypesInstanceType {
	s.StorageType = &v
	return s
}

func (s *DescribeZonesResponseBodyZonesZoneInstanceTypesInstanceType) Validate() error {
	return dara.Validate(s)
}

type DescribeZonesResponseBodyZonesZonePerformance struct {
	Protocol []*string `json:"Protocol,omitempty" xml:"Protocol,omitempty" type:"Repeated"`
}

func (s DescribeZonesResponseBodyZonesZonePerformance) String() string {
	return dara.Prettify(s)
}

func (s DescribeZonesResponseBodyZonesZonePerformance) GoString() string {
	return s.String()
}

func (s *DescribeZonesResponseBodyZonesZonePerformance) GetProtocol() []*string {
	return s.Protocol
}

func (s *DescribeZonesResponseBodyZonesZonePerformance) SetProtocol(v []*string) *DescribeZonesResponseBodyZonesZonePerformance {
	s.Protocol = v
	return s
}

func (s *DescribeZonesResponseBodyZonesZonePerformance) Validate() error {
	return dara.Validate(s)
}

type iDescribeZonesResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DescribeZonesResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DescribeZonesResponse
	GetStatusCode() *int32
	SetBody(v *DescribeZonesResponseBody) *DescribeZonesResponse
	GetBody() *DescribeZonesResponseBody
}

type DescribeZonesResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeZonesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeZonesResponse) String() string {
	return dara.Prettify(s)
}

func (s DescribeZonesResponse) GoString() string {
	return s.String()
}

func (s *DescribeZonesResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DescribeZonesResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DescribeZonesResponse) GetBody() *DescribeZonesResponseBody {
	return s.Body
}

func (s *DescribeZonesResponse) SetHeaders(v map[string]*string) *DescribeZonesResponse {
	s.Headers = v
	return s
}

func (s *DescribeZonesResponse) SetStatusCode(v int32) *DescribeZonesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeZonesResponse) SetBody(v *DescribeZonesResponseBody) *DescribeZonesResponse {
	s.Body = v
	return s
}

func (s *DescribeZonesResponse) Validate() error {
	return dara.Validate(s)
}

type iDetachVscFromFilesystemsRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientToken(v string) *DetachVscFromFilesystemsRequest
	GetClientToken() *string
	SetResourceIds(v []*DetachVscFromFilesystemsRequestResourceIds) *DetachVscFromFilesystemsRequest
	GetResourceIds() []*DetachVscFromFilesystemsRequestResourceIds
}

type DetachVscFromFilesystemsRequest struct {
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// This parameter is required.
	ResourceIds []*DetachVscFromFilesystemsRequestResourceIds `json:"ResourceIds,omitempty" xml:"ResourceIds,omitempty" type:"Repeated"`
}

func (s DetachVscFromFilesystemsRequest) String() string {
	return dara.Prettify(s)
}

func (s DetachVscFromFilesystemsRequest) GoString() string {
	return s.String()
}

func (s *DetachVscFromFilesystemsRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *DetachVscFromFilesystemsRequest) GetResourceIds() []*DetachVscFromFilesystemsRequestResourceIds {
	return s.ResourceIds
}

func (s *DetachVscFromFilesystemsRequest) SetClientToken(v string) *DetachVscFromFilesystemsRequest {
	s.ClientToken = &v
	return s
}

func (s *DetachVscFromFilesystemsRequest) SetResourceIds(v []*DetachVscFromFilesystemsRequestResourceIds) *DetachVscFromFilesystemsRequest {
	s.ResourceIds = v
	return s
}

func (s *DetachVscFromFilesystemsRequest) Validate() error {
	return dara.Validate(s)
}

type DetachVscFromFilesystemsRequestResourceIds struct {
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	VscId        *string `json:"VscId,omitempty" xml:"VscId,omitempty"`
}

func (s DetachVscFromFilesystemsRequestResourceIds) String() string {
	return dara.Prettify(s)
}

func (s DetachVscFromFilesystemsRequestResourceIds) GoString() string {
	return s.String()
}

func (s *DetachVscFromFilesystemsRequestResourceIds) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DetachVscFromFilesystemsRequestResourceIds) GetVscId() *string {
	return s.VscId
}

func (s *DetachVscFromFilesystemsRequestResourceIds) SetFileSystemId(v string) *DetachVscFromFilesystemsRequestResourceIds {
	s.FileSystemId = &v
	return s
}

func (s *DetachVscFromFilesystemsRequestResourceIds) SetVscId(v string) *DetachVscFromFilesystemsRequestResourceIds {
	s.VscId = &v
	return s
}

func (s *DetachVscFromFilesystemsRequestResourceIds) Validate() error {
	return dara.Validate(s)
}

type iDetachVscFromFilesystemsResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *DetachVscFromFilesystemsResponseBody
	GetRequestId() *string
}

type DetachVscFromFilesystemsResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DetachVscFromFilesystemsResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DetachVscFromFilesystemsResponseBody) GoString() string {
	return s.String()
}

func (s *DetachVscFromFilesystemsResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DetachVscFromFilesystemsResponseBody) SetRequestId(v string) *DetachVscFromFilesystemsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DetachVscFromFilesystemsResponseBody) Validate() error {
	return dara.Validate(s)
}

type iDetachVscFromFilesystemsResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DetachVscFromFilesystemsResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DetachVscFromFilesystemsResponse
	GetStatusCode() *int32
	SetBody(v *DetachVscFromFilesystemsResponseBody) *DetachVscFromFilesystemsResponse
	GetBody() *DetachVscFromFilesystemsResponseBody
}

type DetachVscFromFilesystemsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DetachVscFromFilesystemsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DetachVscFromFilesystemsResponse) String() string {
	return dara.Prettify(s)
}

func (s DetachVscFromFilesystemsResponse) GoString() string {
	return s.String()
}

func (s *DetachVscFromFilesystemsResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DetachVscFromFilesystemsResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DetachVscFromFilesystemsResponse) GetBody() *DetachVscFromFilesystemsResponseBody {
	return s.Body
}

func (s *DetachVscFromFilesystemsResponse) SetHeaders(v map[string]*string) *DetachVscFromFilesystemsResponse {
	s.Headers = v
	return s
}

func (s *DetachVscFromFilesystemsResponse) SetStatusCode(v int32) *DetachVscFromFilesystemsResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachVscFromFilesystemsResponse) SetBody(v *DetachVscFromFilesystemsResponseBody) *DetachVscFromFilesystemsResponse {
	s.Body = v
	return s
}

func (s *DetachVscFromFilesystemsResponse) Validate() error {
	return dara.Validate(s)
}

type iDetachVscMountPointRequest interface {
	dara.Model
	String() string
	GoString() string
	SetDescription(v string) *DetachVscMountPointRequest
	GetDescription() *string
	SetFileSystemId(v string) *DetachVscMountPointRequest
	GetFileSystemId() *string
	SetMountPointDomain(v string) *DetachVscMountPointRequest
	GetMountPointDomain() *string
	SetVscAttachInfos(v []*DetachVscMountPointRequestVscAttachInfos) *DetachVscMountPointRequest
	GetVscAttachInfos() []*DetachVscMountPointRequestVscAttachInfos
}

type DetachVscMountPointRequest struct {
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// This parameter is required.
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// This parameter is required.
	MountPointDomain *string `json:"MountPointDomain,omitempty" xml:"MountPointDomain,omitempty"`
	// This parameter is required.
	VscAttachInfos []*DetachVscMountPointRequestVscAttachInfos `json:"VscAttachInfos,omitempty" xml:"VscAttachInfos,omitempty" type:"Repeated"`
}

func (s DetachVscMountPointRequest) String() string {
	return dara.Prettify(s)
}

func (s DetachVscMountPointRequest) GoString() string {
	return s.String()
}

func (s *DetachVscMountPointRequest) GetDescription() *string {
	return s.Description
}

func (s *DetachVscMountPointRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DetachVscMountPointRequest) GetMountPointDomain() *string {
	return s.MountPointDomain
}

func (s *DetachVscMountPointRequest) GetVscAttachInfos() []*DetachVscMountPointRequestVscAttachInfos {
	return s.VscAttachInfos
}

func (s *DetachVscMountPointRequest) SetDescription(v string) *DetachVscMountPointRequest {
	s.Description = &v
	return s
}

func (s *DetachVscMountPointRequest) SetFileSystemId(v string) *DetachVscMountPointRequest {
	s.FileSystemId = &v
	return s
}

func (s *DetachVscMountPointRequest) SetMountPointDomain(v string) *DetachVscMountPointRequest {
	s.MountPointDomain = &v
	return s
}

func (s *DetachVscMountPointRequest) SetVscAttachInfos(v []*DetachVscMountPointRequestVscAttachInfos) *DetachVscMountPointRequest {
	s.VscAttachInfos = v
	return s
}

func (s *DetachVscMountPointRequest) Validate() error {
	return dara.Validate(s)
}

type DetachVscMountPointRequestVscAttachInfos struct {
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	VscId      *string `json:"VscId,omitempty" xml:"VscId,omitempty"`
}

func (s DetachVscMountPointRequestVscAttachInfos) String() string {
	return dara.Prettify(s)
}

func (s DetachVscMountPointRequestVscAttachInfos) GoString() string {
	return s.String()
}

func (s *DetachVscMountPointRequestVscAttachInfos) GetInstanceId() *string {
	return s.InstanceId
}

func (s *DetachVscMountPointRequestVscAttachInfos) GetVscId() *string {
	return s.VscId
}

func (s *DetachVscMountPointRequestVscAttachInfos) SetInstanceId(v string) *DetachVscMountPointRequestVscAttachInfos {
	s.InstanceId = &v
	return s
}

func (s *DetachVscMountPointRequestVscAttachInfos) SetVscId(v string) *DetachVscMountPointRequestVscAttachInfos {
	s.VscId = &v
	return s
}

func (s *DetachVscMountPointRequestVscAttachInfos) Validate() error {
	return dara.Validate(s)
}

type iDetachVscMountPointResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *DetachVscMountPointResponseBody
	GetRequestId() *string
}

type DetachVscMountPointResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DetachVscMountPointResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DetachVscMountPointResponseBody) GoString() string {
	return s.String()
}

func (s *DetachVscMountPointResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DetachVscMountPointResponseBody) SetRequestId(v string) *DetachVscMountPointResponseBody {
	s.RequestId = &v
	return s
}

func (s *DetachVscMountPointResponseBody) Validate() error {
	return dara.Validate(s)
}

type iDetachVscMountPointResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DetachVscMountPointResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DetachVscMountPointResponse
	GetStatusCode() *int32
	SetBody(v *DetachVscMountPointResponseBody) *DetachVscMountPointResponse
	GetBody() *DetachVscMountPointResponseBody
}

type DetachVscMountPointResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DetachVscMountPointResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DetachVscMountPointResponse) String() string {
	return dara.Prettify(s)
}

func (s DetachVscMountPointResponse) GoString() string {
	return s.String()
}

func (s *DetachVscMountPointResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DetachVscMountPointResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DetachVscMountPointResponse) GetBody() *DetachVscMountPointResponseBody {
	return s.Body
}

func (s *DetachVscMountPointResponse) SetHeaders(v map[string]*string) *DetachVscMountPointResponse {
	s.Headers = v
	return s
}

func (s *DetachVscMountPointResponse) SetStatusCode(v int32) *DetachVscMountPointResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachVscMountPointResponse) SetBody(v *DetachVscMountPointResponseBody) *DetachVscMountPointResponse {
	s.Body = v
	return s
}

func (s *DetachVscMountPointResponse) Validate() error {
	return dara.Validate(s)
}

type iDisableAndCleanRecycleBinRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *DisableAndCleanRecycleBinRequest
	GetFileSystemId() *string
}

type DisableAndCleanRecycleBinRequest struct {
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1ca404****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
}

func (s DisableAndCleanRecycleBinRequest) String() string {
	return dara.Prettify(s)
}

func (s DisableAndCleanRecycleBinRequest) GoString() string {
	return s.String()
}

func (s *DisableAndCleanRecycleBinRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DisableAndCleanRecycleBinRequest) SetFileSystemId(v string) *DisableAndCleanRecycleBinRequest {
	s.FileSystemId = &v
	return s
}

func (s *DisableAndCleanRecycleBinRequest) Validate() error {
	return dara.Validate(s)
}

type iDisableAndCleanRecycleBinResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *DisableAndCleanRecycleBinResponseBody
	GetRequestId() *string
}

type DisableAndCleanRecycleBinResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 9E15E394-38A6-457A-A62A-D9797C9A****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DisableAndCleanRecycleBinResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DisableAndCleanRecycleBinResponseBody) GoString() string {
	return s.String()
}

func (s *DisableAndCleanRecycleBinResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DisableAndCleanRecycleBinResponseBody) SetRequestId(v string) *DisableAndCleanRecycleBinResponseBody {
	s.RequestId = &v
	return s
}

func (s *DisableAndCleanRecycleBinResponseBody) Validate() error {
	return dara.Validate(s)
}

type iDisableAndCleanRecycleBinResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DisableAndCleanRecycleBinResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DisableAndCleanRecycleBinResponse
	GetStatusCode() *int32
	SetBody(v *DisableAndCleanRecycleBinResponseBody) *DisableAndCleanRecycleBinResponse
	GetBody() *DisableAndCleanRecycleBinResponseBody
}

type DisableAndCleanRecycleBinResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DisableAndCleanRecycleBinResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DisableAndCleanRecycleBinResponse) String() string {
	return dara.Prettify(s)
}

func (s DisableAndCleanRecycleBinResponse) GoString() string {
	return s.String()
}

func (s *DisableAndCleanRecycleBinResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DisableAndCleanRecycleBinResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DisableAndCleanRecycleBinResponse) GetBody() *DisableAndCleanRecycleBinResponseBody {
	return s.Body
}

func (s *DisableAndCleanRecycleBinResponse) SetHeaders(v map[string]*string) *DisableAndCleanRecycleBinResponse {
	s.Headers = v
	return s
}

func (s *DisableAndCleanRecycleBinResponse) SetStatusCode(v int32) *DisableAndCleanRecycleBinResponse {
	s.StatusCode = &v
	return s
}

func (s *DisableAndCleanRecycleBinResponse) SetBody(v *DisableAndCleanRecycleBinResponseBody) *DisableAndCleanRecycleBinResponse {
	s.Body = v
	return s
}

func (s *DisableAndCleanRecycleBinResponse) Validate() error {
	return dara.Validate(s)
}

type iDisableNfsAclRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *DisableNfsAclRequest
	GetFileSystemId() *string
}

type DisableNfsAclRequest struct {
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 91fcdxxxx
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
}

func (s DisableNfsAclRequest) String() string {
	return dara.Prettify(s)
}

func (s DisableNfsAclRequest) GoString() string {
	return s.String()
}

func (s *DisableNfsAclRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DisableNfsAclRequest) SetFileSystemId(v string) *DisableNfsAclRequest {
	s.FileSystemId = &v
	return s
}

func (s *DisableNfsAclRequest) Validate() error {
	return dara.Validate(s)
}

type iDisableNfsAclResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *DisableNfsAclResponseBody
	GetRequestId() *string
}

type DisableNfsAclResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 24487C24-AE54-57EC-B4E4-4EDEEEB83B01
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DisableNfsAclResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DisableNfsAclResponseBody) GoString() string {
	return s.String()
}

func (s *DisableNfsAclResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DisableNfsAclResponseBody) SetRequestId(v string) *DisableNfsAclResponseBody {
	s.RequestId = &v
	return s
}

func (s *DisableNfsAclResponseBody) Validate() error {
	return dara.Validate(s)
}

type iDisableNfsAclResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DisableNfsAclResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DisableNfsAclResponse
	GetStatusCode() *int32
	SetBody(v *DisableNfsAclResponseBody) *DisableNfsAclResponse
	GetBody() *DisableNfsAclResponseBody
}

type DisableNfsAclResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DisableNfsAclResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DisableNfsAclResponse) String() string {
	return dara.Prettify(s)
}

func (s DisableNfsAclResponse) GoString() string {
	return s.String()
}

func (s *DisableNfsAclResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DisableNfsAclResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DisableNfsAclResponse) GetBody() *DisableNfsAclResponseBody {
	return s.Body
}

func (s *DisableNfsAclResponse) SetHeaders(v map[string]*string) *DisableNfsAclResponse {
	s.Headers = v
	return s
}

func (s *DisableNfsAclResponse) SetStatusCode(v int32) *DisableNfsAclResponse {
	s.StatusCode = &v
	return s
}

func (s *DisableNfsAclResponse) SetBody(v *DisableNfsAclResponseBody) *DisableNfsAclResponse {
	s.Body = v
	return s
}

func (s *DisableNfsAclResponse) Validate() error {
	return dara.Validate(s)
}

type iDisableSmbAclRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *DisableSmbAclRequest
	GetFileSystemId() *string
}

type DisableSmbAclRequest struct {
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1ca404****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
}

func (s DisableSmbAclRequest) String() string {
	return dara.Prettify(s)
}

func (s DisableSmbAclRequest) GoString() string {
	return s.String()
}

func (s *DisableSmbAclRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *DisableSmbAclRequest) SetFileSystemId(v string) *DisableSmbAclRequest {
	s.FileSystemId = &v
	return s
}

func (s *DisableSmbAclRequest) Validate() error {
	return dara.Validate(s)
}

type iDisableSmbAclResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *DisableSmbAclResponseBody
	GetRequestId() *string
}

type DisableSmbAclResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 98696EF0-1607-4E9D-B01D-F20930B6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DisableSmbAclResponseBody) String() string {
	return dara.Prettify(s)
}

func (s DisableSmbAclResponseBody) GoString() string {
	return s.String()
}

func (s *DisableSmbAclResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *DisableSmbAclResponseBody) SetRequestId(v string) *DisableSmbAclResponseBody {
	s.RequestId = &v
	return s
}

func (s *DisableSmbAclResponseBody) Validate() error {
	return dara.Validate(s)
}

type iDisableSmbAclResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *DisableSmbAclResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *DisableSmbAclResponse
	GetStatusCode() *int32
	SetBody(v *DisableSmbAclResponseBody) *DisableSmbAclResponse
	GetBody() *DisableSmbAclResponseBody
}

type DisableSmbAclResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DisableSmbAclResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DisableSmbAclResponse) String() string {
	return dara.Prettify(s)
}

func (s DisableSmbAclResponse) GoString() string {
	return s.String()
}

func (s *DisableSmbAclResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *DisableSmbAclResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *DisableSmbAclResponse) GetBody() *DisableSmbAclResponseBody {
	return s.Body
}

func (s *DisableSmbAclResponse) SetHeaders(v map[string]*string) *DisableSmbAclResponse {
	s.Headers = v
	return s
}

func (s *DisableSmbAclResponse) SetStatusCode(v int32) *DisableSmbAclResponse {
	s.StatusCode = &v
	return s
}

func (s *DisableSmbAclResponse) SetBody(v *DisableSmbAclResponseBody) *DisableSmbAclResponse {
	s.Body = v
	return s
}

func (s *DisableSmbAclResponse) Validate() error {
	return dara.Validate(s)
}

type iEnableNfsAclRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *EnableNfsAclRequest
	GetFileSystemId() *string
}

type EnableNfsAclRequest struct {
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 43f264xxxx
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
}

func (s EnableNfsAclRequest) String() string {
	return dara.Prettify(s)
}

func (s EnableNfsAclRequest) GoString() string {
	return s.String()
}

func (s *EnableNfsAclRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *EnableNfsAclRequest) SetFileSystemId(v string) *EnableNfsAclRequest {
	s.FileSystemId = &v
	return s
}

func (s *EnableNfsAclRequest) Validate() error {
	return dara.Validate(s)
}

type iEnableNfsAclResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *EnableNfsAclResponseBody
	GetRequestId() *string
}

type EnableNfsAclResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 29F4F360-A6A8-561A-A45B-A0F6882969BA
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s EnableNfsAclResponseBody) String() string {
	return dara.Prettify(s)
}

func (s EnableNfsAclResponseBody) GoString() string {
	return s.String()
}

func (s *EnableNfsAclResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *EnableNfsAclResponseBody) SetRequestId(v string) *EnableNfsAclResponseBody {
	s.RequestId = &v
	return s
}

func (s *EnableNfsAclResponseBody) Validate() error {
	return dara.Validate(s)
}

type iEnableNfsAclResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *EnableNfsAclResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *EnableNfsAclResponse
	GetStatusCode() *int32
	SetBody(v *EnableNfsAclResponseBody) *EnableNfsAclResponse
	GetBody() *EnableNfsAclResponseBody
}

type EnableNfsAclResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *EnableNfsAclResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s EnableNfsAclResponse) String() string {
	return dara.Prettify(s)
}

func (s EnableNfsAclResponse) GoString() string {
	return s.String()
}

func (s *EnableNfsAclResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *EnableNfsAclResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *EnableNfsAclResponse) GetBody() *EnableNfsAclResponseBody {
	return s.Body
}

func (s *EnableNfsAclResponse) SetHeaders(v map[string]*string) *EnableNfsAclResponse {
	s.Headers = v
	return s
}

func (s *EnableNfsAclResponse) SetStatusCode(v int32) *EnableNfsAclResponse {
	s.StatusCode = &v
	return s
}

func (s *EnableNfsAclResponse) SetBody(v *EnableNfsAclResponseBody) *EnableNfsAclResponse {
	s.Body = v
	return s
}

func (s *EnableNfsAclResponse) Validate() error {
	return dara.Validate(s)
}

type iEnableRecycleBinRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *EnableRecycleBinRequest
	GetFileSystemId() *string
	SetReservedDays(v int64) *EnableRecycleBinRequest
	GetReservedDays() *int64
}

type EnableRecycleBinRequest struct {
	// The ID of the file system for which you want to enable the recycle bin feature.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1ca404****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The retention period of the files in the recycle bin. Unit: days.
	//
	// Valid values: 1 to 180.
	//
	// Default value: 3.
	//
	// example:
	//
	// 3
	ReservedDays *int64 `json:"ReservedDays,omitempty" xml:"ReservedDays,omitempty"`
}

func (s EnableRecycleBinRequest) String() string {
	return dara.Prettify(s)
}

func (s EnableRecycleBinRequest) GoString() string {
	return s.String()
}

func (s *EnableRecycleBinRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *EnableRecycleBinRequest) GetReservedDays() *int64 {
	return s.ReservedDays
}

func (s *EnableRecycleBinRequest) SetFileSystemId(v string) *EnableRecycleBinRequest {
	s.FileSystemId = &v
	return s
}

func (s *EnableRecycleBinRequest) SetReservedDays(v int64) *EnableRecycleBinRequest {
	s.ReservedDays = &v
	return s
}

func (s *EnableRecycleBinRequest) Validate() error {
	return dara.Validate(s)
}

type iEnableRecycleBinResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *EnableRecycleBinResponseBody
	GetRequestId() *string
}

type EnableRecycleBinResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 9E15E394-38A6-457A-A62A-D9797C9A****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s EnableRecycleBinResponseBody) String() string {
	return dara.Prettify(s)
}

func (s EnableRecycleBinResponseBody) GoString() string {
	return s.String()
}

func (s *EnableRecycleBinResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *EnableRecycleBinResponseBody) SetRequestId(v string) *EnableRecycleBinResponseBody {
	s.RequestId = &v
	return s
}

func (s *EnableRecycleBinResponseBody) Validate() error {
	return dara.Validate(s)
}

type iEnableRecycleBinResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *EnableRecycleBinResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *EnableRecycleBinResponse
	GetStatusCode() *int32
	SetBody(v *EnableRecycleBinResponseBody) *EnableRecycleBinResponse
	GetBody() *EnableRecycleBinResponseBody
}

type EnableRecycleBinResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *EnableRecycleBinResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s EnableRecycleBinResponse) String() string {
	return dara.Prettify(s)
}

func (s EnableRecycleBinResponse) GoString() string {
	return s.String()
}

func (s *EnableRecycleBinResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *EnableRecycleBinResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *EnableRecycleBinResponse) GetBody() *EnableRecycleBinResponseBody {
	return s.Body
}

func (s *EnableRecycleBinResponse) SetHeaders(v map[string]*string) *EnableRecycleBinResponse {
	s.Headers = v
	return s
}

func (s *EnableRecycleBinResponse) SetStatusCode(v int32) *EnableRecycleBinResponse {
	s.StatusCode = &v
	return s
}

func (s *EnableRecycleBinResponse) SetBody(v *EnableRecycleBinResponseBody) *EnableRecycleBinResponse {
	s.Body = v
	return s
}

func (s *EnableRecycleBinResponse) Validate() error {
	return dara.Validate(s)
}

type iEnableSmbAclRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAuthCenter(v string) *EnableSmbAclRequest
	GetAuthCenter() *string
	SetAuthMethod(v string) *EnableSmbAclRequest
	GetAuthMethod() *string
	SetFileSystemId(v string) *EnableSmbAclRequest
	GetFileSystemId() *string
	SetKeytab(v string) *EnableSmbAclRequest
	GetKeytab() *string
	SetKeytabMd5(v string) *EnableSmbAclRequest
	GetKeytabMd5() *string
}

type EnableSmbAclRequest struct {
	AuthCenter *string `json:"AuthCenter,omitempty" xml:"AuthCenter,omitempty"`
	AuthMethod *string `json:"AuthMethod,omitempty" xml:"AuthMethod,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 31a8e4****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The string that is generated after the system encodes the keytab file by using Base64.
	//
	// example:
	//
	// BQIAAABHAAIADUFMSUFEVEVTVC5DT00ABGNpZnMAGXNtYnNlcnZlcjI0LmFsaWFkdGVzdC5jb20AAAABAAAAAAEAAQAIqIx6v7p11oUAAABHAAIADUFMSUFEVEVTVC5DT00ABGNpZnMAGXNtYnNlcnZlcjI0LmFsaWFkdGVzdC5jb20AAAABAAAAAAEAAwAIqIx6v7p11oUAAABPAAIADUFMSUFEVEVTVC5DT00ABGNpZnMAGXNtYnNlcnZlcjI0LmFsaWFkdGVzdC5jb20AAAABAAAAAAEAFwAQnQZWB3RAPHU7PMIJyBWePAAAAF8AAgANQUxJQURURVNULkNPTQAEY2lmcwAZc21ic2VydmVyMjQuYWxpYWR0ZXN0LmNvbQAAAAEAAAAAAQASACAGJ7F0s+bcBjf6jD5HlvlRLmPSOW+qDZe0Qk0lQcf8WwAAAE8AAgANQUxJQURURVNULkNPTQAEY2lmcwAZc21ic2VydmVyMjQuYWxpYWR0ZXN0LmNvbQAAAAEAAAAAAQARABDdFmanrSIatnDDhxxxxx
	Keytab *string `json:"Keytab,omitempty" xml:"Keytab,omitempty"`
	// The string that is generated after the system encodes the keytab file by using MD5.
	//
	// example:
	//
	// E3CCF7E2416DF04FA958AA4513EAxxxx
	KeytabMd5 *string `json:"KeytabMd5,omitempty" xml:"KeytabMd5,omitempty"`
}

func (s EnableSmbAclRequest) String() string {
	return dara.Prettify(s)
}

func (s EnableSmbAclRequest) GoString() string {
	return s.String()
}

func (s *EnableSmbAclRequest) GetAuthCenter() *string {
	return s.AuthCenter
}

func (s *EnableSmbAclRequest) GetAuthMethod() *string {
	return s.AuthMethod
}

func (s *EnableSmbAclRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *EnableSmbAclRequest) GetKeytab() *string {
	return s.Keytab
}

func (s *EnableSmbAclRequest) GetKeytabMd5() *string {
	return s.KeytabMd5
}

func (s *EnableSmbAclRequest) SetAuthCenter(v string) *EnableSmbAclRequest {
	s.AuthCenter = &v
	return s
}

func (s *EnableSmbAclRequest) SetAuthMethod(v string) *EnableSmbAclRequest {
	s.AuthMethod = &v
	return s
}

func (s *EnableSmbAclRequest) SetFileSystemId(v string) *EnableSmbAclRequest {
	s.FileSystemId = &v
	return s
}

func (s *EnableSmbAclRequest) SetKeytab(v string) *EnableSmbAclRequest {
	s.Keytab = &v
	return s
}

func (s *EnableSmbAclRequest) SetKeytabMd5(v string) *EnableSmbAclRequest {
	s.KeytabMd5 = &v
	return s
}

func (s *EnableSmbAclRequest) Validate() error {
	return dara.Validate(s)
}

type iEnableSmbAclResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *EnableSmbAclResponseBody
	GetRequestId() *string
}

type EnableSmbAclResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 98696EF0-1607-4E9D-B01D-F20930B6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s EnableSmbAclResponseBody) String() string {
	return dara.Prettify(s)
}

func (s EnableSmbAclResponseBody) GoString() string {
	return s.String()
}

func (s *EnableSmbAclResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *EnableSmbAclResponseBody) SetRequestId(v string) *EnableSmbAclResponseBody {
	s.RequestId = &v
	return s
}

func (s *EnableSmbAclResponseBody) Validate() error {
	return dara.Validate(s)
}

type iEnableSmbAclResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *EnableSmbAclResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *EnableSmbAclResponse
	GetStatusCode() *int32
	SetBody(v *EnableSmbAclResponseBody) *EnableSmbAclResponse
	GetBody() *EnableSmbAclResponseBody
}

type EnableSmbAclResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *EnableSmbAclResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s EnableSmbAclResponse) String() string {
	return dara.Prettify(s)
}

func (s EnableSmbAclResponse) GoString() string {
	return s.String()
}

func (s *EnableSmbAclResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *EnableSmbAclResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *EnableSmbAclResponse) GetBody() *EnableSmbAclResponseBody {
	return s.Body
}

func (s *EnableSmbAclResponse) SetHeaders(v map[string]*string) *EnableSmbAclResponse {
	s.Headers = v
	return s
}

func (s *EnableSmbAclResponse) SetStatusCode(v int32) *EnableSmbAclResponse {
	s.StatusCode = &v
	return s
}

func (s *EnableSmbAclResponse) SetBody(v *EnableSmbAclResponseBody) *EnableSmbAclResponse {
	s.Body = v
	return s
}

func (s *EnableSmbAclResponse) Validate() error {
	return dara.Validate(s)
}

type iGetDirectoryOrFilePropertiesRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *GetDirectoryOrFilePropertiesRequest
	GetFileSystemId() *string
	SetPath(v string) *GetDirectoryOrFilePropertiesRequest
	GetPath() *string
}

type GetDirectoryOrFilePropertiesRequest struct {
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 31a8e4****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The absolute path of the directory.
	//
	// The path must start with a forward slash (/) and must be a path that exists in the mount target.
	//
	// This parameter is required.
	//
	// example:
	//
	// /pathway/to/folder
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s GetDirectoryOrFilePropertiesRequest) String() string {
	return dara.Prettify(s)
}

func (s GetDirectoryOrFilePropertiesRequest) GoString() string {
	return s.String()
}

func (s *GetDirectoryOrFilePropertiesRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *GetDirectoryOrFilePropertiesRequest) GetPath() *string {
	return s.Path
}

func (s *GetDirectoryOrFilePropertiesRequest) SetFileSystemId(v string) *GetDirectoryOrFilePropertiesRequest {
	s.FileSystemId = &v
	return s
}

func (s *GetDirectoryOrFilePropertiesRequest) SetPath(v string) *GetDirectoryOrFilePropertiesRequest {
	s.Path = &v
	return s
}

func (s *GetDirectoryOrFilePropertiesRequest) Validate() error {
	return dara.Validate(s)
}

type iGetDirectoryOrFilePropertiesResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetEntry(v *GetDirectoryOrFilePropertiesResponseBodyEntry) *GetDirectoryOrFilePropertiesResponseBody
	GetEntry() *GetDirectoryOrFilePropertiesResponseBodyEntry
	SetRequestId(v string) *GetDirectoryOrFilePropertiesResponseBody
	GetRequestId() *string
}

type GetDirectoryOrFilePropertiesResponseBody struct {
	// The details about the files or directories.
	Entry *GetDirectoryOrFilePropertiesResponseBodyEntry `json:"Entry,omitempty" xml:"Entry,omitempty" type:"Struct"`
	// The request ID.
	//
	// example:
	//
	// 2D69A58F-345C-4FDE-88E4-BF518948****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetDirectoryOrFilePropertiesResponseBody) String() string {
	return dara.Prettify(s)
}

func (s GetDirectoryOrFilePropertiesResponseBody) GoString() string {
	return s.String()
}

func (s *GetDirectoryOrFilePropertiesResponseBody) GetEntry() *GetDirectoryOrFilePropertiesResponseBodyEntry {
	return s.Entry
}

func (s *GetDirectoryOrFilePropertiesResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *GetDirectoryOrFilePropertiesResponseBody) SetEntry(v *GetDirectoryOrFilePropertiesResponseBodyEntry) *GetDirectoryOrFilePropertiesResponseBody {
	s.Entry = v
	return s
}

func (s *GetDirectoryOrFilePropertiesResponseBody) SetRequestId(v string) *GetDirectoryOrFilePropertiesResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDirectoryOrFilePropertiesResponseBody) Validate() error {
	return dara.Validate(s)
}

type GetDirectoryOrFilePropertiesResponseBodyEntry struct {
	// The time when the file was queried.
	//
	// The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format.
	//
	// This parameter is returned only if the value of the Type parameter is File.
	//
	// example:
	//
	// 2021-02-01T10:08:08Z
	ATime *string `json:"ATime,omitempty" xml:"ATime,omitempty"`
	// The time when the raw data was modified.
	//
	// The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format.
	//
	// This parameter is returned only if the value of the Type parameter is File.
	//
	// example:
	//
	// 2021-02-11T10:08:10Z
	CTime *string `json:"CTime,omitempty" xml:"CTime,omitempty"`
	// Indicates whether the directory contains files stored in the Archive storage class.
	//
	// This parameter is returned only if the Type parameter is set to Directory.
	//
	// Valid values:
	//
	// 	- true: The directory contains files stored in the Archive storage class.
	//
	// 	- false: The directory does not contain files stored in the Archive storage class.
	//
	// example:
	//
	// false
	HasArchiveFile *bool `json:"HasArchiveFile,omitempty" xml:"HasArchiveFile,omitempty"`
	// Indicates whether the directory contains files stored in the IA storage medium.
	//
	// This parameter is returned only if the value of the Type parameter is Directory.
	//
	// Valid values:
	//
	// 	- true: The directory contains files stored in the IA storage medium.
	//
	// 	- false: The directory does not contain files stored in the IA storage medium.
	//
	// example:
	//
	// true
	HasInfrequentAccessFile *bool `json:"HasInfrequentAccessFile,omitempty" xml:"HasInfrequentAccessFile,omitempty"`
	// The file or directory inode.
	//
	// example:
	//
	// 40
	Inode *string `json:"Inode,omitempty" xml:"Inode,omitempty"`
	// The time when the file was modified.
	//
	// The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format.
	//
	// This parameter is returned only if the value of the Type parameter is File.
	//
	// example:
	//
	// 2021-02-11T10:08:08Z
	MTime *string `json:"MTime,omitempty" xml:"MTime,omitempty"`
	// The name of the file or directory.
	//
	// example:
	//
	// file.txt
	Name                     *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OfflineDuration          *int64  `json:"OfflineDuration,omitempty" xml:"OfflineDuration,omitempty"`
	OfflineUnchangedDuration *int64  `json:"OfflineUnchangedDuration,omitempty" xml:"OfflineUnchangedDuration,omitempty"`
	// The time when the last data retrieval task was run.
	//
	// The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format.
	//
	// This parameter is returned only if the value of the Type parameter is File.
	//
	// example:
	//
	// 2021-02-11T10:08:08Z
	RetrieveTime *string `json:"RetrieveTime,omitempty" xml:"RetrieveTime,omitempty"`
	// The size of the file.
	//
	// Unit: bytes.
	//
	// This parameter is returned only if the value of the Type parameter is File.
	//
	// example:
	//
	// 1024
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The storage type of the file.
	//
	// This parameter is returned only if the value of the Type parameter is File.
	//
	// Valid values:
	//
	// 	- standard: General-purpose NAS file system
	//
	// 	- InfrequentAccess: IA storage medium
	//
	// example:
	//
	// InfrequentAccess
	StorageType *string `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
	// The type of the query result.
	//
	// Valid values:
	//
	// 	- File
	//
	// 	- Directory
	//
	// example:
	//
	// File
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetDirectoryOrFilePropertiesResponseBodyEntry) String() string {
	return dara.Prettify(s)
}

func (s GetDirectoryOrFilePropertiesResponseBodyEntry) GoString() string {
	return s.String()
}

func (s *GetDirectoryOrFilePropertiesResponseBodyEntry) GetATime() *string {
	return s.ATime
}

func (s *GetDirectoryOrFilePropertiesResponseBodyEntry) GetCTime() *string {
	return s.CTime
}

func (s *GetDirectoryOrFilePropertiesResponseBodyEntry) GetHasArchiveFile() *bool {
	return s.HasArchiveFile
}

func (s *GetDirectoryOrFilePropertiesResponseBodyEntry) GetHasInfrequentAccessFile() *bool {
	return s.HasInfrequentAccessFile
}

func (s *GetDirectoryOrFilePropertiesResponseBodyEntry) GetInode() *string {
	return s.Inode
}

func (s *GetDirectoryOrFilePropertiesResponseBodyEntry) GetMTime() *string {
	return s.MTime
}

func (s *GetDirectoryOrFilePropertiesResponseBodyEntry) GetName() *string {
	return s.Name
}

func (s *GetDirectoryOrFilePropertiesResponseBodyEntry) GetOfflineDuration() *int64 {
	return s.OfflineDuration
}

func (s *GetDirectoryOrFilePropertiesResponseBodyEntry) GetOfflineUnchangedDuration() *int64 {
	return s.OfflineUnchangedDuration
}

func (s *GetDirectoryOrFilePropertiesResponseBodyEntry) GetRetrieveTime() *string {
	return s.RetrieveTime
}

func (s *GetDirectoryOrFilePropertiesResponseBodyEntry) GetSize() *int64 {
	return s.Size
}

func (s *GetDirectoryOrFilePropertiesResponseBodyEntry) GetStorageType() *string {
	return s.StorageType
}

func (s *GetDirectoryOrFilePropertiesResponseBodyEntry) GetType() *string {
	return s.Type
}

func (s *GetDirectoryOrFilePropertiesResponseBodyEntry) SetATime(v string) *GetDirectoryOrFilePropertiesResponseBodyEntry {
	s.ATime = &v
	return s
}

func (s *GetDirectoryOrFilePropertiesResponseBodyEntry) SetCTime(v string) *GetDirectoryOrFilePropertiesResponseBodyEntry {
	s.CTime = &v
	return s
}

func (s *GetDirectoryOrFilePropertiesResponseBodyEntry) SetHasArchiveFile(v bool) *GetDirectoryOrFilePropertiesResponseBodyEntry {
	s.HasArchiveFile = &v
	return s
}

func (s *GetDirectoryOrFilePropertiesResponseBodyEntry) SetHasInfrequentAccessFile(v bool) *GetDirectoryOrFilePropertiesResponseBodyEntry {
	s.HasInfrequentAccessFile = &v
	return s
}

func (s *GetDirectoryOrFilePropertiesResponseBodyEntry) SetInode(v string) *GetDirectoryOrFilePropertiesResponseBodyEntry {
	s.Inode = &v
	return s
}

func (s *GetDirectoryOrFilePropertiesResponseBodyEntry) SetMTime(v string) *GetDirectoryOrFilePropertiesResponseBodyEntry {
	s.MTime = &v
	return s
}

func (s *GetDirectoryOrFilePropertiesResponseBodyEntry) SetName(v string) *GetDirectoryOrFilePropertiesResponseBodyEntry {
	s.Name = &v
	return s
}

func (s *GetDirectoryOrFilePropertiesResponseBodyEntry) SetOfflineDuration(v int64) *GetDirectoryOrFilePropertiesResponseBodyEntry {
	s.OfflineDuration = &v
	return s
}

func (s *GetDirectoryOrFilePropertiesResponseBodyEntry) SetOfflineUnchangedDuration(v int64) *GetDirectoryOrFilePropertiesResponseBodyEntry {
	s.OfflineUnchangedDuration = &v
	return s
}

func (s *GetDirectoryOrFilePropertiesResponseBodyEntry) SetRetrieveTime(v string) *GetDirectoryOrFilePropertiesResponseBodyEntry {
	s.RetrieveTime = &v
	return s
}

func (s *GetDirectoryOrFilePropertiesResponseBodyEntry) SetSize(v int64) *GetDirectoryOrFilePropertiesResponseBodyEntry {
	s.Size = &v
	return s
}

func (s *GetDirectoryOrFilePropertiesResponseBodyEntry) SetStorageType(v string) *GetDirectoryOrFilePropertiesResponseBodyEntry {
	s.StorageType = &v
	return s
}

func (s *GetDirectoryOrFilePropertiesResponseBodyEntry) SetType(v string) *GetDirectoryOrFilePropertiesResponseBodyEntry {
	s.Type = &v
	return s
}

func (s *GetDirectoryOrFilePropertiesResponseBodyEntry) Validate() error {
	return dara.Validate(s)
}

type iGetDirectoryOrFilePropertiesResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *GetDirectoryOrFilePropertiesResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *GetDirectoryOrFilePropertiesResponse
	GetStatusCode() *int32
	SetBody(v *GetDirectoryOrFilePropertiesResponseBody) *GetDirectoryOrFilePropertiesResponse
	GetBody() *GetDirectoryOrFilePropertiesResponseBody
}

type GetDirectoryOrFilePropertiesResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetDirectoryOrFilePropertiesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetDirectoryOrFilePropertiesResponse) String() string {
	return dara.Prettify(s)
}

func (s GetDirectoryOrFilePropertiesResponse) GoString() string {
	return s.String()
}

func (s *GetDirectoryOrFilePropertiesResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *GetDirectoryOrFilePropertiesResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *GetDirectoryOrFilePropertiesResponse) GetBody() *GetDirectoryOrFilePropertiesResponseBody {
	return s.Body
}

func (s *GetDirectoryOrFilePropertiesResponse) SetHeaders(v map[string]*string) *GetDirectoryOrFilePropertiesResponse {
	s.Headers = v
	return s
}

func (s *GetDirectoryOrFilePropertiesResponse) SetStatusCode(v int32) *GetDirectoryOrFilePropertiesResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDirectoryOrFilePropertiesResponse) SetBody(v *GetDirectoryOrFilePropertiesResponseBody) *GetDirectoryOrFilePropertiesResponse {
	s.Body = v
	return s
}

func (s *GetDirectoryOrFilePropertiesResponse) Validate() error {
	return dara.Validate(s)
}

type iGetLifecycleRuleTimeRangeRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *GetLifecycleRuleTimeRangeRequest
	GetFileSystemId() *string
	SetPaths(v []*string) *GetLifecycleRuleTimeRangeRequest
	GetPaths() []*string
	SetStorageType(v string) *GetLifecycleRuleTimeRangeRequest
	GetStorageType() *string
}

type GetLifecycleRuleTimeRangeRequest struct {
	// This parameter is required.
	FileSystemId *string   `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	Paths        []*string `json:"Paths,omitempty" xml:"Paths,omitempty" type:"Repeated"`
	// This parameter is required.
	StorageType *string `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
}

func (s GetLifecycleRuleTimeRangeRequest) String() string {
	return dara.Prettify(s)
}

func (s GetLifecycleRuleTimeRangeRequest) GoString() string {
	return s.String()
}

func (s *GetLifecycleRuleTimeRangeRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *GetLifecycleRuleTimeRangeRequest) GetPaths() []*string {
	return s.Paths
}

func (s *GetLifecycleRuleTimeRangeRequest) GetStorageType() *string {
	return s.StorageType
}

func (s *GetLifecycleRuleTimeRangeRequest) SetFileSystemId(v string) *GetLifecycleRuleTimeRangeRequest {
	s.FileSystemId = &v
	return s
}

func (s *GetLifecycleRuleTimeRangeRequest) SetPaths(v []*string) *GetLifecycleRuleTimeRangeRequest {
	s.Paths = v
	return s
}

func (s *GetLifecycleRuleTimeRangeRequest) SetStorageType(v string) *GetLifecycleRuleTimeRangeRequest {
	s.StorageType = &v
	return s
}

func (s *GetLifecycleRuleTimeRangeRequest) Validate() error {
	return dara.Validate(s)
}

type iGetLifecycleRuleTimeRangeResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetData(v *GetLifecycleRuleTimeRangeResponseBodyData) *GetLifecycleRuleTimeRangeResponseBody
	GetData() *GetLifecycleRuleTimeRangeResponseBodyData
	SetRequestId(v string) *GetLifecycleRuleTimeRangeResponseBody
	GetRequestId() *string
}

type GetLifecycleRuleTimeRangeResponseBody struct {
	Data      *GetLifecycleRuleTimeRangeResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	RequestId *string                                    `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetLifecycleRuleTimeRangeResponseBody) String() string {
	return dara.Prettify(s)
}

func (s GetLifecycleRuleTimeRangeResponseBody) GoString() string {
	return s.String()
}

func (s *GetLifecycleRuleTimeRangeResponseBody) GetData() *GetLifecycleRuleTimeRangeResponseBodyData {
	return s.Data
}

func (s *GetLifecycleRuleTimeRangeResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *GetLifecycleRuleTimeRangeResponseBody) SetData(v *GetLifecycleRuleTimeRangeResponseBodyData) *GetLifecycleRuleTimeRangeResponseBody {
	s.Data = v
	return s
}

func (s *GetLifecycleRuleTimeRangeResponseBody) SetRequestId(v string) *GetLifecycleRuleTimeRangeResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetLifecycleRuleTimeRangeResponseBody) Validate() error {
	return dara.Validate(s)
}

type GetLifecycleRuleTimeRangeResponseBodyData struct {
	HasValidRange  *bool  `json:"HasValidRange,omitempty" xml:"HasValidRange,omitempty"`
	SecondsMaximum *int64 `json:"SecondsMaximum,omitempty" xml:"SecondsMaximum,omitempty"`
	SecondsMinimum *int64 `json:"SecondsMinimum,omitempty" xml:"SecondsMinimum,omitempty"`
}

func (s GetLifecycleRuleTimeRangeResponseBodyData) String() string {
	return dara.Prettify(s)
}

func (s GetLifecycleRuleTimeRangeResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetLifecycleRuleTimeRangeResponseBodyData) GetHasValidRange() *bool {
	return s.HasValidRange
}

func (s *GetLifecycleRuleTimeRangeResponseBodyData) GetSecondsMaximum() *int64 {
	return s.SecondsMaximum
}

func (s *GetLifecycleRuleTimeRangeResponseBodyData) GetSecondsMinimum() *int64 {
	return s.SecondsMinimum
}

func (s *GetLifecycleRuleTimeRangeResponseBodyData) SetHasValidRange(v bool) *GetLifecycleRuleTimeRangeResponseBodyData {
	s.HasValidRange = &v
	return s
}

func (s *GetLifecycleRuleTimeRangeResponseBodyData) SetSecondsMaximum(v int64) *GetLifecycleRuleTimeRangeResponseBodyData {
	s.SecondsMaximum = &v
	return s
}

func (s *GetLifecycleRuleTimeRangeResponseBodyData) SetSecondsMinimum(v int64) *GetLifecycleRuleTimeRangeResponseBodyData {
	s.SecondsMinimum = &v
	return s
}

func (s *GetLifecycleRuleTimeRangeResponseBodyData) Validate() error {
	return dara.Validate(s)
}

type iGetLifecycleRuleTimeRangeResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *GetLifecycleRuleTimeRangeResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *GetLifecycleRuleTimeRangeResponse
	GetStatusCode() *int32
	SetBody(v *GetLifecycleRuleTimeRangeResponseBody) *GetLifecycleRuleTimeRangeResponse
	GetBody() *GetLifecycleRuleTimeRangeResponseBody
}

type GetLifecycleRuleTimeRangeResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetLifecycleRuleTimeRangeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetLifecycleRuleTimeRangeResponse) String() string {
	return dara.Prettify(s)
}

func (s GetLifecycleRuleTimeRangeResponse) GoString() string {
	return s.String()
}

func (s *GetLifecycleRuleTimeRangeResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *GetLifecycleRuleTimeRangeResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *GetLifecycleRuleTimeRangeResponse) GetBody() *GetLifecycleRuleTimeRangeResponseBody {
	return s.Body
}

func (s *GetLifecycleRuleTimeRangeResponse) SetHeaders(v map[string]*string) *GetLifecycleRuleTimeRangeResponse {
	s.Headers = v
	return s
}

func (s *GetLifecycleRuleTimeRangeResponse) SetStatusCode(v int32) *GetLifecycleRuleTimeRangeResponse {
	s.StatusCode = &v
	return s
}

func (s *GetLifecycleRuleTimeRangeResponse) SetBody(v *GetLifecycleRuleTimeRangeResponseBody) *GetLifecycleRuleTimeRangeResponse {
	s.Body = v
	return s
}

func (s *GetLifecycleRuleTimeRangeResponse) Validate() error {
	return dara.Validate(s)
}

type iGetRecycleBinAttributeRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *GetRecycleBinAttributeRequest
	GetFileSystemId() *string
}

type GetRecycleBinAttributeRequest struct {
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1ca404****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
}

func (s GetRecycleBinAttributeRequest) String() string {
	return dara.Prettify(s)
}

func (s GetRecycleBinAttributeRequest) GoString() string {
	return s.String()
}

func (s *GetRecycleBinAttributeRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *GetRecycleBinAttributeRequest) SetFileSystemId(v string) *GetRecycleBinAttributeRequest {
	s.FileSystemId = &v
	return s
}

func (s *GetRecycleBinAttributeRequest) Validate() error {
	return dara.Validate(s)
}

type iGetRecycleBinAttributeResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRecycleBinAttribute(v *GetRecycleBinAttributeResponseBodyRecycleBinAttribute) *GetRecycleBinAttributeResponseBody
	GetRecycleBinAttribute() *GetRecycleBinAttributeResponseBodyRecycleBinAttribute
	SetRequestId(v string) *GetRecycleBinAttributeResponseBody
	GetRequestId() *string
}

type GetRecycleBinAttributeResponseBody struct {
	// The description of the recycle bin.
	RecycleBinAttribute *GetRecycleBinAttributeResponseBodyRecycleBinAttribute `json:"RecycleBinAttribute,omitempty" xml:"RecycleBinAttribute,omitempty" type:"Struct"`
	// The request ID.
	//
	// example:
	//
	// 9E15E394-38A6-457A-A62A-D9797C9A****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetRecycleBinAttributeResponseBody) String() string {
	return dara.Prettify(s)
}

func (s GetRecycleBinAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *GetRecycleBinAttributeResponseBody) GetRecycleBinAttribute() *GetRecycleBinAttributeResponseBodyRecycleBinAttribute {
	return s.RecycleBinAttribute
}

func (s *GetRecycleBinAttributeResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *GetRecycleBinAttributeResponseBody) SetRecycleBinAttribute(v *GetRecycleBinAttributeResponseBodyRecycleBinAttribute) *GetRecycleBinAttributeResponseBody {
	s.RecycleBinAttribute = v
	return s
}

func (s *GetRecycleBinAttributeResponseBody) SetRequestId(v string) *GetRecycleBinAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetRecycleBinAttributeResponseBody) Validate() error {
	return dara.Validate(s)
}

type GetRecycleBinAttributeResponseBodyRecycleBinAttribute struct {
	// The size of the archived data that is dumped to the recycle bin. Unit: bytes.
	//
	// example:
	//
	// 1611661312
	ArchiveSize *int64 `json:"ArchiveSize,omitempty" xml:"ArchiveSize,omitempty"`
	// The time at which the recycle bin was enabled.
	//
	// example:
	//
	// 2021-05-30T10:08:08Z
	EnableTime *string `json:"EnableTime,omitempty" xml:"EnableTime,omitempty"`
	// The retention period of the files in the recycle bin. Unit: days.
	//
	// If the recycle bin is disabled, 0 is returned for this parameter.
	//
	// example:
	//
	// 0
	ReservedDays *int64 `json:"ReservedDays,omitempty" xml:"ReservedDays,omitempty"`
	// The size of the Infrequent Access (IA) data that is dumped to the recycle bin. Unit: bytes.
	//
	// example:
	//
	// 100
	SecondarySize *int64 `json:"SecondarySize,omitempty" xml:"SecondarySize,omitempty"`
	// The size of the files that are dumped to the recycle bin. Unit: bytes.
	//
	// example:
	//
	// 100
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The status of the recycle bin.
	//
	// Valid values:
	//
	// 	- Enable: The recycle bin is enabled.
	//
	// 	- Disable: The recycle bin is disabled.
	//
	// example:
	//
	// Disable
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetRecycleBinAttributeResponseBodyRecycleBinAttribute) String() string {
	return dara.Prettify(s)
}

func (s GetRecycleBinAttributeResponseBodyRecycleBinAttribute) GoString() string {
	return s.String()
}

func (s *GetRecycleBinAttributeResponseBodyRecycleBinAttribute) GetArchiveSize() *int64 {
	return s.ArchiveSize
}

func (s *GetRecycleBinAttributeResponseBodyRecycleBinAttribute) GetEnableTime() *string {
	return s.EnableTime
}

func (s *GetRecycleBinAttributeResponseBodyRecycleBinAttribute) GetReservedDays() *int64 {
	return s.ReservedDays
}

func (s *GetRecycleBinAttributeResponseBodyRecycleBinAttribute) GetSecondarySize() *int64 {
	return s.SecondarySize
}

func (s *GetRecycleBinAttributeResponseBodyRecycleBinAttribute) GetSize() *int64 {
	return s.Size
}

func (s *GetRecycleBinAttributeResponseBodyRecycleBinAttribute) GetStatus() *string {
	return s.Status
}

func (s *GetRecycleBinAttributeResponseBodyRecycleBinAttribute) SetArchiveSize(v int64) *GetRecycleBinAttributeResponseBodyRecycleBinAttribute {
	s.ArchiveSize = &v
	return s
}

func (s *GetRecycleBinAttributeResponseBodyRecycleBinAttribute) SetEnableTime(v string) *GetRecycleBinAttributeResponseBodyRecycleBinAttribute {
	s.EnableTime = &v
	return s
}

func (s *GetRecycleBinAttributeResponseBodyRecycleBinAttribute) SetReservedDays(v int64) *GetRecycleBinAttributeResponseBodyRecycleBinAttribute {
	s.ReservedDays = &v
	return s
}

func (s *GetRecycleBinAttributeResponseBodyRecycleBinAttribute) SetSecondarySize(v int64) *GetRecycleBinAttributeResponseBodyRecycleBinAttribute {
	s.SecondarySize = &v
	return s
}

func (s *GetRecycleBinAttributeResponseBodyRecycleBinAttribute) SetSize(v int64) *GetRecycleBinAttributeResponseBodyRecycleBinAttribute {
	s.Size = &v
	return s
}

func (s *GetRecycleBinAttributeResponseBodyRecycleBinAttribute) SetStatus(v string) *GetRecycleBinAttributeResponseBodyRecycleBinAttribute {
	s.Status = &v
	return s
}

func (s *GetRecycleBinAttributeResponseBodyRecycleBinAttribute) Validate() error {
	return dara.Validate(s)
}

type iGetRecycleBinAttributeResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *GetRecycleBinAttributeResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *GetRecycleBinAttributeResponse
	GetStatusCode() *int32
	SetBody(v *GetRecycleBinAttributeResponseBody) *GetRecycleBinAttributeResponse
	GetBody() *GetRecycleBinAttributeResponseBody
}

type GetRecycleBinAttributeResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetRecycleBinAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetRecycleBinAttributeResponse) String() string {
	return dara.Prettify(s)
}

func (s GetRecycleBinAttributeResponse) GoString() string {
	return s.String()
}

func (s *GetRecycleBinAttributeResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *GetRecycleBinAttributeResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *GetRecycleBinAttributeResponse) GetBody() *GetRecycleBinAttributeResponseBody {
	return s.Body
}

func (s *GetRecycleBinAttributeResponse) SetHeaders(v map[string]*string) *GetRecycleBinAttributeResponse {
	s.Headers = v
	return s
}

func (s *GetRecycleBinAttributeResponse) SetStatusCode(v int32) *GetRecycleBinAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *GetRecycleBinAttributeResponse) SetBody(v *GetRecycleBinAttributeResponseBody) *GetRecycleBinAttributeResponse {
	s.Body = v
	return s
}

func (s *GetRecycleBinAttributeResponse) Validate() error {
	return dara.Validate(s)
}

type iGetViperGrayConfigRequest interface {
	dara.Model
	String() string
	GoString() string
	SetCondition(v string) *GetViperGrayConfigRequest
	GetCondition() *string
	SetConfigName(v string) *GetViperGrayConfigRequest
	GetConfigName() *string
	SetRegionId(v string) *GetViperGrayConfigRequest
	GetRegionId() *string
}

type GetViperGrayConfigRequest struct {
	Condition *string `json:"Condition,omitempty" xml:"Condition,omitempty"`
	// This parameter is required.
	ConfigName *string `json:"ConfigName,omitempty" xml:"ConfigName,omitempty"`
	RegionId   *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetViperGrayConfigRequest) String() string {
	return dara.Prettify(s)
}

func (s GetViperGrayConfigRequest) GoString() string {
	return s.String()
}

func (s *GetViperGrayConfigRequest) GetCondition() *string {
	return s.Condition
}

func (s *GetViperGrayConfigRequest) GetConfigName() *string {
	return s.ConfigName
}

func (s *GetViperGrayConfigRequest) GetRegionId() *string {
	return s.RegionId
}

func (s *GetViperGrayConfigRequest) SetCondition(v string) *GetViperGrayConfigRequest {
	s.Condition = &v
	return s
}

func (s *GetViperGrayConfigRequest) SetConfigName(v string) *GetViperGrayConfigRequest {
	s.ConfigName = &v
	return s
}

func (s *GetViperGrayConfigRequest) SetRegionId(v string) *GetViperGrayConfigRequest {
	s.RegionId = &v
	return s
}

func (s *GetViperGrayConfigRequest) Validate() error {
	return dara.Validate(s)
}

type iGetViperGrayConfigResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetConfig(v string) *GetViperGrayConfigResponseBody
	GetConfig() *string
	SetRequestId(v string) *GetViperGrayConfigResponseBody
	GetRequestId() *string
}

type GetViperGrayConfigResponseBody struct {
	Config    *string `json:"Config,omitempty" xml:"Config,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetViperGrayConfigResponseBody) String() string {
	return dara.Prettify(s)
}

func (s GetViperGrayConfigResponseBody) GoString() string {
	return s.String()
}

func (s *GetViperGrayConfigResponseBody) GetConfig() *string {
	return s.Config
}

func (s *GetViperGrayConfigResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *GetViperGrayConfigResponseBody) SetConfig(v string) *GetViperGrayConfigResponseBody {
	s.Config = &v
	return s
}

func (s *GetViperGrayConfigResponseBody) SetRequestId(v string) *GetViperGrayConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetViperGrayConfigResponseBody) Validate() error {
	return dara.Validate(s)
}

type iGetViperGrayConfigResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *GetViperGrayConfigResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *GetViperGrayConfigResponse
	GetStatusCode() *int32
	SetBody(v *GetViperGrayConfigResponseBody) *GetViperGrayConfigResponse
	GetBody() *GetViperGrayConfigResponseBody
}

type GetViperGrayConfigResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetViperGrayConfigResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetViperGrayConfigResponse) String() string {
	return dara.Prettify(s)
}

func (s GetViperGrayConfigResponse) GoString() string {
	return s.String()
}

func (s *GetViperGrayConfigResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *GetViperGrayConfigResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *GetViperGrayConfigResponse) GetBody() *GetViperGrayConfigResponseBody {
	return s.Body
}

func (s *GetViperGrayConfigResponse) SetHeaders(v map[string]*string) *GetViperGrayConfigResponse {
	s.Headers = v
	return s
}

func (s *GetViperGrayConfigResponse) SetStatusCode(v int32) *GetViperGrayConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *GetViperGrayConfigResponse) SetBody(v *GetViperGrayConfigResponseBody) *GetViperGrayConfigResponse {
	s.Body = v
	return s
}

func (s *GetViperGrayConfigResponse) Validate() error {
	return dara.Validate(s)
}

type iListDirectoriesAndFilesRequest interface {
	dara.Model
	String() string
	GoString() string
	SetDirectoryOnly(v bool) *ListDirectoriesAndFilesRequest
	GetDirectoryOnly() *bool
	SetFileSystemId(v string) *ListDirectoriesAndFilesRequest
	GetFileSystemId() *string
	SetMaxResults(v int64) *ListDirectoriesAndFilesRequest
	GetMaxResults() *int64
	SetNextToken(v string) *ListDirectoriesAndFilesRequest
	GetNextToken() *string
	SetPath(v string) *ListDirectoriesAndFilesRequest
	GetPath() *string
	SetStorageType(v string) *ListDirectoriesAndFilesRequest
	GetStorageType() *string
}

type ListDirectoriesAndFilesRequest struct {
	// Specifies whether to query only directories.
	//
	// Valid values:
	//
	// 	- false (default): queries both directories and files.
	//
	// 	- true: queries only directories.
	//
	// >  If you set the StorageType parameter to All, you must set the DirectoryOnly parameter to true.
	//
	// example:
	//
	// false
	DirectoryOnly *bool `json:"DirectoryOnly,omitempty" xml:"DirectoryOnly,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 31a8e4****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The maximum number of directories or files to include in the results of each query.
	//
	// Valid values: 10 to 128.
	//
	// Default value: 100.
	//
	// example:
	//
	// 100
	MaxResults *int64 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.
	//
	// example:
	//
	// TGlzdFJlc291cmNlU****mVzJjE1MTI2NjY4NzY5MTAzOTEmMiZORnI4NDhVeEtrUT0=
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The absolute path of the directory.
	//
	// The path must start with a forward slash (/) and must be a path that exists in the mount target.
	//
	// This parameter is required.
	//
	// example:
	//
	// /pathway/to/folder
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The storage class.
	//
	// 	- InfrequentAccess: the Infrequent Access (IA) storage class.
	//
	// 	- Archive: the Archive storage class.
	//
	// 	- All: all stored data.
	//
	// >  If you set the StorageType parameter to All, you must set the DirectoryOnly parameter to true.
	//
	// This parameter is required.
	//
	// example:
	//
	// InfrequentAccess
	StorageType *string `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
}

func (s ListDirectoriesAndFilesRequest) String() string {
	return dara.Prettify(s)
}

func (s ListDirectoriesAndFilesRequest) GoString() string {
	return s.String()
}

func (s *ListDirectoriesAndFilesRequest) GetDirectoryOnly() *bool {
	return s.DirectoryOnly
}

func (s *ListDirectoriesAndFilesRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *ListDirectoriesAndFilesRequest) GetMaxResults() *int64 {
	return s.MaxResults
}

func (s *ListDirectoriesAndFilesRequest) GetNextToken() *string {
	return s.NextToken
}

func (s *ListDirectoriesAndFilesRequest) GetPath() *string {
	return s.Path
}

func (s *ListDirectoriesAndFilesRequest) GetStorageType() *string {
	return s.StorageType
}

func (s *ListDirectoriesAndFilesRequest) SetDirectoryOnly(v bool) *ListDirectoriesAndFilesRequest {
	s.DirectoryOnly = &v
	return s
}

func (s *ListDirectoriesAndFilesRequest) SetFileSystemId(v string) *ListDirectoriesAndFilesRequest {
	s.FileSystemId = &v
	return s
}

func (s *ListDirectoriesAndFilesRequest) SetMaxResults(v int64) *ListDirectoriesAndFilesRequest {
	s.MaxResults = &v
	return s
}

func (s *ListDirectoriesAndFilesRequest) SetNextToken(v string) *ListDirectoriesAndFilesRequest {
	s.NextToken = &v
	return s
}

func (s *ListDirectoriesAndFilesRequest) SetPath(v string) *ListDirectoriesAndFilesRequest {
	s.Path = &v
	return s
}

func (s *ListDirectoriesAndFilesRequest) SetStorageType(v string) *ListDirectoriesAndFilesRequest {
	s.StorageType = &v
	return s
}

func (s *ListDirectoriesAndFilesRequest) Validate() error {
	return dara.Validate(s)
}

type iListDirectoriesAndFilesResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetEntries(v []*ListDirectoriesAndFilesResponseBodyEntries) *ListDirectoriesAndFilesResponseBody
	GetEntries() []*ListDirectoriesAndFilesResponseBodyEntries
	SetNextToken(v string) *ListDirectoriesAndFilesResponseBody
	GetNextToken() *string
	SetRequestId(v string) *ListDirectoriesAndFilesResponseBody
	GetRequestId() *string
}

type ListDirectoriesAndFilesResponseBody struct {
	// The details about the files or directories.
	Entries []*ListDirectoriesAndFilesResponseBodyEntries `json:"Entries,omitempty" xml:"Entries,omitempty" type:"Repeated"`
	// A pagination token. It can be used in the next request to retrieve a new page of results.
	//
	// example:
	//
	// TGlzdFJlc291cmNlU****mVzJjE1MTI2NjY4NzY5MTAzOTEmMiZORnI4NDhVeEtrUT0=
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 2D69A58F-345C-4FDE-88E4-BF518948****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListDirectoriesAndFilesResponseBody) String() string {
	return dara.Prettify(s)
}

func (s ListDirectoriesAndFilesResponseBody) GoString() string {
	return s.String()
}

func (s *ListDirectoriesAndFilesResponseBody) GetEntries() []*ListDirectoriesAndFilesResponseBodyEntries {
	return s.Entries
}

func (s *ListDirectoriesAndFilesResponseBody) GetNextToken() *string {
	return s.NextToken
}

func (s *ListDirectoriesAndFilesResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *ListDirectoriesAndFilesResponseBody) SetEntries(v []*ListDirectoriesAndFilesResponseBodyEntries) *ListDirectoriesAndFilesResponseBody {
	s.Entries = v
	return s
}

func (s *ListDirectoriesAndFilesResponseBody) SetNextToken(v string) *ListDirectoriesAndFilesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListDirectoriesAndFilesResponseBody) SetRequestId(v string) *ListDirectoriesAndFilesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDirectoriesAndFilesResponseBody) Validate() error {
	return dara.Validate(s)
}

type ListDirectoriesAndFilesResponseBodyEntries struct {
	// The time when the file was queried.
	//
	// The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format.
	//
	// This parameter is returned and valid only if the value of the Type parameter is File.
	//
	// example:
	//
	// 2021-02-01T10:08:08Z
	Atime *string `json:"Atime,omitempty" xml:"Atime,omitempty"`
	// The time when the raw data was modified.
	//
	// The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format.
	//
	// This parameter is returned and valid only if the value of the Type parameter is File.
	//
	// example:
	//
	// 2021-02-11T10:08:10Z
	Ctime *string `json:"Ctime,omitempty" xml:"Ctime,omitempty"`
	// The ID of the directory or file.
	//
	// example:
	//
	// 66
	FileId *string `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// Indicates whether the directory contains files stored in the Archive storage class.
	//
	// This parameter is returned and valid only if the value of the Type parameter is Directory.
	//
	// Valid values:
	//
	// 	- true: The directory contains files stored in the Archive storage class.
	//
	// 	- false: The directory does not contain files stored in the Archive storage class.
	//
	// example:
	//
	// true
	HasArchiveFile *string `json:"HasArchiveFile,omitempty" xml:"HasArchiveFile,omitempty"`
	// Indicates whether the directory contains files stored in the IA storage class.
	//
	// This parameter is returned and valid only if the value of the Type parameter is Directory.
	//
	// Valid values:
	//
	// 	- true: The directory contains files stored in the IA storage class.
	//
	// 	- false: The directory does not contain files stored in the IA storage class.
	//
	// example:
	//
	// true
	HasInfrequentAccessFile *bool `json:"HasInfrequentAccessFile,omitempty" xml:"HasInfrequentAccessFile,omitempty"`
	// The file or directory inode.
	//
	// example:
	//
	// 66
	Inode *string `json:"Inode,omitempty" xml:"Inode,omitempty"`
	// The time when the file was modified.
	//
	// The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format.
	//
	// This parameter is returned and valid only if the value of the Type parameter is File.
	//
	// example:
	//
	// 2021-02-11T10:08:08Z
	Mtime *string `json:"Mtime,omitempty" xml:"Mtime,omitempty"`
	// The name of the file or directory.
	//
	// example:
	//
	// file.txt
	Name                     *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OfflineDuration          *int64  `json:"OfflineDuration,omitempty" xml:"OfflineDuration,omitempty"`
	OfflineUnchangedDuration *int64  `json:"OfflineUnchangedDuration,omitempty" xml:"OfflineUnchangedDuration,omitempty"`
	// The ID of the portable account. This parameter is returned and valid only if the value of the ProtocolType parameter is SMB and RAM-based access control is enabled.
	//
	// example:
	//
	// 37862c****
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The time when the last data retrieval task was run.
	//
	// The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format.
	//
	// This parameter is returned and valid only if the value of the Type parameter is File.
	//
	// example:
	//
	// 2021-02-11T10:08:08Z
	RetrieveTime *string `json:"RetrieveTime,omitempty" xml:"RetrieveTime,omitempty"`
	// The size of the file.
	//
	// Unit: bytes.
	//
	// This parameter is returned and valid only if the value of the Type parameter is File.
	//
	// example:
	//
	// 1024
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The storage class.
	//
	// This parameter is returned and valid only if the value of the Type parameter is File.
	//
	// Valid values:
	//
	// 	- InfrequentAccess: the IA storage class.
	//
	// 	- Archive: the Archive storage class.
	//
	// example:
	//
	// InfrequentAccess
	StorageType *string `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
	// The type of the query result.
	//
	// Valid values:
	//
	// 	- File
	//
	// 	- Directory
	//
	// example:
	//
	// Directory
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListDirectoriesAndFilesResponseBodyEntries) String() string {
	return dara.Prettify(s)
}

func (s ListDirectoriesAndFilesResponseBodyEntries) GoString() string {
	return s.String()
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) GetAtime() *string {
	return s.Atime
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) GetCtime() *string {
	return s.Ctime
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) GetFileId() *string {
	return s.FileId
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) GetHasArchiveFile() *string {
	return s.HasArchiveFile
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) GetHasInfrequentAccessFile() *bool {
	return s.HasInfrequentAccessFile
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) GetInode() *string {
	return s.Inode
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) GetMtime() *string {
	return s.Mtime
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) GetName() *string {
	return s.Name
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) GetOfflineDuration() *int64 {
	return s.OfflineDuration
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) GetOfflineUnchangedDuration() *int64 {
	return s.OfflineUnchangedDuration
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) GetOwner() *string {
	return s.Owner
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) GetRetrieveTime() *string {
	return s.RetrieveTime
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) GetSize() *int64 {
	return s.Size
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) GetStorageType() *string {
	return s.StorageType
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) GetType() *string {
	return s.Type
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) SetAtime(v string) *ListDirectoriesAndFilesResponseBodyEntries {
	s.Atime = &v
	return s
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) SetCtime(v string) *ListDirectoriesAndFilesResponseBodyEntries {
	s.Ctime = &v
	return s
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) SetFileId(v string) *ListDirectoriesAndFilesResponseBodyEntries {
	s.FileId = &v
	return s
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) SetHasArchiveFile(v string) *ListDirectoriesAndFilesResponseBodyEntries {
	s.HasArchiveFile = &v
	return s
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) SetHasInfrequentAccessFile(v bool) *ListDirectoriesAndFilesResponseBodyEntries {
	s.HasInfrequentAccessFile = &v
	return s
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) SetInode(v string) *ListDirectoriesAndFilesResponseBodyEntries {
	s.Inode = &v
	return s
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) SetMtime(v string) *ListDirectoriesAndFilesResponseBodyEntries {
	s.Mtime = &v
	return s
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) SetName(v string) *ListDirectoriesAndFilesResponseBodyEntries {
	s.Name = &v
	return s
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) SetOfflineDuration(v int64) *ListDirectoriesAndFilesResponseBodyEntries {
	s.OfflineDuration = &v
	return s
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) SetOfflineUnchangedDuration(v int64) *ListDirectoriesAndFilesResponseBodyEntries {
	s.OfflineUnchangedDuration = &v
	return s
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) SetOwner(v string) *ListDirectoriesAndFilesResponseBodyEntries {
	s.Owner = &v
	return s
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) SetRetrieveTime(v string) *ListDirectoriesAndFilesResponseBodyEntries {
	s.RetrieveTime = &v
	return s
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) SetSize(v int64) *ListDirectoriesAndFilesResponseBodyEntries {
	s.Size = &v
	return s
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) SetStorageType(v string) *ListDirectoriesAndFilesResponseBodyEntries {
	s.StorageType = &v
	return s
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) SetType(v string) *ListDirectoriesAndFilesResponseBodyEntries {
	s.Type = &v
	return s
}

func (s *ListDirectoriesAndFilesResponseBodyEntries) Validate() error {
	return dara.Validate(s)
}

type iListDirectoriesAndFilesResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *ListDirectoriesAndFilesResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *ListDirectoriesAndFilesResponse
	GetStatusCode() *int32
	SetBody(v *ListDirectoriesAndFilesResponseBody) *ListDirectoriesAndFilesResponse
	GetBody() *ListDirectoriesAndFilesResponseBody
}

type ListDirectoriesAndFilesResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDirectoriesAndFilesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDirectoriesAndFilesResponse) String() string {
	return dara.Prettify(s)
}

func (s ListDirectoriesAndFilesResponse) GoString() string {
	return s.String()
}

func (s *ListDirectoriesAndFilesResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *ListDirectoriesAndFilesResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *ListDirectoriesAndFilesResponse) GetBody() *ListDirectoriesAndFilesResponseBody {
	return s.Body
}

func (s *ListDirectoriesAndFilesResponse) SetHeaders(v map[string]*string) *ListDirectoriesAndFilesResponse {
	s.Headers = v
	return s
}

func (s *ListDirectoriesAndFilesResponse) SetStatusCode(v int32) *ListDirectoriesAndFilesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDirectoriesAndFilesResponse) SetBody(v *ListDirectoriesAndFilesResponseBody) *ListDirectoriesAndFilesResponse {
	s.Body = v
	return s
}

func (s *ListDirectoriesAndFilesResponse) Validate() error {
	return dara.Validate(s)
}

type iListLifecycleRetrieveJobsRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *ListLifecycleRetrieveJobsRequest
	GetFileSystemId() *string
	SetPageNumber(v int32) *ListLifecycleRetrieveJobsRequest
	GetPageNumber() *int32
	SetPageSize(v int32) *ListLifecycleRetrieveJobsRequest
	GetPageSize() *int32
	SetStatus(v string) *ListLifecycleRetrieveJobsRequest
	GetStatus() *string
	SetStorageType(v string) *ListLifecycleRetrieveJobsRequest
	GetStorageType() *string
}

type ListLifecycleRetrieveJobsRequest struct {
	// The ID of the file system.
	//
	// example:
	//
	// 31a8e4****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The number of the page to return.
	//
	// Pages start from page 1. Default value: 1.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	//
	// Valid values: 1 to 100.
	//
	// Default value: 10.
	//
	// example:
	//
	// 10
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The status of the data retrieval task. Valid values:
	//
	// 	- active: The task is running.
	//
	// 	- canceled: The task is canceled.
	//
	// 	- completed: The task is completed.
	//
	// 	- failed: The task has failed.
	//
	// example:
	//
	// completed
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The storage class.
	//
	// 	- InfrequentAccess: the Infrequent Access (IA) storage class.
	//
	// 	- Archive: the Archive storage class.
	//
	// >  If the StorageType parameter is not specified, data retrieval tasks of all types are returned.
	//
	// example:
	//
	// InfrequentAccess
	StorageType *string `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
}

func (s ListLifecycleRetrieveJobsRequest) String() string {
	return dara.Prettify(s)
}

func (s ListLifecycleRetrieveJobsRequest) GoString() string {
	return s.String()
}

func (s *ListLifecycleRetrieveJobsRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *ListLifecycleRetrieveJobsRequest) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *ListLifecycleRetrieveJobsRequest) GetPageSize() *int32 {
	return s.PageSize
}

func (s *ListLifecycleRetrieveJobsRequest) GetStatus() *string {
	return s.Status
}

func (s *ListLifecycleRetrieveJobsRequest) GetStorageType() *string {
	return s.StorageType
}

func (s *ListLifecycleRetrieveJobsRequest) SetFileSystemId(v string) *ListLifecycleRetrieveJobsRequest {
	s.FileSystemId = &v
	return s
}

func (s *ListLifecycleRetrieveJobsRequest) SetPageNumber(v int32) *ListLifecycleRetrieveJobsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListLifecycleRetrieveJobsRequest) SetPageSize(v int32) *ListLifecycleRetrieveJobsRequest {
	s.PageSize = &v
	return s
}

func (s *ListLifecycleRetrieveJobsRequest) SetStatus(v string) *ListLifecycleRetrieveJobsRequest {
	s.Status = &v
	return s
}

func (s *ListLifecycleRetrieveJobsRequest) SetStorageType(v string) *ListLifecycleRetrieveJobsRequest {
	s.StorageType = &v
	return s
}

func (s *ListLifecycleRetrieveJobsRequest) Validate() error {
	return dara.Validate(s)
}

type iListLifecycleRetrieveJobsResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetLifecycleRetrieveJobs(v []*ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs) *ListLifecycleRetrieveJobsResponseBody
	GetLifecycleRetrieveJobs() []*ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs
	SetPageNumber(v int32) *ListLifecycleRetrieveJobsResponseBody
	GetPageNumber() *int32
	SetPageSize(v int32) *ListLifecycleRetrieveJobsResponseBody
	GetPageSize() *int32
	SetRequestId(v string) *ListLifecycleRetrieveJobsResponseBody
	GetRequestId() *string
	SetTotalCount(v int32) *ListLifecycleRetrieveJobsResponseBody
	GetTotalCount() *int32
}

type ListLifecycleRetrieveJobsResponseBody struct {
	// The details about the data retrieval tasks.
	LifecycleRetrieveJobs []*ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs `json:"LifecycleRetrieveJobs,omitempty" xml:"LifecycleRetrieveJobs,omitempty" type:"Repeated"`
	// The page number of the returned page.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	//
	// example:
	//
	// 10
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// BC7C825C-5F65-4B56-BEF6-98C56C7C****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of data retrieval tasks.
	//
	// example:
	//
	// 10
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListLifecycleRetrieveJobsResponseBody) String() string {
	return dara.Prettify(s)
}

func (s ListLifecycleRetrieveJobsResponseBody) GoString() string {
	return s.String()
}

func (s *ListLifecycleRetrieveJobsResponseBody) GetLifecycleRetrieveJobs() []*ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs {
	return s.LifecycleRetrieveJobs
}

func (s *ListLifecycleRetrieveJobsResponseBody) GetPageNumber() *int32 {
	return s.PageNumber
}

func (s *ListLifecycleRetrieveJobsResponseBody) GetPageSize() *int32 {
	return s.PageSize
}

func (s *ListLifecycleRetrieveJobsResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *ListLifecycleRetrieveJobsResponseBody) GetTotalCount() *int32 {
	return s.TotalCount
}

func (s *ListLifecycleRetrieveJobsResponseBody) SetLifecycleRetrieveJobs(v []*ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs) *ListLifecycleRetrieveJobsResponseBody {
	s.LifecycleRetrieveJobs = v
	return s
}

func (s *ListLifecycleRetrieveJobsResponseBody) SetPageNumber(v int32) *ListLifecycleRetrieveJobsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListLifecycleRetrieveJobsResponseBody) SetPageSize(v int32) *ListLifecycleRetrieveJobsResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListLifecycleRetrieveJobsResponseBody) SetRequestId(v string) *ListLifecycleRetrieveJobsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListLifecycleRetrieveJobsResponseBody) SetTotalCount(v int32) *ListLifecycleRetrieveJobsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListLifecycleRetrieveJobsResponseBody) Validate() error {
	return dara.Validate(s)
}

type ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs struct {
	// The time when the task was created.
	//
	// The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format.
	//
	// example:
	//
	// 2021-02-30T10:08:08Z
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The total number of files that are read in the data retrieval task.
	//
	// example:
	//
	// 100
	DiscoveredFileCount *int64 `json:"DiscoveredFileCount,omitempty" xml:"DiscoveredFileCount,omitempty"`
	// The ID of the file system.
	//
	// example:
	//
	// 31a8e4****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The ID of the data retrieval task.
	//
	// example:
	//
	// lrj-nfstest-ia-160****853-hshvw
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The execution path of the data retrieval task.
	Paths []*string `json:"Paths,omitempty" xml:"Paths,omitempty" type:"Repeated"`
	// The total number of files that are retrieved.
	//
	// example:
	//
	// 80
	RetrievedFileCount *int64 `json:"RetrievedFileCount,omitempty" xml:"RetrievedFileCount,omitempty"`
	// The status of the data retrieval task. Valid values:
	//
	// 	- active: The task is running.
	//
	// 	- canceled: The task is canceled.
	//
	// 	- completed: The task is completed.
	//
	// 	- failed: The task has failed.
	//
	// example:
	//
	// completed
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The storage class.
	//
	// 	- InfrequentAccess: the IA storage class.
	//
	// 	- Archive: the Archive storage class.
	//
	// example:
	//
	// InfrequentAccess
	StorageType *string `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
	// The time when the task was updated.
	//
	// The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format.
	//
	// example:
	//
	// 2021-02-30T11:08:08Z
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs) String() string {
	return dara.Prettify(s)
}

func (s ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs) GoString() string {
	return s.String()
}

func (s *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs) GetCreateTime() *string {
	return s.CreateTime
}

func (s *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs) GetDiscoveredFileCount() *int64 {
	return s.DiscoveredFileCount
}

func (s *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs) GetJobId() *string {
	return s.JobId
}

func (s *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs) GetPaths() []*string {
	return s.Paths
}

func (s *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs) GetRetrievedFileCount() *int64 {
	return s.RetrievedFileCount
}

func (s *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs) GetStatus() *string {
	return s.Status
}

func (s *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs) GetStorageType() *string {
	return s.StorageType
}

func (s *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs) GetUpdateTime() *string {
	return s.UpdateTime
}

func (s *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs) SetCreateTime(v string) *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs {
	s.CreateTime = &v
	return s
}

func (s *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs) SetDiscoveredFileCount(v int64) *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs {
	s.DiscoveredFileCount = &v
	return s
}

func (s *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs) SetFileSystemId(v string) *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs {
	s.FileSystemId = &v
	return s
}

func (s *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs) SetJobId(v string) *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs {
	s.JobId = &v
	return s
}

func (s *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs) SetPaths(v []*string) *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs {
	s.Paths = v
	return s
}

func (s *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs) SetRetrievedFileCount(v int64) *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs {
	s.RetrievedFileCount = &v
	return s
}

func (s *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs) SetStatus(v string) *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs {
	s.Status = &v
	return s
}

func (s *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs) SetStorageType(v string) *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs {
	s.StorageType = &v
	return s
}

func (s *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs) SetUpdateTime(v string) *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs {
	s.UpdateTime = &v
	return s
}

func (s *ListLifecycleRetrieveJobsResponseBodyLifecycleRetrieveJobs) Validate() error {
	return dara.Validate(s)
}

type iListLifecycleRetrieveJobsResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *ListLifecycleRetrieveJobsResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *ListLifecycleRetrieveJobsResponse
	GetStatusCode() *int32
	SetBody(v *ListLifecycleRetrieveJobsResponseBody) *ListLifecycleRetrieveJobsResponse
	GetBody() *ListLifecycleRetrieveJobsResponseBody
}

type ListLifecycleRetrieveJobsResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListLifecycleRetrieveJobsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListLifecycleRetrieveJobsResponse) String() string {
	return dara.Prettify(s)
}

func (s ListLifecycleRetrieveJobsResponse) GoString() string {
	return s.String()
}

func (s *ListLifecycleRetrieveJobsResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *ListLifecycleRetrieveJobsResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *ListLifecycleRetrieveJobsResponse) GetBody() *ListLifecycleRetrieveJobsResponseBody {
	return s.Body
}

func (s *ListLifecycleRetrieveJobsResponse) SetHeaders(v map[string]*string) *ListLifecycleRetrieveJobsResponse {
	s.Headers = v
	return s
}

func (s *ListLifecycleRetrieveJobsResponse) SetStatusCode(v int32) *ListLifecycleRetrieveJobsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListLifecycleRetrieveJobsResponse) SetBody(v *ListLifecycleRetrieveJobsResponseBody) *ListLifecycleRetrieveJobsResponse {
	s.Body = v
	return s
}

func (s *ListLifecycleRetrieveJobsResponse) Validate() error {
	return dara.Validate(s)
}

type iListRecentlyRecycledDirectoriesRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *ListRecentlyRecycledDirectoriesRequest
	GetFileSystemId() *string
	SetMaxResults(v int64) *ListRecentlyRecycledDirectoriesRequest
	GetMaxResults() *int64
	SetNextToken(v string) *ListRecentlyRecycledDirectoriesRequest
	GetNextToken() *string
}

type ListRecentlyRecycledDirectoriesRequest struct {
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1ca404****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The number of directories to return for each query.
	//
	// Valid values: 10 to 1000.
	//
	// Default value: 100.
	//
	// example:
	//
	// 100
	MaxResults *int64 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request.
	//
	// If not all directories are returned in a query, the return value of the NextToken parameter is not empty. In this case, you can specify a valid value for the NextToken parameter to continue the query.
	//
	// example:
	//
	// 1256****25
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
}

func (s ListRecentlyRecycledDirectoriesRequest) String() string {
	return dara.Prettify(s)
}

func (s ListRecentlyRecycledDirectoriesRequest) GoString() string {
	return s.String()
}

func (s *ListRecentlyRecycledDirectoriesRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *ListRecentlyRecycledDirectoriesRequest) GetMaxResults() *int64 {
	return s.MaxResults
}

func (s *ListRecentlyRecycledDirectoriesRequest) GetNextToken() *string {
	return s.NextToken
}

func (s *ListRecentlyRecycledDirectoriesRequest) SetFileSystemId(v string) *ListRecentlyRecycledDirectoriesRequest {
	s.FileSystemId = &v
	return s
}

func (s *ListRecentlyRecycledDirectoriesRequest) SetMaxResults(v int64) *ListRecentlyRecycledDirectoriesRequest {
	s.MaxResults = &v
	return s
}

func (s *ListRecentlyRecycledDirectoriesRequest) SetNextToken(v string) *ListRecentlyRecycledDirectoriesRequest {
	s.NextToken = &v
	return s
}

func (s *ListRecentlyRecycledDirectoriesRequest) Validate() error {
	return dara.Validate(s)
}

type iListRecentlyRecycledDirectoriesResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetEntries(v []*ListRecentlyRecycledDirectoriesResponseBodyEntries) *ListRecentlyRecycledDirectoriesResponseBody
	GetEntries() []*ListRecentlyRecycledDirectoriesResponseBodyEntries
	SetNextToken(v string) *ListRecentlyRecycledDirectoriesResponseBody
	GetNextToken() *string
	SetRequestId(v string) *ListRecentlyRecycledDirectoriesResponseBody
	GetRequestId() *string
}

type ListRecentlyRecycledDirectoriesResponseBody struct {
	// The information about the directories that are recently deleted.
	Entries []*ListRecentlyRecycledDirectoriesResponseBodyEntries `json:"Entries,omitempty" xml:"Entries,omitempty" type:"Repeated"`
	// A pagination token.
	//
	// If not all directories are returned in a query, the return value of the NextToken parameter is not empty. In this case, you can specify a valid value for the NextToken parameter to continue the query.
	//
	// example:
	//
	// 1256****25
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 9E15E394-38A6-457A-A62A-D9797C9A****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListRecentlyRecycledDirectoriesResponseBody) String() string {
	return dara.Prettify(s)
}

func (s ListRecentlyRecycledDirectoriesResponseBody) GoString() string {
	return s.String()
}

func (s *ListRecentlyRecycledDirectoriesResponseBody) GetEntries() []*ListRecentlyRecycledDirectoriesResponseBodyEntries {
	return s.Entries
}

func (s *ListRecentlyRecycledDirectoriesResponseBody) GetNextToken() *string {
	return s.NextToken
}

func (s *ListRecentlyRecycledDirectoriesResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *ListRecentlyRecycledDirectoriesResponseBody) SetEntries(v []*ListRecentlyRecycledDirectoriesResponseBodyEntries) *ListRecentlyRecycledDirectoriesResponseBody {
	s.Entries = v
	return s
}

func (s *ListRecentlyRecycledDirectoriesResponseBody) SetNextToken(v string) *ListRecentlyRecycledDirectoriesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListRecentlyRecycledDirectoriesResponseBody) SetRequestId(v string) *ListRecentlyRecycledDirectoriesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListRecentlyRecycledDirectoriesResponseBody) Validate() error {
	return dara.Validate(s)
}

type ListRecentlyRecycledDirectoriesResponseBodyEntries struct {
	// The ID of the directory.
	//
	// example:
	//
	// 04***08
	FileId *string `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The time when the directory was last deleted.
	//
	// example:
	//
	// 2021-05-30T10:08:08Z
	LastDeleteTime *string `json:"LastDeleteTime,omitempty" xml:"LastDeleteTime,omitempty"`
	// The name of the directory.
	//
	// example:
	//
	// b
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The absolute path to the directory.
	//
	// example:
	//
	// /a/b
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s ListRecentlyRecycledDirectoriesResponseBodyEntries) String() string {
	return dara.Prettify(s)
}

func (s ListRecentlyRecycledDirectoriesResponseBodyEntries) GoString() string {
	return s.String()
}

func (s *ListRecentlyRecycledDirectoriesResponseBodyEntries) GetFileId() *string {
	return s.FileId
}

func (s *ListRecentlyRecycledDirectoriesResponseBodyEntries) GetLastDeleteTime() *string {
	return s.LastDeleteTime
}

func (s *ListRecentlyRecycledDirectoriesResponseBodyEntries) GetName() *string {
	return s.Name
}

func (s *ListRecentlyRecycledDirectoriesResponseBodyEntries) GetPath() *string {
	return s.Path
}

func (s *ListRecentlyRecycledDirectoriesResponseBodyEntries) SetFileId(v string) *ListRecentlyRecycledDirectoriesResponseBodyEntries {
	s.FileId = &v
	return s
}

func (s *ListRecentlyRecycledDirectoriesResponseBodyEntries) SetLastDeleteTime(v string) *ListRecentlyRecycledDirectoriesResponseBodyEntries {
	s.LastDeleteTime = &v
	return s
}

func (s *ListRecentlyRecycledDirectoriesResponseBodyEntries) SetName(v string) *ListRecentlyRecycledDirectoriesResponseBodyEntries {
	s.Name = &v
	return s
}

func (s *ListRecentlyRecycledDirectoriesResponseBodyEntries) SetPath(v string) *ListRecentlyRecycledDirectoriesResponseBodyEntries {
	s.Path = &v
	return s
}

func (s *ListRecentlyRecycledDirectoriesResponseBodyEntries) Validate() error {
	return dara.Validate(s)
}

type iListRecentlyRecycledDirectoriesResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *ListRecentlyRecycledDirectoriesResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *ListRecentlyRecycledDirectoriesResponse
	GetStatusCode() *int32
	SetBody(v *ListRecentlyRecycledDirectoriesResponseBody) *ListRecentlyRecycledDirectoriesResponse
	GetBody() *ListRecentlyRecycledDirectoriesResponseBody
}

type ListRecentlyRecycledDirectoriesResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListRecentlyRecycledDirectoriesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListRecentlyRecycledDirectoriesResponse) String() string {
	return dara.Prettify(s)
}

func (s ListRecentlyRecycledDirectoriesResponse) GoString() string {
	return s.String()
}

func (s *ListRecentlyRecycledDirectoriesResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *ListRecentlyRecycledDirectoriesResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *ListRecentlyRecycledDirectoriesResponse) GetBody() *ListRecentlyRecycledDirectoriesResponseBody {
	return s.Body
}

func (s *ListRecentlyRecycledDirectoriesResponse) SetHeaders(v map[string]*string) *ListRecentlyRecycledDirectoriesResponse {
	s.Headers = v
	return s
}

func (s *ListRecentlyRecycledDirectoriesResponse) SetStatusCode(v int32) *ListRecentlyRecycledDirectoriesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListRecentlyRecycledDirectoriesResponse) SetBody(v *ListRecentlyRecycledDirectoriesResponseBody) *ListRecentlyRecycledDirectoriesResponse {
	s.Body = v
	return s
}

func (s *ListRecentlyRecycledDirectoriesResponse) Validate() error {
	return dara.Validate(s)
}

type iListRecycleBinJobsRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *ListRecycleBinJobsRequest
	GetFileSystemId() *string
	SetJobId(v string) *ListRecycleBinJobsRequest
	GetJobId() *string
	SetPageNumber(v int64) *ListRecycleBinJobsRequest
	GetPageNumber() *int64
	SetPageSize(v int64) *ListRecycleBinJobsRequest
	GetPageSize() *int64
	SetStatus(v string) *ListRecycleBinJobsRequest
	GetStatus() *string
}

type ListRecycleBinJobsRequest struct {
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1ca404****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The job ID.
	//
	// example:
	//
	// rb-15****ed-r-1625****2441
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The page number.
	//
	// Pages start from page 1. Default value: 1.
	//
	// example:
	//
	// 1
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	//
	// Valid values: 1 to 100.
	//
	// Default value: 10.
	//
	// example:
	//
	// 10
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The job status. Valid values:
	//
	// 	- Running: The job is running.
	//
	// 	- Defragmenting: The job is defragmenting data.
	//
	// 	- PartialSuccess: The job is partially completed.
	//
	// 	- Success: The job is completed.
	//
	// 	- Fail: The job failed.
	//
	// 	- Cancelled: The job is canceled.
	//
	// 	- all (default)
	//
	// example:
	//
	// All
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListRecycleBinJobsRequest) String() string {
	return dara.Prettify(s)
}

func (s ListRecycleBinJobsRequest) GoString() string {
	return s.String()
}

func (s *ListRecycleBinJobsRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *ListRecycleBinJobsRequest) GetJobId() *string {
	return s.JobId
}

func (s *ListRecycleBinJobsRequest) GetPageNumber() *int64 {
	return s.PageNumber
}

func (s *ListRecycleBinJobsRequest) GetPageSize() *int64 {
	return s.PageSize
}

func (s *ListRecycleBinJobsRequest) GetStatus() *string {
	return s.Status
}

func (s *ListRecycleBinJobsRequest) SetFileSystemId(v string) *ListRecycleBinJobsRequest {
	s.FileSystemId = &v
	return s
}

func (s *ListRecycleBinJobsRequest) SetJobId(v string) *ListRecycleBinJobsRequest {
	s.JobId = &v
	return s
}

func (s *ListRecycleBinJobsRequest) SetPageNumber(v int64) *ListRecycleBinJobsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListRecycleBinJobsRequest) SetPageSize(v int64) *ListRecycleBinJobsRequest {
	s.PageSize = &v
	return s
}

func (s *ListRecycleBinJobsRequest) SetStatus(v string) *ListRecycleBinJobsRequest {
	s.Status = &v
	return s
}

func (s *ListRecycleBinJobsRequest) Validate() error {
	return dara.Validate(s)
}

type iListRecycleBinJobsResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetJobs(v []*ListRecycleBinJobsResponseBodyJobs) *ListRecycleBinJobsResponseBody
	GetJobs() []*ListRecycleBinJobsResponseBodyJobs
	SetPageNumber(v int64) *ListRecycleBinJobsResponseBody
	GetPageNumber() *int64
	SetPageSize(v int64) *ListRecycleBinJobsResponseBody
	GetPageSize() *int64
	SetRequestId(v string) *ListRecycleBinJobsResponseBody
	GetRequestId() *string
	SetTotalCount(v int64) *ListRecycleBinJobsResponseBody
	GetTotalCount() *int64
}

type ListRecycleBinJobsResponseBody struct {
	// The information about the jobs of the recycle bin.
	Jobs []*ListRecycleBinJobsResponseBodyJobs `json:"Jobs,omitempty" xml:"Jobs,omitempty" type:"Repeated"`
	// The page number.
	//
	// example:
	//
	// 1
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of jobs returned per page.
	//
	// example:
	//
	// 10
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 9E15E394-38A6-457A-A62A-D9797C9A****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of jobs.
	//
	// example:
	//
	// 1
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListRecycleBinJobsResponseBody) String() string {
	return dara.Prettify(s)
}

func (s ListRecycleBinJobsResponseBody) GoString() string {
	return s.String()
}

func (s *ListRecycleBinJobsResponseBody) GetJobs() []*ListRecycleBinJobsResponseBodyJobs {
	return s.Jobs
}

func (s *ListRecycleBinJobsResponseBody) GetPageNumber() *int64 {
	return s.PageNumber
}

func (s *ListRecycleBinJobsResponseBody) GetPageSize() *int64 {
	return s.PageSize
}

func (s *ListRecycleBinJobsResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *ListRecycleBinJobsResponseBody) GetTotalCount() *int64 {
	return s.TotalCount
}

func (s *ListRecycleBinJobsResponseBody) SetJobs(v []*ListRecycleBinJobsResponseBodyJobs) *ListRecycleBinJobsResponseBody {
	s.Jobs = v
	return s
}

func (s *ListRecycleBinJobsResponseBody) SetPageNumber(v int64) *ListRecycleBinJobsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListRecycleBinJobsResponseBody) SetPageSize(v int64) *ListRecycleBinJobsResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListRecycleBinJobsResponseBody) SetRequestId(v string) *ListRecycleBinJobsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListRecycleBinJobsResponseBody) SetTotalCount(v int64) *ListRecycleBinJobsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListRecycleBinJobsResponseBody) Validate() error {
	return dara.Validate(s)
}

type ListRecycleBinJobsResponseBodyJobs struct {
	// The time when the job was created.
	//
	// example:
	//
	// 2021-05-30T10:08:08Z
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The error code returned.
	//
	// A valid value is returned only if you set the Status parameter to Fail or PartialSuccess.
	//
	// example:
	//
	// InvalidFileId.NotFound
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	//
	// A valid value is returned only if you set the Status parameter to Fail or PartialSuccess.
	//
	// example:
	//
	// The Target File or Directory does not exist.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the file or directory in the job.
	//
	// example:
	//
	// 04***08
	FileId *string `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The name of the file or directory that is associated with the job.
	//
	// example:
	//
	// test001
	FileName *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	// The job ID.
	//
	// example:
	//
	// 8C****C54
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The progress of the job.
	//
	// Valid values: 1 to 100.
	//
	// example:
	//
	// 100
	Progress *string `json:"Progress,omitempty" xml:"Progress,omitempty"`
	// The status of the job. Valid values:
	//
	// 	- Running: The job is running.
	//
	// 	- Defragmenting: The job is defragmenting data.
	//
	// 	- PartialSuccess: The job is partially completed.
	//
	// 	- Success: The job is completed.
	//
	// 	- Fail: The job failed.
	//
	// 	- Cancelled: The job is canceled.
	//
	// example:
	//
	// Fail
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the job. Valid values:
	//
	// 	- Restore: a file restoration job
	//
	// 	- Delete: a file deletion job
	//
	// example:
	//
	// Restore
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListRecycleBinJobsResponseBodyJobs) String() string {
	return dara.Prettify(s)
}

func (s ListRecycleBinJobsResponseBodyJobs) GoString() string {
	return s.String()
}

func (s *ListRecycleBinJobsResponseBodyJobs) GetCreateTime() *string {
	return s.CreateTime
}

func (s *ListRecycleBinJobsResponseBodyJobs) GetErrorCode() *string {
	return s.ErrorCode
}

func (s *ListRecycleBinJobsResponseBodyJobs) GetErrorMessage() *string {
	return s.ErrorMessage
}

func (s *ListRecycleBinJobsResponseBodyJobs) GetFileId() *string {
	return s.FileId
}

func (s *ListRecycleBinJobsResponseBodyJobs) GetFileName() *string {
	return s.FileName
}

func (s *ListRecycleBinJobsResponseBodyJobs) GetId() *string {
	return s.Id
}

func (s *ListRecycleBinJobsResponseBodyJobs) GetProgress() *string {
	return s.Progress
}

func (s *ListRecycleBinJobsResponseBodyJobs) GetStatus() *string {
	return s.Status
}

func (s *ListRecycleBinJobsResponseBodyJobs) GetType() *string {
	return s.Type
}

func (s *ListRecycleBinJobsResponseBodyJobs) SetCreateTime(v string) *ListRecycleBinJobsResponseBodyJobs {
	s.CreateTime = &v
	return s
}

func (s *ListRecycleBinJobsResponseBodyJobs) SetErrorCode(v string) *ListRecycleBinJobsResponseBodyJobs {
	s.ErrorCode = &v
	return s
}

func (s *ListRecycleBinJobsResponseBodyJobs) SetErrorMessage(v string) *ListRecycleBinJobsResponseBodyJobs {
	s.ErrorMessage = &v
	return s
}

func (s *ListRecycleBinJobsResponseBodyJobs) SetFileId(v string) *ListRecycleBinJobsResponseBodyJobs {
	s.FileId = &v
	return s
}

func (s *ListRecycleBinJobsResponseBodyJobs) SetFileName(v string) *ListRecycleBinJobsResponseBodyJobs {
	s.FileName = &v
	return s
}

func (s *ListRecycleBinJobsResponseBodyJobs) SetId(v string) *ListRecycleBinJobsResponseBodyJobs {
	s.Id = &v
	return s
}

func (s *ListRecycleBinJobsResponseBodyJobs) SetProgress(v string) *ListRecycleBinJobsResponseBodyJobs {
	s.Progress = &v
	return s
}

func (s *ListRecycleBinJobsResponseBodyJobs) SetStatus(v string) *ListRecycleBinJobsResponseBodyJobs {
	s.Status = &v
	return s
}

func (s *ListRecycleBinJobsResponseBodyJobs) SetType(v string) *ListRecycleBinJobsResponseBodyJobs {
	s.Type = &v
	return s
}

func (s *ListRecycleBinJobsResponseBodyJobs) Validate() error {
	return dara.Validate(s)
}

type iListRecycleBinJobsResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *ListRecycleBinJobsResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *ListRecycleBinJobsResponse
	GetStatusCode() *int32
	SetBody(v *ListRecycleBinJobsResponseBody) *ListRecycleBinJobsResponse
	GetBody() *ListRecycleBinJobsResponseBody
}

type ListRecycleBinJobsResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListRecycleBinJobsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListRecycleBinJobsResponse) String() string {
	return dara.Prettify(s)
}

func (s ListRecycleBinJobsResponse) GoString() string {
	return s.String()
}

func (s *ListRecycleBinJobsResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *ListRecycleBinJobsResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *ListRecycleBinJobsResponse) GetBody() *ListRecycleBinJobsResponseBody {
	return s.Body
}

func (s *ListRecycleBinJobsResponse) SetHeaders(v map[string]*string) *ListRecycleBinJobsResponse {
	s.Headers = v
	return s
}

func (s *ListRecycleBinJobsResponse) SetStatusCode(v int32) *ListRecycleBinJobsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListRecycleBinJobsResponse) SetBody(v *ListRecycleBinJobsResponseBody) *ListRecycleBinJobsResponse {
	s.Body = v
	return s
}

func (s *ListRecycleBinJobsResponse) Validate() error {
	return dara.Validate(s)
}

type iListRecycledDirectoriesAndFilesRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileId(v string) *ListRecycledDirectoriesAndFilesRequest
	GetFileId() *string
	SetFileSystemId(v string) *ListRecycledDirectoriesAndFilesRequest
	GetFileSystemId() *string
	SetMaxResults(v int64) *ListRecycledDirectoriesAndFilesRequest
	GetMaxResults() *int64
	SetNextToken(v string) *ListRecycledDirectoriesAndFilesRequest
	GetNextToken() *string
}

type ListRecycledDirectoriesAndFilesRequest struct {
	// The ID of the directory that you want to query.
	//
	// You can call the [ListRecentlyRecycledDirectories ](https://help.aliyun.com/document_detail/2412173.html)operation to query the file ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// 04***08
	FileId *string `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1ca404****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The number of files or directories to return for each query.
	//
	// Valid values: 10 to 1000.
	//
	// Default value: 100.
	//
	// example:
	//
	// 100
	MaxResults *int64 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request.
	//
	// If all the files and directories are incompletely returned in a query, the return value of the NextToken parameter is not empty. In this case, you can specify a valid value for the NextToken parameter to continue the query.
	//
	// example:
	//
	// CJyNARIsMTY5OTI2NjQ3NTEzMjY2OTMwOF8xODA5NF8ufnl0YkROTl9uZXcuaXB5bmI=
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
}

func (s ListRecycledDirectoriesAndFilesRequest) String() string {
	return dara.Prettify(s)
}

func (s ListRecycledDirectoriesAndFilesRequest) GoString() string {
	return s.String()
}

func (s *ListRecycledDirectoriesAndFilesRequest) GetFileId() *string {
	return s.FileId
}

func (s *ListRecycledDirectoriesAndFilesRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *ListRecycledDirectoriesAndFilesRequest) GetMaxResults() *int64 {
	return s.MaxResults
}

func (s *ListRecycledDirectoriesAndFilesRequest) GetNextToken() *string {
	return s.NextToken
}

func (s *ListRecycledDirectoriesAndFilesRequest) SetFileId(v string) *ListRecycledDirectoriesAndFilesRequest {
	s.FileId = &v
	return s
}

func (s *ListRecycledDirectoriesAndFilesRequest) SetFileSystemId(v string) *ListRecycledDirectoriesAndFilesRequest {
	s.FileSystemId = &v
	return s
}

func (s *ListRecycledDirectoriesAndFilesRequest) SetMaxResults(v int64) *ListRecycledDirectoriesAndFilesRequest {
	s.MaxResults = &v
	return s
}

func (s *ListRecycledDirectoriesAndFilesRequest) SetNextToken(v string) *ListRecycledDirectoriesAndFilesRequest {
	s.NextToken = &v
	return s
}

func (s *ListRecycledDirectoriesAndFilesRequest) Validate() error {
	return dara.Validate(s)
}

type iListRecycledDirectoriesAndFilesResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetEntries(v []*ListRecycledDirectoriesAndFilesResponseBodyEntries) *ListRecycledDirectoriesAndFilesResponseBody
	GetEntries() []*ListRecycledDirectoriesAndFilesResponseBodyEntries
	SetNextToken(v string) *ListRecycledDirectoriesAndFilesResponseBody
	GetNextToken() *string
	SetRequestId(v string) *ListRecycledDirectoriesAndFilesResponseBody
	GetRequestId() *string
}

type ListRecycledDirectoriesAndFilesResponseBody struct {
	// The information about files or directories in the recycle bin.
	Entries []*ListRecycledDirectoriesAndFilesResponseBodyEntries `json:"Entries,omitempty" xml:"Entries,omitempty" type:"Repeated"`
	// A pagination token.
	//
	// If all the files and directories are incompletely returned in a query, the return value of the NextToken parameter is not empty. In this case, you can specify a valid value for the NextToken parameter to continue the query.
	//
	// example:
	//
	// CKuO8QMSIjE2OTc3NzI0NjI5MTcyMTYyNDVfMzEzNTUyMF81MjEzODY=
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 98696EF0-1607-4E9D-B01D-F20930B6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListRecycledDirectoriesAndFilesResponseBody) String() string {
	return dara.Prettify(s)
}

func (s ListRecycledDirectoriesAndFilesResponseBody) GoString() string {
	return s.String()
}

func (s *ListRecycledDirectoriesAndFilesResponseBody) GetEntries() []*ListRecycledDirectoriesAndFilesResponseBodyEntries {
	return s.Entries
}

func (s *ListRecycledDirectoriesAndFilesResponseBody) GetNextToken() *string {
	return s.NextToken
}

func (s *ListRecycledDirectoriesAndFilesResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *ListRecycledDirectoriesAndFilesResponseBody) SetEntries(v []*ListRecycledDirectoriesAndFilesResponseBodyEntries) *ListRecycledDirectoriesAndFilesResponseBody {
	s.Entries = v
	return s
}

func (s *ListRecycledDirectoriesAndFilesResponseBody) SetNextToken(v string) *ListRecycledDirectoriesAndFilesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListRecycledDirectoriesAndFilesResponseBody) SetRequestId(v string) *ListRecycledDirectoriesAndFilesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListRecycledDirectoriesAndFilesResponseBody) Validate() error {
	return dara.Validate(s)
}

type ListRecycledDirectoriesAndFilesResponseBodyEntries struct {
	// The time when the file or directory was last accessed.
	//
	// example:
	//
	// 2019-10-30T10:08:08Z
	ATime *string `json:"ATime,omitempty" xml:"ATime,omitempty"`
	// The time when the metadata was last modified.
	//
	// example:
	//
	// 2019-10-30T10:08:08Z
	CTime *string `json:"CTime,omitempty" xml:"CTime,omitempty"`
	// The time when the file or directory was deleted.
	//
	// example:
	//
	// 2021-05-30T10:08:08Z
	DeleteTime *string `json:"DeleteTime,omitempty" xml:"DeleteTime,omitempty"`
	// The IDs of the files or directories.
	//
	// example:
	//
	// 04***08
	FileId *string `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The inode of the file or directory.
	//
	// example:
	//
	// 04***08
	Inode *string `json:"Inode,omitempty" xml:"Inode,omitempty"`
	// The time when the file or directory was last modified.
	//
	// example:
	//
	// 2019-10-30T10:08:08Z
	MTime *string `json:"MTime,omitempty" xml:"MTime,omitempty"`
	// The name of the file or directory before it was deleted.
	//
	// example:
	//
	// test001
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The size of the file. Unit: bytes.
	//
	// The value 0 is returned for this parameter if Directory is returned for the Type parameter.
	//
	// example:
	//
	// 1073741824
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The type of the returned object. Valid values:
	//
	// 	- File
	//
	// 	- Directory
	//
	// example:
	//
	// File
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListRecycledDirectoriesAndFilesResponseBodyEntries) String() string {
	return dara.Prettify(s)
}

func (s ListRecycledDirectoriesAndFilesResponseBodyEntries) GoString() string {
	return s.String()
}

func (s *ListRecycledDirectoriesAndFilesResponseBodyEntries) GetATime() *string {
	return s.ATime
}

func (s *ListRecycledDirectoriesAndFilesResponseBodyEntries) GetCTime() *string {
	return s.CTime
}

func (s *ListRecycledDirectoriesAndFilesResponseBodyEntries) GetDeleteTime() *string {
	return s.DeleteTime
}

func (s *ListRecycledDirectoriesAndFilesResponseBodyEntries) GetFileId() *string {
	return s.FileId
}

func (s *ListRecycledDirectoriesAndFilesResponseBodyEntries) GetInode() *string {
	return s.Inode
}

func (s *ListRecycledDirectoriesAndFilesResponseBodyEntries) GetMTime() *string {
	return s.MTime
}

func (s *ListRecycledDirectoriesAndFilesResponseBodyEntries) GetName() *string {
	return s.Name
}

func (s *ListRecycledDirectoriesAndFilesResponseBodyEntries) GetSize() *int64 {
	return s.Size
}

func (s *ListRecycledDirectoriesAndFilesResponseBodyEntries) GetType() *string {
	return s.Type
}

func (s *ListRecycledDirectoriesAndFilesResponseBodyEntries) SetATime(v string) *ListRecycledDirectoriesAndFilesResponseBodyEntries {
	s.ATime = &v
	return s
}

func (s *ListRecycledDirectoriesAndFilesResponseBodyEntries) SetCTime(v string) *ListRecycledDirectoriesAndFilesResponseBodyEntries {
	s.CTime = &v
	return s
}

func (s *ListRecycledDirectoriesAndFilesResponseBodyEntries) SetDeleteTime(v string) *ListRecycledDirectoriesAndFilesResponseBodyEntries {
	s.DeleteTime = &v
	return s
}

func (s *ListRecycledDirectoriesAndFilesResponseBodyEntries) SetFileId(v string) *ListRecycledDirectoriesAndFilesResponseBodyEntries {
	s.FileId = &v
	return s
}

func (s *ListRecycledDirectoriesAndFilesResponseBodyEntries) SetInode(v string) *ListRecycledDirectoriesAndFilesResponseBodyEntries {
	s.Inode = &v
	return s
}

func (s *ListRecycledDirectoriesAndFilesResponseBodyEntries) SetMTime(v string) *ListRecycledDirectoriesAndFilesResponseBodyEntries {
	s.MTime = &v
	return s
}

func (s *ListRecycledDirectoriesAndFilesResponseBodyEntries) SetName(v string) *ListRecycledDirectoriesAndFilesResponseBodyEntries {
	s.Name = &v
	return s
}

func (s *ListRecycledDirectoriesAndFilesResponseBodyEntries) SetSize(v int64) *ListRecycledDirectoriesAndFilesResponseBodyEntries {
	s.Size = &v
	return s
}

func (s *ListRecycledDirectoriesAndFilesResponseBodyEntries) SetType(v string) *ListRecycledDirectoriesAndFilesResponseBodyEntries {
	s.Type = &v
	return s
}

func (s *ListRecycledDirectoriesAndFilesResponseBodyEntries) Validate() error {
	return dara.Validate(s)
}

type iListRecycledDirectoriesAndFilesResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *ListRecycledDirectoriesAndFilesResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *ListRecycledDirectoriesAndFilesResponse
	GetStatusCode() *int32
	SetBody(v *ListRecycledDirectoriesAndFilesResponseBody) *ListRecycledDirectoriesAndFilesResponse
	GetBody() *ListRecycledDirectoriesAndFilesResponseBody
}

type ListRecycledDirectoriesAndFilesResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListRecycledDirectoriesAndFilesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListRecycledDirectoriesAndFilesResponse) String() string {
	return dara.Prettify(s)
}

func (s ListRecycledDirectoriesAndFilesResponse) GoString() string {
	return s.String()
}

func (s *ListRecycledDirectoriesAndFilesResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *ListRecycledDirectoriesAndFilesResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *ListRecycledDirectoriesAndFilesResponse) GetBody() *ListRecycledDirectoriesAndFilesResponseBody {
	return s.Body
}

func (s *ListRecycledDirectoriesAndFilesResponse) SetHeaders(v map[string]*string) *ListRecycledDirectoriesAndFilesResponse {
	s.Headers = v
	return s
}

func (s *ListRecycledDirectoriesAndFilesResponse) SetStatusCode(v int32) *ListRecycledDirectoriesAndFilesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListRecycledDirectoriesAndFilesResponse) SetBody(v *ListRecycledDirectoriesAndFilesResponseBody) *ListRecycledDirectoriesAndFilesResponse {
	s.Body = v
	return s
}

func (s *ListRecycledDirectoriesAndFilesResponse) Validate() error {
	return dara.Validate(s)
}

type iListTagResourcesRequest interface {
	dara.Model
	String() string
	GoString() string
	SetNextToken(v string) *ListTagResourcesRequest
	GetNextToken() *string
	SetResourceId(v []*string) *ListTagResourcesRequest
	GetResourceId() []*string
	SetResourceType(v string) *ListTagResourcesRequest
	GetResourceType() *string
	SetTag(v []*ListTagResourcesRequestTag) *ListTagResourcesRequest
	GetTag() []*ListTagResourcesRequestTag
}

type ListTagResourcesRequest struct {
	// The pagination token that is used in the next request to retrieve a new page of results.
	//
	// example:
	//
	// MTcyNDU1MTYyNjIxNTMyNzM4NiMzNjExMzQxNw==
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The resource IDs.
	//
	// example:
	//
	// 03e08484f0
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The resource type. Set the value to filesystem.
	//
	// This parameter is required.
	//
	// example:
	//
	// filesystem
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The details about the tags.
	Tag []*ListTagResourcesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s ListTagResourcesRequest) String() string {
	return dara.Prettify(s)
}

func (s ListTagResourcesRequest) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequest) GetNextToken() *string {
	return s.NextToken
}

func (s *ListTagResourcesRequest) GetResourceId() []*string {
	return s.ResourceId
}

func (s *ListTagResourcesRequest) GetResourceType() *string {
	return s.ResourceType
}

func (s *ListTagResourcesRequest) GetTag() []*ListTagResourcesRequestTag {
	return s.Tag
}

func (s *ListTagResourcesRequest) SetNextToken(v string) *ListTagResourcesRequest {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesRequest) SetResourceId(v []*string) *ListTagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *ListTagResourcesRequest) SetResourceType(v string) *ListTagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesRequest) SetTag(v []*ListTagResourcesRequestTag) *ListTagResourcesRequest {
	s.Tag = v
	return s
}

func (s *ListTagResourcesRequest) Validate() error {
	return dara.Validate(s)
}

type ListTagResourcesRequestTag struct {
	// The tag key.
	//
	// Limits:
	//
	// 	- The tag key cannot be left empty.
	//
	// 	- Valid values of N: 1 to 20.
	//
	// 	- The tag key must be 1 to 128 characters in length.
	//
	// 	- The tag key cannot start with `aliyun` or `acs:`.
	//
	// 	- The tag key cannot contain `http://` or `https://`.
	//
	// example:
	//
	// nastest
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	//
	// Limits:
	//
	// 	- Valid values of N: 1 to 20.
	//
	// 	- The tag value must be 1 to 128 characters in length.
	//
	// 	- The tag value cannot start with `aliyun` or `acs:`.
	//
	// 	- The tag value cannot contain `http://` or `https://`.
	//
	// example:
	//
	// filetest
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTagResourcesRequestTag) String() string {
	return dara.Prettify(s)
}

func (s ListTagResourcesRequestTag) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequestTag) GetKey() *string {
	return s.Key
}

func (s *ListTagResourcesRequestTag) GetValue() *string {
	return s.Value
}

func (s *ListTagResourcesRequestTag) SetKey(v string) *ListTagResourcesRequestTag {
	s.Key = &v
	return s
}

func (s *ListTagResourcesRequestTag) SetValue(v string) *ListTagResourcesRequestTag {
	s.Value = &v
	return s
}

func (s *ListTagResourcesRequestTag) Validate() error {
	return dara.Validate(s)
}

type iListTagResourcesResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetNextToken(v string) *ListTagResourcesResponseBody
	GetNextToken() *string
	SetRequestId(v string) *ListTagResourcesResponseBody
	GetRequestId() *string
	SetTagResources(v *ListTagResourcesResponseBodyTagResources) *ListTagResourcesResponseBody
	GetTagResources() *ListTagResourcesResponseBodyTagResources
}

type ListTagResourcesResponseBody struct {
	// A pagination token. It can be used in the next request to retrieve a new page of results. If the value of this parameter is null, no queries are performed after the current query.
	//
	// example:
	//
	// MTcyNDU1MTYyNjIxNTMyNzM4NiMzNjExMzQxNw==
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 2D69A58F-345C-4FDE-88E4-BF518948****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of resources.
	TagResources *ListTagResourcesResponseBodyTagResources `json:"TagResources,omitempty" xml:"TagResources,omitempty" type:"Struct"`
}

func (s ListTagResourcesResponseBody) String() string {
	return dara.Prettify(s)
}

func (s ListTagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBody) GetNextToken() *string {
	return s.NextToken
}

func (s *ListTagResourcesResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *ListTagResourcesResponseBody) GetTagResources() *ListTagResourcesResponseBodyTagResources {
	return s.TagResources
}

func (s *ListTagResourcesResponseBody) SetNextToken(v string) *ListTagResourcesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetRequestId(v string) *ListTagResourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetTagResources(v *ListTagResourcesResponseBodyTagResources) *ListTagResourcesResponseBody {
	s.TagResources = v
	return s
}

func (s *ListTagResourcesResponseBody) Validate() error {
	return dara.Validate(s)
}

type ListTagResourcesResponseBodyTagResources struct {
	TagResource []*ListTagResourcesResponseBodyTagResourcesTagResource `json:"TagResource,omitempty" xml:"TagResource,omitempty" type:"Repeated"`
}

func (s ListTagResourcesResponseBodyTagResources) String() string {
	return dara.Prettify(s)
}

func (s ListTagResourcesResponseBodyTagResources) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyTagResources) GetTagResource() []*ListTagResourcesResponseBodyTagResourcesTagResource {
	return s.TagResource
}

func (s *ListTagResourcesResponseBodyTagResources) SetTagResource(v []*ListTagResourcesResponseBodyTagResourcesTagResource) *ListTagResourcesResponseBodyTagResources {
	s.TagResource = v
	return s
}

func (s *ListTagResourcesResponseBodyTagResources) Validate() error {
	return dara.Validate(s)
}

type ListTagResourcesResponseBodyTagResourcesTagResource struct {
	// The resource ID.
	//
	// example:
	//
	// i-2zebd226fxed6h4iadhe
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The resource type.
	//
	// example:
	//
	// filesystem
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tag key.
	//
	// example:
	//
	// test1
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The tag value.
	//
	// example:
	//
	// test
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s ListTagResourcesResponseBodyTagResourcesTagResource) String() string {
	return dara.Prettify(s)
}

func (s ListTagResourcesResponseBodyTagResourcesTagResource) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) GetResourceId() *string {
	return s.ResourceId
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) GetResourceType() *string {
	return s.ResourceType
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) GetTagKey() *string {
	return s.TagKey
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) GetTagValue() *string {
	return s.TagValue
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetResourceId(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.ResourceId = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetResourceType(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetTagKey(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.TagKey = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetTagValue(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.TagValue = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) Validate() error {
	return dara.Validate(s)
}

type iListTagResourcesResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *ListTagResourcesResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *ListTagResourcesResponse
	GetStatusCode() *int32
	SetBody(v *ListTagResourcesResponseBody) *ListTagResourcesResponse
	GetBody() *ListTagResourcesResponseBody
}

type ListTagResourcesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListTagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListTagResourcesResponse) String() string {
	return dara.Prettify(s)
}

func (s ListTagResourcesResponse) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *ListTagResourcesResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *ListTagResourcesResponse) GetBody() *ListTagResourcesResponseBody {
	return s.Body
}

func (s *ListTagResourcesResponse) SetHeaders(v map[string]*string) *ListTagResourcesResponse {
	s.Headers = v
	return s
}

func (s *ListTagResourcesResponse) SetStatusCode(v int32) *ListTagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTagResourcesResponse) SetBody(v *ListTagResourcesResponseBody) *ListTagResourcesResponse {
	s.Body = v
	return s
}

func (s *ListTagResourcesResponse) Validate() error {
	return dara.Validate(s)
}

type iModifyAccessGroupRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAccessGroupName(v string) *ModifyAccessGroupRequest
	GetAccessGroupName() *string
	SetDescription(v string) *ModifyAccessGroupRequest
	GetDescription() *string
	SetFileSystemType(v string) *ModifyAccessGroupRequest
	GetFileSystemType() *string
}

type ModifyAccessGroupRequest struct {
	// The name of the permission group.
	//
	// Limits:
	//
	// 	- The name must be 3 to 64 characters in length.
	//
	// 	- The name must start with a letter and can contain letters, digits, underscores (_), and hyphens (-).
	//
	// This parameter is required.
	//
	// example:
	//
	// vpc-test
	AccessGroupName *string `json:"AccessGroupName,omitempty" xml:"AccessGroupName,omitempty"`
	// The description of the permission group.
	//
	// Limits:
	//
	// 	- By default, the description of the permission group is the same as the name of the permission group. The description must be 2 to 128 characters in length.
	//
	// 	- The description must start with a letter and cannot start with `http://` or `https://`.
	//
	// 	- The description can contain digits, colons (:), underscores (_), and hyphens (-).
	//
	// example:
	//
	// vpc-test
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The type of the file system.
	//
	// Valid values:
	//
	// 	- standard (default): General-purpose NAS file system
	//
	// 	- extreme: Extreme NAS file system
	//
	// example:
	//
	// standard
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
}

func (s ModifyAccessGroupRequest) String() string {
	return dara.Prettify(s)
}

func (s ModifyAccessGroupRequest) GoString() string {
	return s.String()
}

func (s *ModifyAccessGroupRequest) GetAccessGroupName() *string {
	return s.AccessGroupName
}

func (s *ModifyAccessGroupRequest) GetDescription() *string {
	return s.Description
}

func (s *ModifyAccessGroupRequest) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *ModifyAccessGroupRequest) SetAccessGroupName(v string) *ModifyAccessGroupRequest {
	s.AccessGroupName = &v
	return s
}

func (s *ModifyAccessGroupRequest) SetDescription(v string) *ModifyAccessGroupRequest {
	s.Description = &v
	return s
}

func (s *ModifyAccessGroupRequest) SetFileSystemType(v string) *ModifyAccessGroupRequest {
	s.FileSystemType = &v
	return s
}

func (s *ModifyAccessGroupRequest) Validate() error {
	return dara.Validate(s)
}

type iModifyAccessGroupResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *ModifyAccessGroupResponseBody
	GetRequestId() *string
}

type ModifyAccessGroupResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// ED2AE737-9D50-4CA4-B0DA-31BD610C****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyAccessGroupResponseBody) String() string {
	return dara.Prettify(s)
}

func (s ModifyAccessGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyAccessGroupResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *ModifyAccessGroupResponseBody) SetRequestId(v string) *ModifyAccessGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyAccessGroupResponseBody) Validate() error {
	return dara.Validate(s)
}

type iModifyAccessGroupResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *ModifyAccessGroupResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *ModifyAccessGroupResponse
	GetStatusCode() *int32
	SetBody(v *ModifyAccessGroupResponseBody) *ModifyAccessGroupResponse
	GetBody() *ModifyAccessGroupResponseBody
}

type ModifyAccessGroupResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyAccessGroupResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyAccessGroupResponse) String() string {
	return dara.Prettify(s)
}

func (s ModifyAccessGroupResponse) GoString() string {
	return s.String()
}

func (s *ModifyAccessGroupResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *ModifyAccessGroupResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *ModifyAccessGroupResponse) GetBody() *ModifyAccessGroupResponseBody {
	return s.Body
}

func (s *ModifyAccessGroupResponse) SetHeaders(v map[string]*string) *ModifyAccessGroupResponse {
	s.Headers = v
	return s
}

func (s *ModifyAccessGroupResponse) SetStatusCode(v int32) *ModifyAccessGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyAccessGroupResponse) SetBody(v *ModifyAccessGroupResponseBody) *ModifyAccessGroupResponse {
	s.Body = v
	return s
}

func (s *ModifyAccessGroupResponse) Validate() error {
	return dara.Validate(s)
}

type iModifyAccessPointRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAccessGroup(v string) *ModifyAccessPointRequest
	GetAccessGroup() *string
	SetAccessPointId(v string) *ModifyAccessPointRequest
	GetAccessPointId() *string
	SetAccessPointName(v string) *ModifyAccessPointRequest
	GetAccessPointName() *string
	SetEnabledRam(v bool) *ModifyAccessPointRequest
	GetEnabledRam() *bool
	SetFileSystemId(v string) *ModifyAccessPointRequest
	GetFileSystemId() *string
}

type ModifyAccessPointRequest struct {
	// The name of the permission group.
	//
	// This parameter is required for a General-purpose File Storage NAS (NAS) file system.
	//
	// The default permission group for virtual private clouds (VPCs) is named DEFAULT_VPC_GROUP_NAME.
	//
	// example:
	//
	// DEFAULT_VPC_GROUP_NAME
	AccessGroup *string `json:"AccessGroup,omitempty" xml:"AccessGroup,omitempty"`
	// The ID of the access point.
	//
	// This parameter is required.
	//
	// example:
	//
	// ap-ie15yd****
	AccessPointId *string `json:"AccessPointId,omitempty" xml:"AccessPointId,omitempty"`
	// The name of the access point.
	//
	// example:
	//
	// test
	AccessPointName *string `json:"AccessPointName,omitempty" xml:"AccessPointName,omitempty"`
	// Specifies whether to enable the Resource Access Management (RAM) policy. Valid values:
	//
	// 	- true: The RAM policy is enabled.
	//
	// 	- false (default): The RAM policy is disabled.
	//
	// >  After the RAM policy is enabled for access points, no RAM user is allowed to use access points to mount and access data by default. To use access points to mount and access data as a RAM user, you must grant the related access permissions to the RAM user. If the RAM policy is disabled, access points can be anonymously mounted.
	//
	// example:
	//
	// false
	EnabledRam *bool `json:"EnabledRam,omitempty" xml:"EnabledRam,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1ca404****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
}

func (s ModifyAccessPointRequest) String() string {
	return dara.Prettify(s)
}

func (s ModifyAccessPointRequest) GoString() string {
	return s.String()
}

func (s *ModifyAccessPointRequest) GetAccessGroup() *string {
	return s.AccessGroup
}

func (s *ModifyAccessPointRequest) GetAccessPointId() *string {
	return s.AccessPointId
}

func (s *ModifyAccessPointRequest) GetAccessPointName() *string {
	return s.AccessPointName
}

func (s *ModifyAccessPointRequest) GetEnabledRam() *bool {
	return s.EnabledRam
}

func (s *ModifyAccessPointRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *ModifyAccessPointRequest) SetAccessGroup(v string) *ModifyAccessPointRequest {
	s.AccessGroup = &v
	return s
}

func (s *ModifyAccessPointRequest) SetAccessPointId(v string) *ModifyAccessPointRequest {
	s.AccessPointId = &v
	return s
}

func (s *ModifyAccessPointRequest) SetAccessPointName(v string) *ModifyAccessPointRequest {
	s.AccessPointName = &v
	return s
}

func (s *ModifyAccessPointRequest) SetEnabledRam(v bool) *ModifyAccessPointRequest {
	s.EnabledRam = &v
	return s
}

func (s *ModifyAccessPointRequest) SetFileSystemId(v string) *ModifyAccessPointRequest {
	s.FileSystemId = &v
	return s
}

func (s *ModifyAccessPointRequest) Validate() error {
	return dara.Validate(s)
}

type iModifyAccessPointResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *ModifyAccessPointResponseBody
	GetRequestId() *string
}

type ModifyAccessPointResponseBody struct {
	// The request ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// 70EACC9C-D07A-4A34-ADA4-77506C42****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyAccessPointResponseBody) String() string {
	return dara.Prettify(s)
}

func (s ModifyAccessPointResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyAccessPointResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *ModifyAccessPointResponseBody) SetRequestId(v string) *ModifyAccessPointResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyAccessPointResponseBody) Validate() error {
	return dara.Validate(s)
}

type iModifyAccessPointResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *ModifyAccessPointResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *ModifyAccessPointResponse
	GetStatusCode() *int32
	SetBody(v *ModifyAccessPointResponseBody) *ModifyAccessPointResponse
	GetBody() *ModifyAccessPointResponseBody
}

type ModifyAccessPointResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyAccessPointResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyAccessPointResponse) String() string {
	return dara.Prettify(s)
}

func (s ModifyAccessPointResponse) GoString() string {
	return s.String()
}

func (s *ModifyAccessPointResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *ModifyAccessPointResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *ModifyAccessPointResponse) GetBody() *ModifyAccessPointResponseBody {
	return s.Body
}

func (s *ModifyAccessPointResponse) SetHeaders(v map[string]*string) *ModifyAccessPointResponse {
	s.Headers = v
	return s
}

func (s *ModifyAccessPointResponse) SetStatusCode(v int32) *ModifyAccessPointResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyAccessPointResponse) SetBody(v *ModifyAccessPointResponseBody) *ModifyAccessPointResponse {
	s.Body = v
	return s
}

func (s *ModifyAccessPointResponse) Validate() error {
	return dara.Validate(s)
}

type iModifyAccessRuleRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAccessGroupName(v string) *ModifyAccessRuleRequest
	GetAccessGroupName() *string
	SetAccessRuleId(v string) *ModifyAccessRuleRequest
	GetAccessRuleId() *string
	SetFileSystemType(v string) *ModifyAccessRuleRequest
	GetFileSystemType() *string
	SetIpv6SourceCidrIp(v string) *ModifyAccessRuleRequest
	GetIpv6SourceCidrIp() *string
	SetPriority(v int32) *ModifyAccessRuleRequest
	GetPriority() *int32
	SetRWAccessType(v string) *ModifyAccessRuleRequest
	GetRWAccessType() *string
	SetSourceCidrIp(v string) *ModifyAccessRuleRequest
	GetSourceCidrIp() *string
	SetUserAccessType(v string) *ModifyAccessRuleRequest
	GetUserAccessType() *string
}

type ModifyAccessRuleRequest struct {
	// The name of the permission group.
	//
	// This parameter is required.
	//
	// example:
	//
	// vpc-test
	AccessGroupName *string `json:"AccessGroupName,omitempty" xml:"AccessGroupName,omitempty"`
	// The rule ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1
	AccessRuleId *string `json:"AccessRuleId,omitempty" xml:"AccessRuleId,omitempty"`
	// The type of the file system.
	//
	// Valid values:
	//
	// 	- standard (default): General-purpose NAS file system
	//
	// 	- extreme: Extreme NAS file system
	//
	// example:
	//
	// standard
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
	// The IPv6 address or CIDR block of the authorized object.
	//
	// You must set this parameter to an IPv6 IP address or CIDR block.
	//
	// > 	- Only Extreme NAS file systems that reside in the China (Hohhot) region support IPv6.
	//
	// >	- Only permission groups that reside in virtual private clouds (VPCs) support IPv6.
	//
	// >	- This parameter is unavailable if you specify the SourceCidrIp parameter.
	//
	// example:
	//
	// fe80::3d4a:80fd:f05d:****
	Ipv6SourceCidrIp *string `json:"Ipv6SourceCidrIp,omitempty" xml:"Ipv6SourceCidrIp,omitempty"`
	// The priority of the rule.
	//
	// Valid values: 1 to 100.
	//
	// Default value: 1, which indicates the highest priority.
	//
	// example:
	//
	// 1
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The access permissions of the authorized object on the file system.
	//
	// Valid values:
	//
	// 	- RDWR (default): the read and write permissions
	//
	// 	- RDONLY: the read-only permissions
	//
	// example:
	//
	// RDWR
	RWAccessType *string `json:"RWAccessType,omitempty" xml:"RWAccessType,omitempty"`
	// The IP address or CIDR block of the authorized object.
	//
	// You must set this parameter to an IP address or CIDR block.
	//
	// example:
	//
	// ``192.0.**.**``
	SourceCidrIp *string `json:"SourceCidrIp,omitempty" xml:"SourceCidrIp,omitempty"`
	// The access permissions for different types of users in the authorized object.
	//
	// Valid values:
	//
	// 	- no_squash: allows access from root users to the file system.
	//
	// 	- root_squash: grants root users the least permissions as the nobody user.
	//
	// 	- all_squash: grants all users the least permissions as the nobody user.
	//
	// The nobody user has the least permissions in Linux and can access only the public content of the file system. This ensures the security of the file system.
	//
	// example:
	//
	// all_squash
	UserAccessType *string `json:"UserAccessType,omitempty" xml:"UserAccessType,omitempty"`
}

func (s ModifyAccessRuleRequest) String() string {
	return dara.Prettify(s)
}

func (s ModifyAccessRuleRequest) GoString() string {
	return s.String()
}

func (s *ModifyAccessRuleRequest) GetAccessGroupName() *string {
	return s.AccessGroupName
}

func (s *ModifyAccessRuleRequest) GetAccessRuleId() *string {
	return s.AccessRuleId
}

func (s *ModifyAccessRuleRequest) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *ModifyAccessRuleRequest) GetIpv6SourceCidrIp() *string {
	return s.Ipv6SourceCidrIp
}

func (s *ModifyAccessRuleRequest) GetPriority() *int32 {
	return s.Priority
}

func (s *ModifyAccessRuleRequest) GetRWAccessType() *string {
	return s.RWAccessType
}

func (s *ModifyAccessRuleRequest) GetSourceCidrIp() *string {
	return s.SourceCidrIp
}

func (s *ModifyAccessRuleRequest) GetUserAccessType() *string {
	return s.UserAccessType
}

func (s *ModifyAccessRuleRequest) SetAccessGroupName(v string) *ModifyAccessRuleRequest {
	s.AccessGroupName = &v
	return s
}

func (s *ModifyAccessRuleRequest) SetAccessRuleId(v string) *ModifyAccessRuleRequest {
	s.AccessRuleId = &v
	return s
}

func (s *ModifyAccessRuleRequest) SetFileSystemType(v string) *ModifyAccessRuleRequest {
	s.FileSystemType = &v
	return s
}

func (s *ModifyAccessRuleRequest) SetIpv6SourceCidrIp(v string) *ModifyAccessRuleRequest {
	s.Ipv6SourceCidrIp = &v
	return s
}

func (s *ModifyAccessRuleRequest) SetPriority(v int32) *ModifyAccessRuleRequest {
	s.Priority = &v
	return s
}

func (s *ModifyAccessRuleRequest) SetRWAccessType(v string) *ModifyAccessRuleRequest {
	s.RWAccessType = &v
	return s
}

func (s *ModifyAccessRuleRequest) SetSourceCidrIp(v string) *ModifyAccessRuleRequest {
	s.SourceCidrIp = &v
	return s
}

func (s *ModifyAccessRuleRequest) SetUserAccessType(v string) *ModifyAccessRuleRequest {
	s.UserAccessType = &v
	return s
}

func (s *ModifyAccessRuleRequest) Validate() error {
	return dara.Validate(s)
}

type iModifyAccessRuleResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *ModifyAccessRuleResponseBody
	GetRequestId() *string
}

type ModifyAccessRuleResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 6299428C-3861-435D-AE54-9B330A00****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyAccessRuleResponseBody) String() string {
	return dara.Prettify(s)
}

func (s ModifyAccessRuleResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyAccessRuleResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *ModifyAccessRuleResponseBody) SetRequestId(v string) *ModifyAccessRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyAccessRuleResponseBody) Validate() error {
	return dara.Validate(s)
}

type iModifyAccessRuleResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *ModifyAccessRuleResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *ModifyAccessRuleResponse
	GetStatusCode() *int32
	SetBody(v *ModifyAccessRuleResponseBody) *ModifyAccessRuleResponse
	GetBody() *ModifyAccessRuleResponseBody
}

type ModifyAccessRuleResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyAccessRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyAccessRuleResponse) String() string {
	return dara.Prettify(s)
}

func (s ModifyAccessRuleResponse) GoString() string {
	return s.String()
}

func (s *ModifyAccessRuleResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *ModifyAccessRuleResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *ModifyAccessRuleResponse) GetBody() *ModifyAccessRuleResponseBody {
	return s.Body
}

func (s *ModifyAccessRuleResponse) SetHeaders(v map[string]*string) *ModifyAccessRuleResponse {
	s.Headers = v
	return s
}

func (s *ModifyAccessRuleResponse) SetStatusCode(v int32) *ModifyAccessRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyAccessRuleResponse) SetBody(v *ModifyAccessRuleResponseBody) *ModifyAccessRuleResponse {
	s.Body = v
	return s
}

func (s *ModifyAccessRuleResponse) Validate() error {
	return dara.Validate(s)
}

type iModifyAutoSnapshotPolicyRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAutoSnapshotPolicyId(v string) *ModifyAutoSnapshotPolicyRequest
	GetAutoSnapshotPolicyId() *string
	SetAutoSnapshotPolicyName(v string) *ModifyAutoSnapshotPolicyRequest
	GetAutoSnapshotPolicyName() *string
	SetRepeatWeekdays(v string) *ModifyAutoSnapshotPolicyRequest
	GetRepeatWeekdays() *string
	SetRetentionDays(v int32) *ModifyAutoSnapshotPolicyRequest
	GetRetentionDays() *int32
	SetTimePoints(v string) *ModifyAutoSnapshotPolicyRequest
	GetTimePoints() *string
}

type ModifyAutoSnapshotPolicyRequest struct {
	// The ID of the automatic snapshot policy.
	//
	// You can call the DescribeAutoSnapshotPolicies operation to view available automatic snapshot policies.
	//
	// This parameter is required.
	//
	// example:
	//
	// sp-extreme-233e6****
	AutoSnapshotPolicyId *string `json:"AutoSnapshotPolicyId,omitempty" xml:"AutoSnapshotPolicyId,omitempty"`
	// The name of the automatic snapshot policy. If you do not specify this parameter, the policy name is not changed.
	//
	// Limits:
	//
	// 	- The name must be 2 to 128 characters in length.
	//
	// 	- The name must start with a letter.
	//
	// 	- The name can contain digits, letters, colons (:), underscores (_), and hyphens (-). It cannot start with `http://` or `https://`.
	//
	// example:
	//
	// FinanceJoshua
	AutoSnapshotPolicyName *string `json:"AutoSnapshotPolicyName,omitempty" xml:"AutoSnapshotPolicyName,omitempty"`
	// The days of a week on which auto snapshots are created.
	//
	// Cycle: week.
	//
	// Valid values: 1 to 7. The value 1 indicates Monday. If you want to create multiple auto snapshots within a week, you can specify multiple days from Monday to Sunday and separate the days with commas (,). You can specify a maximum of seven days.
	//
	// example:
	//
	// 1,7
	RepeatWeekdays *string `json:"RepeatWeekdays,omitempty" xml:"RepeatWeekdays,omitempty"`
	// The retention period of auto snapshots.
	//
	// Unit: days.
	//
	// Valid values:
	//
	// 	- \\-1 (default): Auto snapshots are permanently retained. After the number of auto snapshots exceeds the upper limit, the earliest auto snapshot is automatically deleted.
	//
	// 	- 1 to 65536: Auto snapshots are retained for the specified number of days. After the retention period of auto snapshots expires, the auto snapshots are automatically deleted.
	//
	// example:
	//
	// 30
	RetentionDays *int32 `json:"RetentionDays,omitempty" xml:"RetentionDays,omitempty"`
	// The points in time at which auto snapshots are created.
	//
	// Unit: hours.
	//
	// Valid values: 0 to 23. The values from 0 to 23 indicate a total of 24 hours from 00:00 to 23:00. For example, the value 1 indicates 01:00. If you want to create multiple auto snapshots within a day, you can specify multiple points in time and separate the points in time with commas (,). You can specify a maximum of 24 points in time.
	//
	// example:
	//
	// 0,1
	TimePoints *string `json:"TimePoints,omitempty" xml:"TimePoints,omitempty"`
}

func (s ModifyAutoSnapshotPolicyRequest) String() string {
	return dara.Prettify(s)
}

func (s ModifyAutoSnapshotPolicyRequest) GoString() string {
	return s.String()
}

func (s *ModifyAutoSnapshotPolicyRequest) GetAutoSnapshotPolicyId() *string {
	return s.AutoSnapshotPolicyId
}

func (s *ModifyAutoSnapshotPolicyRequest) GetAutoSnapshotPolicyName() *string {
	return s.AutoSnapshotPolicyName
}

func (s *ModifyAutoSnapshotPolicyRequest) GetRepeatWeekdays() *string {
	return s.RepeatWeekdays
}

func (s *ModifyAutoSnapshotPolicyRequest) GetRetentionDays() *int32 {
	return s.RetentionDays
}

func (s *ModifyAutoSnapshotPolicyRequest) GetTimePoints() *string {
	return s.TimePoints
}

func (s *ModifyAutoSnapshotPolicyRequest) SetAutoSnapshotPolicyId(v string) *ModifyAutoSnapshotPolicyRequest {
	s.AutoSnapshotPolicyId = &v
	return s
}

func (s *ModifyAutoSnapshotPolicyRequest) SetAutoSnapshotPolicyName(v string) *ModifyAutoSnapshotPolicyRequest {
	s.AutoSnapshotPolicyName = &v
	return s
}

func (s *ModifyAutoSnapshotPolicyRequest) SetRepeatWeekdays(v string) *ModifyAutoSnapshotPolicyRequest {
	s.RepeatWeekdays = &v
	return s
}

func (s *ModifyAutoSnapshotPolicyRequest) SetRetentionDays(v int32) *ModifyAutoSnapshotPolicyRequest {
	s.RetentionDays = &v
	return s
}

func (s *ModifyAutoSnapshotPolicyRequest) SetTimePoints(v string) *ModifyAutoSnapshotPolicyRequest {
	s.TimePoints = &v
	return s
}

func (s *ModifyAutoSnapshotPolicyRequest) Validate() error {
	return dara.Validate(s)
}

type iModifyAutoSnapshotPolicyResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *ModifyAutoSnapshotPolicyResponseBody
	GetRequestId() *string
}

type ModifyAutoSnapshotPolicyResponseBody struct {
	// The request ID.
	//
	// Every response returns a unique request ID regardless of whether the request is successful.
	//
	// example:
	//
	// 473469C7-AA6F-4DC5-B3DB-A3DC0DE3****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyAutoSnapshotPolicyResponseBody) String() string {
	return dara.Prettify(s)
}

func (s ModifyAutoSnapshotPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyAutoSnapshotPolicyResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *ModifyAutoSnapshotPolicyResponseBody) SetRequestId(v string) *ModifyAutoSnapshotPolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyAutoSnapshotPolicyResponseBody) Validate() error {
	return dara.Validate(s)
}

type iModifyAutoSnapshotPolicyResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *ModifyAutoSnapshotPolicyResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *ModifyAutoSnapshotPolicyResponse
	GetStatusCode() *int32
	SetBody(v *ModifyAutoSnapshotPolicyResponseBody) *ModifyAutoSnapshotPolicyResponse
	GetBody() *ModifyAutoSnapshotPolicyResponseBody
}

type ModifyAutoSnapshotPolicyResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyAutoSnapshotPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyAutoSnapshotPolicyResponse) String() string {
	return dara.Prettify(s)
}

func (s ModifyAutoSnapshotPolicyResponse) GoString() string {
	return s.String()
}

func (s *ModifyAutoSnapshotPolicyResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *ModifyAutoSnapshotPolicyResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *ModifyAutoSnapshotPolicyResponse) GetBody() *ModifyAutoSnapshotPolicyResponseBody {
	return s.Body
}

func (s *ModifyAutoSnapshotPolicyResponse) SetHeaders(v map[string]*string) *ModifyAutoSnapshotPolicyResponse {
	s.Headers = v
	return s
}

func (s *ModifyAutoSnapshotPolicyResponse) SetStatusCode(v int32) *ModifyAutoSnapshotPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyAutoSnapshotPolicyResponse) SetBody(v *ModifyAutoSnapshotPolicyResponseBody) *ModifyAutoSnapshotPolicyResponse {
	s.Body = v
	return s
}

func (s *ModifyAutoSnapshotPolicyResponse) Validate() error {
	return dara.Validate(s)
}

type iModifyDataFlowRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientToken(v string) *ModifyDataFlowRequest
	GetClientToken() *string
	SetDataFlowId(v string) *ModifyDataFlowRequest
	GetDataFlowId() *string
	SetDescription(v string) *ModifyDataFlowRequest
	GetDescription() *string
	SetDryRun(v bool) *ModifyDataFlowRequest
	GetDryRun() *bool
	SetFileSystemId(v string) *ModifyDataFlowRequest
	GetFileSystemId() *string
	SetThroughput(v int64) *ModifyDataFlowRequest
	GetThroughput() *int64
}

type ModifyDataFlowRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// >  If you do not specify this parameter, the system automatically uses the request ID as the client token. The value of RequestId may be different for each API request.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-42665544****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The dataflow ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// df-194433a5be31****
	DataFlowId *string `json:"DataFlowId,omitempty" xml:"DataFlowId,omitempty"`
	// The description of the dataflow.
	//
	// Limits:
	//
	// 	- The description must be 2 to 128 characters in length.
	//
	// 	- The description must start with a letter but cannot start with http:// or https://.
	//
	// 	- The description can contain letters, digits, colons (:), underscores (_), and hyphens (-).
	//
	// example:
	//
	// test
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to perform a dry run.
	//
	// During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no file system is created and no fee is incurred.
	//
	// Valid values:
	//
	// 	- true: performs a dry run. The system checks the required parameters, request syntax, limits, and available NAS resources. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the FileSystemId parameter.
	//
	// 	- false (default): performs a dry run and sends the request. If the request passes the dry run, a file system is created.
	//
	// example:
	//
	// false
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the file system.
	//
	// 	- The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-125487\\*\\*\\*\\*.
	//
	// 	- The IDs of CPFS for LINGJUN file systems must start with `bmcpfs-`. Example: bmcpfs-0015\\*\\*\\*\\*.
	//
	// >  CPFS is not supported on the international site.
	//
	// This parameter is required.
	//
	// example:
	//
	// cpfs-099394bd928c****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The maximum data flow throughput. Unit: MB/s. Valid values:
	//
	// 	- 600
	//
	// 	- 1200
	//
	// 	- 1500
	//
	// >  The data flow throughput must be less than the I/O throughput of the file system. This parameter is required for CPFS file systems.
	//
	// example:
	//
	// 600
	Throughput *int64 `json:"Throughput,omitempty" xml:"Throughput,omitempty"`
}

func (s ModifyDataFlowRequest) String() string {
	return dara.Prettify(s)
}

func (s ModifyDataFlowRequest) GoString() string {
	return s.String()
}

func (s *ModifyDataFlowRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *ModifyDataFlowRequest) GetDataFlowId() *string {
	return s.DataFlowId
}

func (s *ModifyDataFlowRequest) GetDescription() *string {
	return s.Description
}

func (s *ModifyDataFlowRequest) GetDryRun() *bool {
	return s.DryRun
}

func (s *ModifyDataFlowRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *ModifyDataFlowRequest) GetThroughput() *int64 {
	return s.Throughput
}

func (s *ModifyDataFlowRequest) SetClientToken(v string) *ModifyDataFlowRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyDataFlowRequest) SetDataFlowId(v string) *ModifyDataFlowRequest {
	s.DataFlowId = &v
	return s
}

func (s *ModifyDataFlowRequest) SetDescription(v string) *ModifyDataFlowRequest {
	s.Description = &v
	return s
}

func (s *ModifyDataFlowRequest) SetDryRun(v bool) *ModifyDataFlowRequest {
	s.DryRun = &v
	return s
}

func (s *ModifyDataFlowRequest) SetFileSystemId(v string) *ModifyDataFlowRequest {
	s.FileSystemId = &v
	return s
}

func (s *ModifyDataFlowRequest) SetThroughput(v int64) *ModifyDataFlowRequest {
	s.Throughput = &v
	return s
}

func (s *ModifyDataFlowRequest) Validate() error {
	return dara.Validate(s)
}

type iModifyDataFlowResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *ModifyDataFlowResponseBody
	GetRequestId() *string
}

type ModifyDataFlowResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 98696EF0-1607-4E9D-B01D-F20930B6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDataFlowResponseBody) String() string {
	return dara.Prettify(s)
}

func (s ModifyDataFlowResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDataFlowResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *ModifyDataFlowResponseBody) SetRequestId(v string) *ModifyDataFlowResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyDataFlowResponseBody) Validate() error {
	return dara.Validate(s)
}

type iModifyDataFlowResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *ModifyDataFlowResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *ModifyDataFlowResponse
	GetStatusCode() *int32
	SetBody(v *ModifyDataFlowResponseBody) *ModifyDataFlowResponse
	GetBody() *ModifyDataFlowResponseBody
}

type ModifyDataFlowResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyDataFlowResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyDataFlowResponse) String() string {
	return dara.Prettify(s)
}

func (s ModifyDataFlowResponse) GoString() string {
	return s.String()
}

func (s *ModifyDataFlowResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *ModifyDataFlowResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *ModifyDataFlowResponse) GetBody() *ModifyDataFlowResponseBody {
	return s.Body
}

func (s *ModifyDataFlowResponse) SetHeaders(v map[string]*string) *ModifyDataFlowResponse {
	s.Headers = v
	return s
}

func (s *ModifyDataFlowResponse) SetStatusCode(v int32) *ModifyDataFlowResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDataFlowResponse) SetBody(v *ModifyDataFlowResponseBody) *ModifyDataFlowResponse {
	s.Body = v
	return s
}

func (s *ModifyDataFlowResponse) Validate() error {
	return dara.Validate(s)
}

type iModifyDataFlowAutoRefreshRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAutoRefreshInterval(v int64) *ModifyDataFlowAutoRefreshRequest
	GetAutoRefreshInterval() *int64
	SetAutoRefreshPolicy(v string) *ModifyDataFlowAutoRefreshRequest
	GetAutoRefreshPolicy() *string
	SetClientToken(v string) *ModifyDataFlowAutoRefreshRequest
	GetClientToken() *string
	SetDataFlowId(v string) *ModifyDataFlowAutoRefreshRequest
	GetDataFlowId() *string
	SetDryRun(v bool) *ModifyDataFlowAutoRefreshRequest
	GetDryRun() *bool
	SetFileSystemId(v string) *ModifyDataFlowAutoRefreshRequest
	GetFileSystemId() *string
}

type ModifyDataFlowAutoRefreshRequest struct {
	// The automatic update interval. CPFS checks whether data is updated in the directory at the interval. If data is updated, CPFS runs an AutoRefresh task. Unit: minutes.
	//
	// Valid values: 5 to 526600. Default value: 10.
	//
	// example:
	//
	// 10
	AutoRefreshInterval *int64 `json:"AutoRefreshInterval,omitempty" xml:"AutoRefreshInterval,omitempty"`
	// The automatic update policy. CPFS imports data updates in the Object Storage Service (OSS) bucket to the CPFS file system based on this policy. Valid values:
	//
	// 	- None: CPFS does not automatically import data updates in the OSS bucket to the CPFS file system. You can import the data updates by using a dataflow task.
	//
	// 	- ImportChanged: CPFS automatically imports data updates in the OSS bucket to the CPFS file system.
	//
	// example:
	//
	// None
	AutoRefreshPolicy *string `json:"AutoRefreshPolicy,omitempty" xml:"AutoRefreshPolicy,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// >  If you do not specify this parameter, the system automatically uses the request ID as the client token. The value of RequestId may be different for each API request.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-42665544****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The dataflow ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// df-194433a5be31****
	DataFlowId *string `json:"DataFlowId,omitempty" xml:"DataFlowId,omitempty"`
	// Specifies whether to perform a dry run.
	//
	// During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no file system is created and no fee is incurred.
	//
	// Valid values:
	//
	// 	- true: performs a dry run. The system checks the required parameters, request syntax, limits, and available NAS resources. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the FileSystemId parameter.
	//
	// 	- false (default): performs a dry run and sends the request. If the request passes the dry run, a file system is created.
	//
	// example:
	//
	// false
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// cpfs-099394bd928c****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
}

func (s ModifyDataFlowAutoRefreshRequest) String() string {
	return dara.Prettify(s)
}

func (s ModifyDataFlowAutoRefreshRequest) GoString() string {
	return s.String()
}

func (s *ModifyDataFlowAutoRefreshRequest) GetAutoRefreshInterval() *int64 {
	return s.AutoRefreshInterval
}

func (s *ModifyDataFlowAutoRefreshRequest) GetAutoRefreshPolicy() *string {
	return s.AutoRefreshPolicy
}

func (s *ModifyDataFlowAutoRefreshRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *ModifyDataFlowAutoRefreshRequest) GetDataFlowId() *string {
	return s.DataFlowId
}

func (s *ModifyDataFlowAutoRefreshRequest) GetDryRun() *bool {
	return s.DryRun
}

func (s *ModifyDataFlowAutoRefreshRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *ModifyDataFlowAutoRefreshRequest) SetAutoRefreshInterval(v int64) *ModifyDataFlowAutoRefreshRequest {
	s.AutoRefreshInterval = &v
	return s
}

func (s *ModifyDataFlowAutoRefreshRequest) SetAutoRefreshPolicy(v string) *ModifyDataFlowAutoRefreshRequest {
	s.AutoRefreshPolicy = &v
	return s
}

func (s *ModifyDataFlowAutoRefreshRequest) SetClientToken(v string) *ModifyDataFlowAutoRefreshRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyDataFlowAutoRefreshRequest) SetDataFlowId(v string) *ModifyDataFlowAutoRefreshRequest {
	s.DataFlowId = &v
	return s
}

func (s *ModifyDataFlowAutoRefreshRequest) SetDryRun(v bool) *ModifyDataFlowAutoRefreshRequest {
	s.DryRun = &v
	return s
}

func (s *ModifyDataFlowAutoRefreshRequest) SetFileSystemId(v string) *ModifyDataFlowAutoRefreshRequest {
	s.FileSystemId = &v
	return s
}

func (s *ModifyDataFlowAutoRefreshRequest) Validate() error {
	return dara.Validate(s)
}

type iModifyDataFlowAutoRefreshResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *ModifyDataFlowAutoRefreshResponseBody
	GetRequestId() *string
}

type ModifyDataFlowAutoRefreshResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 98696EF0-1607-4E9D-B01D-F20930B6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDataFlowAutoRefreshResponseBody) String() string {
	return dara.Prettify(s)
}

func (s ModifyDataFlowAutoRefreshResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDataFlowAutoRefreshResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *ModifyDataFlowAutoRefreshResponseBody) SetRequestId(v string) *ModifyDataFlowAutoRefreshResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyDataFlowAutoRefreshResponseBody) Validate() error {
	return dara.Validate(s)
}

type iModifyDataFlowAutoRefreshResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *ModifyDataFlowAutoRefreshResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *ModifyDataFlowAutoRefreshResponse
	GetStatusCode() *int32
	SetBody(v *ModifyDataFlowAutoRefreshResponseBody) *ModifyDataFlowAutoRefreshResponse
	GetBody() *ModifyDataFlowAutoRefreshResponseBody
}

type ModifyDataFlowAutoRefreshResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyDataFlowAutoRefreshResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyDataFlowAutoRefreshResponse) String() string {
	return dara.Prettify(s)
}

func (s ModifyDataFlowAutoRefreshResponse) GoString() string {
	return s.String()
}

func (s *ModifyDataFlowAutoRefreshResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *ModifyDataFlowAutoRefreshResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *ModifyDataFlowAutoRefreshResponse) GetBody() *ModifyDataFlowAutoRefreshResponseBody {
	return s.Body
}

func (s *ModifyDataFlowAutoRefreshResponse) SetHeaders(v map[string]*string) *ModifyDataFlowAutoRefreshResponse {
	s.Headers = v
	return s
}

func (s *ModifyDataFlowAutoRefreshResponse) SetStatusCode(v int32) *ModifyDataFlowAutoRefreshResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDataFlowAutoRefreshResponse) SetBody(v *ModifyDataFlowAutoRefreshResponseBody) *ModifyDataFlowAutoRefreshResponse {
	s.Body = v
	return s
}

func (s *ModifyDataFlowAutoRefreshResponse) Validate() error {
	return dara.Validate(s)
}

type iModifyFileSystemRequest interface {
	dara.Model
	String() string
	GoString() string
	SetDescription(v string) *ModifyFileSystemRequest
	GetDescription() *string
	SetFileSystemId(v string) *ModifyFileSystemRequest
	GetFileSystemId() *string
	SetOptions(v *ModifyFileSystemRequestOptions) *ModifyFileSystemRequest
	GetOptions() *ModifyFileSystemRequestOptions
}

type ModifyFileSystemRequest struct {
	// The description of the file system.
	//
	// Limits:
	//
	// 	- The description must be 2 to 128 characters in length.
	//
	// 	- It must start with a letter but cannot start with `http://` or `https://`.
	//
	// 	- The description can contain letters, digits, colons (:), underscores (_), and hyphens (-).
	//
	// example:
	//
	// NAS-test-1
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the file system.
	//
	// 	- Sample ID of a General-purpose NAS file system: `31a8e4****`.
	//
	// 	- The IDs of Extreme NAS file systems must start with `extreme-`. Example: `extreme-0015****`.
	//
	// 	- The IDs of Cloud Paralleled File System (CPFS) file systems must start with `cpfs-`. Example: `cpfs-125487****`.
	//
	// >CPFS file systems are available only on the China site (aliyun.com).
	//
	// This parameter is required.
	//
	// example:
	//
	// 1ca404****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The options.
	Options *ModifyFileSystemRequestOptions `json:"Options,omitempty" xml:"Options,omitempty" type:"Struct"`
}

func (s ModifyFileSystemRequest) String() string {
	return dara.Prettify(s)
}

func (s ModifyFileSystemRequest) GoString() string {
	return s.String()
}

func (s *ModifyFileSystemRequest) GetDescription() *string {
	return s.Description
}

func (s *ModifyFileSystemRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *ModifyFileSystemRequest) GetOptions() *ModifyFileSystemRequestOptions {
	return s.Options
}

func (s *ModifyFileSystemRequest) SetDescription(v string) *ModifyFileSystemRequest {
	s.Description = &v
	return s
}

func (s *ModifyFileSystemRequest) SetFileSystemId(v string) *ModifyFileSystemRequest {
	s.FileSystemId = &v
	return s
}

func (s *ModifyFileSystemRequest) SetOptions(v *ModifyFileSystemRequestOptions) *ModifyFileSystemRequest {
	s.Options = v
	return s
}

func (s *ModifyFileSystemRequest) Validate() error {
	return dara.Validate(s)
}

type ModifyFileSystemRequestOptions struct {
	// Specifies whether to enable the oplock feature. Valid values:
	//
	// 	- true: enables the feature.
	//
	// 	- false: disables the feature.
	//
	// >  Only Server Message Block (SMB) file systems support this feature.
	//
	// example:
	//
	// true
	EnableOplock *bool `json:"EnableOplock,omitempty" xml:"EnableOplock,omitempty"`
}

func (s ModifyFileSystemRequestOptions) String() string {
	return dara.Prettify(s)
}

func (s ModifyFileSystemRequestOptions) GoString() string {
	return s.String()
}

func (s *ModifyFileSystemRequestOptions) GetEnableOplock() *bool {
	return s.EnableOplock
}

func (s *ModifyFileSystemRequestOptions) SetEnableOplock(v bool) *ModifyFileSystemRequestOptions {
	s.EnableOplock = &v
	return s
}

func (s *ModifyFileSystemRequestOptions) Validate() error {
	return dara.Validate(s)
}

type iModifyFileSystemShrinkRequest interface {
	dara.Model
	String() string
	GoString() string
	SetDescription(v string) *ModifyFileSystemShrinkRequest
	GetDescription() *string
	SetFileSystemId(v string) *ModifyFileSystemShrinkRequest
	GetFileSystemId() *string
	SetOptionsShrink(v string) *ModifyFileSystemShrinkRequest
	GetOptionsShrink() *string
}

type ModifyFileSystemShrinkRequest struct {
	// The description of the file system.
	//
	// Limits:
	//
	// 	- The description must be 2 to 128 characters in length.
	//
	// 	- It must start with a letter but cannot start with `http://` or `https://`.
	//
	// 	- The description can contain letters, digits, colons (:), underscores (_), and hyphens (-).
	//
	// example:
	//
	// NAS-test-1
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the file system.
	//
	// 	- Sample ID of a General-purpose NAS file system: `31a8e4****`.
	//
	// 	- The IDs of Extreme NAS file systems must start with `extreme-`. Example: `extreme-0015****`.
	//
	// 	- The IDs of Cloud Paralleled File System (CPFS) file systems must start with `cpfs-`. Example: `cpfs-125487****`.
	//
	// >CPFS file systems are available only on the China site (aliyun.com).
	//
	// This parameter is required.
	//
	// example:
	//
	// 1ca404****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The options.
	OptionsShrink *string `json:"Options,omitempty" xml:"Options,omitempty"`
}

func (s ModifyFileSystemShrinkRequest) String() string {
	return dara.Prettify(s)
}

func (s ModifyFileSystemShrinkRequest) GoString() string {
	return s.String()
}

func (s *ModifyFileSystemShrinkRequest) GetDescription() *string {
	return s.Description
}

func (s *ModifyFileSystemShrinkRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *ModifyFileSystemShrinkRequest) GetOptionsShrink() *string {
	return s.OptionsShrink
}

func (s *ModifyFileSystemShrinkRequest) SetDescription(v string) *ModifyFileSystemShrinkRequest {
	s.Description = &v
	return s
}

func (s *ModifyFileSystemShrinkRequest) SetFileSystemId(v string) *ModifyFileSystemShrinkRequest {
	s.FileSystemId = &v
	return s
}

func (s *ModifyFileSystemShrinkRequest) SetOptionsShrink(v string) *ModifyFileSystemShrinkRequest {
	s.OptionsShrink = &v
	return s
}

func (s *ModifyFileSystemShrinkRequest) Validate() error {
	return dara.Validate(s)
}

type iModifyFileSystemResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *ModifyFileSystemResponseBody
	GetRequestId() *string
}

type ModifyFileSystemResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 5BC5CB97-9F28-42FE-84A4-0CD0DF42****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyFileSystemResponseBody) String() string {
	return dara.Prettify(s)
}

func (s ModifyFileSystemResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyFileSystemResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *ModifyFileSystemResponseBody) SetRequestId(v string) *ModifyFileSystemResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyFileSystemResponseBody) Validate() error {
	return dara.Validate(s)
}

type iModifyFileSystemResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *ModifyFileSystemResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *ModifyFileSystemResponse
	GetStatusCode() *int32
	SetBody(v *ModifyFileSystemResponseBody) *ModifyFileSystemResponse
	GetBody() *ModifyFileSystemResponseBody
}

type ModifyFileSystemResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyFileSystemResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyFileSystemResponse) String() string {
	return dara.Prettify(s)
}

func (s ModifyFileSystemResponse) GoString() string {
	return s.String()
}

func (s *ModifyFileSystemResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *ModifyFileSystemResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *ModifyFileSystemResponse) GetBody() *ModifyFileSystemResponseBody {
	return s.Body
}

func (s *ModifyFileSystemResponse) SetHeaders(v map[string]*string) *ModifyFileSystemResponse {
	s.Headers = v
	return s
}

func (s *ModifyFileSystemResponse) SetStatusCode(v int32) *ModifyFileSystemResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyFileSystemResponse) SetBody(v *ModifyFileSystemResponseBody) *ModifyFileSystemResponse {
	s.Body = v
	return s
}

func (s *ModifyFileSystemResponse) Validate() error {
	return dara.Validate(s)
}

type iModifyFilesetRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientToken(v string) *ModifyFilesetRequest
	GetClientToken() *string
	SetDeletionProtection(v bool) *ModifyFilesetRequest
	GetDeletionProtection() *bool
	SetDescription(v string) *ModifyFilesetRequest
	GetDescription() *string
	SetDryRun(v bool) *ModifyFilesetRequest
	GetDryRun() *bool
	SetFileSystemId(v string) *ModifyFilesetRequest
	GetFileSystemId() *string
	SetFsetId(v string) *ModifyFilesetRequest
	GetFsetId() *string
}

type ModifyFilesetRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// >  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-42665544****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to enable deletion protection to allow you to release the fileset by using the console or by calling the [DeleteFileset](https://help.aliyun.com/document_detail/2838077.html) operation.
	//
	// 	- true: enables release protection.
	//
	// 	- false: disables release protection.
	//
	// >  This parameter can protect filesets only against manual releases, but not against automatic releases.
	//
	// if can be null:
	// true
	//
	// example:
	//
	// false
	DeletionProtection *bool `json:"DeletionProtection,omitempty" xml:"DeletionProtection,omitempty"`
	// The fileset description.
	//
	// example:
	//
	// test
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to perform only a dry run, without performing the actual request.
	//
	// During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no fileset is modified and no fees incurred.
	//
	// Valid values:
	//
	// 	- true: performs only a dry run. The system checks the required parameters, request syntax, service limits, and Apsara File Storage NAS (NAS) inventory data. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned.
	//
	// 	- false (default): performs a dry run and sends the request. If the request passes the dry run, the specified fileset is modified.
	//
	// example:
	//
	// false
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the file system.
	//
	// 	- The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-099394bd928c\\*\\*\\*\\*.
	//
	// 	- The IDs of CPFS for LINGJUN file systems must start with `bmcpfs-`. Example: bmcpfs-290w65p03ok64ya\\*\\*\\*\\*.
	//
	// >  CPFS is not supported on the international site.
	//
	// This parameter is required.
	//
	// example:
	//
	// bmcpfs-290w65p03ok64ya****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The fileset ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// fset-1902718ea0ae****
	FsetId *string `json:"FsetId,omitempty" xml:"FsetId,omitempty"`
}

func (s ModifyFilesetRequest) String() string {
	return dara.Prettify(s)
}

func (s ModifyFilesetRequest) GoString() string {
	return s.String()
}

func (s *ModifyFilesetRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *ModifyFilesetRequest) GetDeletionProtection() *bool {
	return s.DeletionProtection
}

func (s *ModifyFilesetRequest) GetDescription() *string {
	return s.Description
}

func (s *ModifyFilesetRequest) GetDryRun() *bool {
	return s.DryRun
}

func (s *ModifyFilesetRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *ModifyFilesetRequest) GetFsetId() *string {
	return s.FsetId
}

func (s *ModifyFilesetRequest) SetClientToken(v string) *ModifyFilesetRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyFilesetRequest) SetDeletionProtection(v bool) *ModifyFilesetRequest {
	s.DeletionProtection = &v
	return s
}

func (s *ModifyFilesetRequest) SetDescription(v string) *ModifyFilesetRequest {
	s.Description = &v
	return s
}

func (s *ModifyFilesetRequest) SetDryRun(v bool) *ModifyFilesetRequest {
	s.DryRun = &v
	return s
}

func (s *ModifyFilesetRequest) SetFileSystemId(v string) *ModifyFilesetRequest {
	s.FileSystemId = &v
	return s
}

func (s *ModifyFilesetRequest) SetFsetId(v string) *ModifyFilesetRequest {
	s.FsetId = &v
	return s
}

func (s *ModifyFilesetRequest) Validate() error {
	return dara.Validate(s)
}

type iModifyFilesetResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *ModifyFilesetResponseBody
	GetRequestId() *string
}

type ModifyFilesetResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 2D69A58F-345C-4FDE-88E4-BF518948****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyFilesetResponseBody) String() string {
	return dara.Prettify(s)
}

func (s ModifyFilesetResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyFilesetResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *ModifyFilesetResponseBody) SetRequestId(v string) *ModifyFilesetResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyFilesetResponseBody) Validate() error {
	return dara.Validate(s)
}

type iModifyFilesetResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *ModifyFilesetResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *ModifyFilesetResponse
	GetStatusCode() *int32
	SetBody(v *ModifyFilesetResponseBody) *ModifyFilesetResponse
	GetBody() *ModifyFilesetResponseBody
}

type ModifyFilesetResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyFilesetResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyFilesetResponse) String() string {
	return dara.Prettify(s)
}

func (s ModifyFilesetResponse) GoString() string {
	return s.String()
}

func (s *ModifyFilesetResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *ModifyFilesetResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *ModifyFilesetResponse) GetBody() *ModifyFilesetResponseBody {
	return s.Body
}

func (s *ModifyFilesetResponse) SetHeaders(v map[string]*string) *ModifyFilesetResponse {
	s.Headers = v
	return s
}

func (s *ModifyFilesetResponse) SetStatusCode(v int32) *ModifyFilesetResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyFilesetResponse) SetBody(v *ModifyFilesetResponseBody) *ModifyFilesetResponse {
	s.Body = v
	return s
}

func (s *ModifyFilesetResponse) Validate() error {
	return dara.Validate(s)
}

type iModifyLDAPConfigRequest interface {
	dara.Model
	String() string
	GoString() string
	SetBindDN(v string) *ModifyLDAPConfigRequest
	GetBindDN() *string
	SetFileSystemId(v string) *ModifyLDAPConfigRequest
	GetFileSystemId() *string
	SetSearchBase(v string) *ModifyLDAPConfigRequest
	GetSearchBase() *string
	SetURI(v string) *ModifyLDAPConfigRequest
	GetURI() *string
}

type ModifyLDAPConfigRequest struct {
	// The LDAP entry.
	//
	// example:
	//
	// cn=alibaba,dc=com
	BindDN *string `json:"BindDN,omitempty" xml:"BindDN,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 109c042666
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The LDAP search base.
	//
	// This parameter is required.
	//
	// example:
	//
	// dc=example
	SearchBase *string `json:"SearchBase,omitempty" xml:"SearchBase,omitempty"`
	// The LDAP service address.
	//
	// This parameter is required.
	//
	// example:
	//
	// ldap://ldap.example.example
	URI *string `json:"URI,omitempty" xml:"URI,omitempty"`
}

func (s ModifyLDAPConfigRequest) String() string {
	return dara.Prettify(s)
}

func (s ModifyLDAPConfigRequest) GoString() string {
	return s.String()
}

func (s *ModifyLDAPConfigRequest) GetBindDN() *string {
	return s.BindDN
}

func (s *ModifyLDAPConfigRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *ModifyLDAPConfigRequest) GetSearchBase() *string {
	return s.SearchBase
}

func (s *ModifyLDAPConfigRequest) GetURI() *string {
	return s.URI
}

func (s *ModifyLDAPConfigRequest) SetBindDN(v string) *ModifyLDAPConfigRequest {
	s.BindDN = &v
	return s
}

func (s *ModifyLDAPConfigRequest) SetFileSystemId(v string) *ModifyLDAPConfigRequest {
	s.FileSystemId = &v
	return s
}

func (s *ModifyLDAPConfigRequest) SetSearchBase(v string) *ModifyLDAPConfigRequest {
	s.SearchBase = &v
	return s
}

func (s *ModifyLDAPConfigRequest) SetURI(v string) *ModifyLDAPConfigRequest {
	s.URI = &v
	return s
}

func (s *ModifyLDAPConfigRequest) Validate() error {
	return dara.Validate(s)
}

type iModifyLDAPConfigResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *ModifyLDAPConfigResponseBody
	GetRequestId() *string
}

type ModifyLDAPConfigResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 5B4511A7-C99E-4071-AA8C-32E2529DA963
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyLDAPConfigResponseBody) String() string {
	return dara.Prettify(s)
}

func (s ModifyLDAPConfigResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyLDAPConfigResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *ModifyLDAPConfigResponseBody) SetRequestId(v string) *ModifyLDAPConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyLDAPConfigResponseBody) Validate() error {
	return dara.Validate(s)
}

type iModifyLDAPConfigResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *ModifyLDAPConfigResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *ModifyLDAPConfigResponse
	GetStatusCode() *int32
	SetBody(v *ModifyLDAPConfigResponseBody) *ModifyLDAPConfigResponse
	GetBody() *ModifyLDAPConfigResponseBody
}

type ModifyLDAPConfigResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyLDAPConfigResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyLDAPConfigResponse) String() string {
	return dara.Prettify(s)
}

func (s ModifyLDAPConfigResponse) GoString() string {
	return s.String()
}

func (s *ModifyLDAPConfigResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *ModifyLDAPConfigResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *ModifyLDAPConfigResponse) GetBody() *ModifyLDAPConfigResponseBody {
	return s.Body
}

func (s *ModifyLDAPConfigResponse) SetHeaders(v map[string]*string) *ModifyLDAPConfigResponse {
	s.Headers = v
	return s
}

func (s *ModifyLDAPConfigResponse) SetStatusCode(v int32) *ModifyLDAPConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyLDAPConfigResponse) SetBody(v *ModifyLDAPConfigResponseBody) *ModifyLDAPConfigResponse {
	s.Body = v
	return s
}

func (s *ModifyLDAPConfigResponse) Validate() error {
	return dara.Validate(s)
}

type iModifyLifecyclePolicyRequest interface {
	dara.Model
	String() string
	GoString() string
	SetEnableLifecycle(v bool) *ModifyLifecyclePolicyRequest
	GetEnableLifecycle() *bool
	SetFileSystemId(v string) *ModifyLifecyclePolicyRequest
	GetFileSystemId() *string
	SetFsetIds(v []*string) *ModifyLifecyclePolicyRequest
	GetFsetIds() []*string
	SetLifecyclePolicyName(v string) *ModifyLifecyclePolicyRequest
	GetLifecyclePolicyName() *string
	SetLifecycleRuleName(v string) *ModifyLifecyclePolicyRequest
	GetLifecycleRuleName() *string
	SetPath(v string) *ModifyLifecyclePolicyRequest
	GetPath() *string
	SetStorageType(v string) *ModifyLifecyclePolicyRequest
	GetStorageType() *string
}

type ModifyLifecyclePolicyRequest struct {
	EnableLifecycle *bool `json:"EnableLifecycle,omitempty" xml:"EnableLifecycle,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 31a8e4****
	FileSystemId *string   `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	FsetIds      []*string `json:"FsetIds,omitempty" xml:"FsetIds,omitempty" type:"Repeated"`
	// The name of the lifecycle policy.
	//
	// The name must be 3 to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-). The name must start with a letter.
	//
	// This parameter is required.
	//
	// example:
	//
	// lifecyclepolicy_01
	LifecyclePolicyName *string `json:"LifecyclePolicyName,omitempty" xml:"LifecyclePolicyName,omitempty"`
	// The management rule that is associated with the lifecycle policy.
	//
	// Valid values:
	//
	// 	- DEFAULT_ATIME_14: Files that are not accessed in the last 14 days are dumped to the IA storage medium.
	//
	// 	- DEFAULT_ATIME_30: Files that are not accessed in the last 30 days are dumped to the IA storage medium.
	//
	// 	- DEFAULT_ATIME_60: Files that are not accessed in the last 60 days are dumped to the IA storage medium.
	//
	// 	- DEFAULT_ATIME_90: Files that are not accessed in the last 90 days are dumped to the IA storage medium.
	//
	// example:
	//
	// DEFAULT_ATIME_14
	LifecycleRuleName *string `json:"LifecycleRuleName,omitempty" xml:"LifecycleRuleName,omitempty"`
	// The absolute path of a directory with which the lifecycle policy is associated.
	//
	// The path must start with a forward slash (/) and must be a path that exists in the mount target.
	//
	// example:
	//
	// /pathway/to/folder
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The storage type of the data that is dumped to the IA storage medium.
	//
	// Default value: InfrequentAccess (IA).
	//
	// example:
	//
	// InfrequentAccess
	StorageType *string `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
}

func (s ModifyLifecyclePolicyRequest) String() string {
	return dara.Prettify(s)
}

func (s ModifyLifecyclePolicyRequest) GoString() string {
	return s.String()
}

func (s *ModifyLifecyclePolicyRequest) GetEnableLifecycle() *bool {
	return s.EnableLifecycle
}

func (s *ModifyLifecyclePolicyRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *ModifyLifecyclePolicyRequest) GetFsetIds() []*string {
	return s.FsetIds
}

func (s *ModifyLifecyclePolicyRequest) GetLifecyclePolicyName() *string {
	return s.LifecyclePolicyName
}

func (s *ModifyLifecyclePolicyRequest) GetLifecycleRuleName() *string {
	return s.LifecycleRuleName
}

func (s *ModifyLifecyclePolicyRequest) GetPath() *string {
	return s.Path
}

func (s *ModifyLifecyclePolicyRequest) GetStorageType() *string {
	return s.StorageType
}

func (s *ModifyLifecyclePolicyRequest) SetEnableLifecycle(v bool) *ModifyLifecyclePolicyRequest {
	s.EnableLifecycle = &v
	return s
}

func (s *ModifyLifecyclePolicyRequest) SetFileSystemId(v string) *ModifyLifecyclePolicyRequest {
	s.FileSystemId = &v
	return s
}

func (s *ModifyLifecyclePolicyRequest) SetFsetIds(v []*string) *ModifyLifecyclePolicyRequest {
	s.FsetIds = v
	return s
}

func (s *ModifyLifecyclePolicyRequest) SetLifecyclePolicyName(v string) *ModifyLifecyclePolicyRequest {
	s.LifecyclePolicyName = &v
	return s
}

func (s *ModifyLifecyclePolicyRequest) SetLifecycleRuleName(v string) *ModifyLifecyclePolicyRequest {
	s.LifecycleRuleName = &v
	return s
}

func (s *ModifyLifecyclePolicyRequest) SetPath(v string) *ModifyLifecyclePolicyRequest {
	s.Path = &v
	return s
}

func (s *ModifyLifecyclePolicyRequest) SetStorageType(v string) *ModifyLifecyclePolicyRequest {
	s.StorageType = &v
	return s
}

func (s *ModifyLifecyclePolicyRequest) Validate() error {
	return dara.Validate(s)
}

type iModifyLifecyclePolicyResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *ModifyLifecyclePolicyResponseBody
	GetRequestId() *string
	SetSuccess(v bool) *ModifyLifecyclePolicyResponseBody
	GetSuccess() *bool
}

type ModifyLifecyclePolicyResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// BC7C825C-5F65-4B56-BEF6-98C56C7C****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	//
	// Valid values:
	//
	// 	- true
	//
	// 	- false
	//
	// example:
	//
	// true
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ModifyLifecyclePolicyResponseBody) String() string {
	return dara.Prettify(s)
}

func (s ModifyLifecyclePolicyResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyLifecyclePolicyResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *ModifyLifecyclePolicyResponseBody) GetSuccess() *bool {
	return s.Success
}

func (s *ModifyLifecyclePolicyResponseBody) SetRequestId(v string) *ModifyLifecyclePolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyLifecyclePolicyResponseBody) SetSuccess(v bool) *ModifyLifecyclePolicyResponseBody {
	s.Success = &v
	return s
}

func (s *ModifyLifecyclePolicyResponseBody) Validate() error {
	return dara.Validate(s)
}

type iModifyLifecyclePolicyResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *ModifyLifecyclePolicyResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *ModifyLifecyclePolicyResponse
	GetStatusCode() *int32
	SetBody(v *ModifyLifecyclePolicyResponseBody) *ModifyLifecyclePolicyResponse
	GetBody() *ModifyLifecyclePolicyResponseBody
}

type ModifyLifecyclePolicyResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyLifecyclePolicyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyLifecyclePolicyResponse) String() string {
	return dara.Prettify(s)
}

func (s ModifyLifecyclePolicyResponse) GoString() string {
	return s.String()
}

func (s *ModifyLifecyclePolicyResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *ModifyLifecyclePolicyResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *ModifyLifecyclePolicyResponse) GetBody() *ModifyLifecyclePolicyResponseBody {
	return s.Body
}

func (s *ModifyLifecyclePolicyResponse) SetHeaders(v map[string]*string) *ModifyLifecyclePolicyResponse {
	s.Headers = v
	return s
}

func (s *ModifyLifecyclePolicyResponse) SetStatusCode(v int32) *ModifyLifecyclePolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyLifecyclePolicyResponse) SetBody(v *ModifyLifecyclePolicyResponseBody) *ModifyLifecyclePolicyResponse {
	s.Body = v
	return s
}

func (s *ModifyLifecyclePolicyResponse) Validate() error {
	return dara.Validate(s)
}

type iModifyMountTargetRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAccessGroupName(v string) *ModifyMountTargetRequest
	GetAccessGroupName() *string
	SetDualStackMountTargetDomain(v string) *ModifyMountTargetRequest
	GetDualStackMountTargetDomain() *string
	SetFileSystemId(v string) *ModifyMountTargetRequest
	GetFileSystemId() *string
	SetMountTargetDomain(v string) *ModifyMountTargetRequest
	GetMountTargetDomain() *string
	SetStatus(v string) *ModifyMountTargetRequest
	GetStatus() *string
}

type ModifyMountTargetRequest struct {
	// The name of the permission group that is attached to the mount target.
	//
	// example:
	//
	// classic-test
	AccessGroupName *string `json:"AccessGroupName,omitempty" xml:"AccessGroupName,omitempty"`
	// The dual-stack (IPv4 and IPv6) domain name of the mount target.
	//
	// >  Only Extreme NAS file systems that reside in the Chinese mainland support IPv6.
	//
	// example:
	//
	// 174494b666-x****.dualstack.cn-hangzhou.nas.aliyuncs.com
	DualStackMountTargetDomain *string `json:"DualStackMountTargetDomain,omitempty" xml:"DualStackMountTargetDomain,omitempty"`
	// The ID of the file system.
	//
	// 	- Sample ID of a General-purpose NAS file system: `31a8e4****`.
	//
	// 	- The IDs of Extreme NAS file systems must start with `extreme-`, for example, `extreme-0015****`.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1ca404****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The IPv4 domain name of the mount target.
	//
	// example:
	//
	// 1ca404a666-w****.cn-hangzhou.nas.aliyuncs.com
	MountTargetDomain *string `json:"MountTargetDomain,omitempty" xml:"MountTargetDomain,omitempty"`
	// The status of the mount target.
	//
	// Valid values:
	//
	// 	- Active: The mount target is available.
	//
	// 	- Inactive: The mount target is unavailable.
	//
	// >  Only General-purpose File Storage NAS (NAS) file systems support changing the mount target status.
	//
	// example:
	//
	// Inactive
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ModifyMountTargetRequest) String() string {
	return dara.Prettify(s)
}

func (s ModifyMountTargetRequest) GoString() string {
	return s.String()
}

func (s *ModifyMountTargetRequest) GetAccessGroupName() *string {
	return s.AccessGroupName
}

func (s *ModifyMountTargetRequest) GetDualStackMountTargetDomain() *string {
	return s.DualStackMountTargetDomain
}

func (s *ModifyMountTargetRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *ModifyMountTargetRequest) GetMountTargetDomain() *string {
	return s.MountTargetDomain
}

func (s *ModifyMountTargetRequest) GetStatus() *string {
	return s.Status
}

func (s *ModifyMountTargetRequest) SetAccessGroupName(v string) *ModifyMountTargetRequest {
	s.AccessGroupName = &v
	return s
}

func (s *ModifyMountTargetRequest) SetDualStackMountTargetDomain(v string) *ModifyMountTargetRequest {
	s.DualStackMountTargetDomain = &v
	return s
}

func (s *ModifyMountTargetRequest) SetFileSystemId(v string) *ModifyMountTargetRequest {
	s.FileSystemId = &v
	return s
}

func (s *ModifyMountTargetRequest) SetMountTargetDomain(v string) *ModifyMountTargetRequest {
	s.MountTargetDomain = &v
	return s
}

func (s *ModifyMountTargetRequest) SetStatus(v string) *ModifyMountTargetRequest {
	s.Status = &v
	return s
}

func (s *ModifyMountTargetRequest) Validate() error {
	return dara.Validate(s)
}

type iModifyMountTargetResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *ModifyMountTargetResponseBody
	GetRequestId() *string
}

type ModifyMountTargetResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// FF387D95-34C4-4879-B65A-99D1FA1B****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyMountTargetResponseBody) String() string {
	return dara.Prettify(s)
}

func (s ModifyMountTargetResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyMountTargetResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *ModifyMountTargetResponseBody) SetRequestId(v string) *ModifyMountTargetResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyMountTargetResponseBody) Validate() error {
	return dara.Validate(s)
}

type iModifyMountTargetResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *ModifyMountTargetResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *ModifyMountTargetResponse
	GetStatusCode() *int32
	SetBody(v *ModifyMountTargetResponseBody) *ModifyMountTargetResponse
	GetBody() *ModifyMountTargetResponseBody
}

type ModifyMountTargetResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyMountTargetResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyMountTargetResponse) String() string {
	return dara.Prettify(s)
}

func (s ModifyMountTargetResponse) GoString() string {
	return s.String()
}

func (s *ModifyMountTargetResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *ModifyMountTargetResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *ModifyMountTargetResponse) GetBody() *ModifyMountTargetResponseBody {
	return s.Body
}

func (s *ModifyMountTargetResponse) SetHeaders(v map[string]*string) *ModifyMountTargetResponse {
	s.Headers = v
	return s
}

func (s *ModifyMountTargetResponse) SetStatusCode(v int32) *ModifyMountTargetResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyMountTargetResponse) SetBody(v *ModifyMountTargetResponseBody) *ModifyMountTargetResponse {
	s.Body = v
	return s
}

func (s *ModifyMountTargetResponse) Validate() error {
	return dara.Validate(s)
}

type iModifyProtocolMountTargetRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAccessGroupName(v string) *ModifyProtocolMountTargetRequest
	GetAccessGroupName() *string
	SetClientToken(v string) *ModifyProtocolMountTargetRequest
	GetClientToken() *string
	SetDescription(v string) *ModifyProtocolMountTargetRequest
	GetDescription() *string
	SetDryRun(v bool) *ModifyProtocolMountTargetRequest
	GetDryRun() *bool
	SetExportId(v string) *ModifyProtocolMountTargetRequest
	GetExportId() *string
	SetFileSystemId(v string) *ModifyProtocolMountTargetRequest
	GetFileSystemId() *string
	SetProtocolServiceId(v string) *ModifyProtocolMountTargetRequest
	GetProtocolServiceId() *string
}

type ModifyProtocolMountTargetRequest struct {
	AccessGroupName *string `json:"AccessGroupName,omitempty" xml:"AccessGroupName,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// >  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.
	//
	// example:
	//
	// 473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the export directory for the protocol service.
	//
	// Limits:
	//
	// 	- The description must be 2 to 128 characters in length.
	//
	// 	- The description must start with a letter but cannot start with `http://` or `https://`.
	//
	// 	- The description can contain letters, digits, colons (:), underscores (_), and hyphens (-).
	//
	// example:
	//
	// test
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to perform only a dry run, without performing the actual request. The dry run checks parameter validity and prerequisites. The dry run does not modify the specified export directory or incur fees.
	//
	// Valid values:
	//
	// 	- true: performs only a dry run. The system checks the required parameters, request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned.
	//
	// 	- false (default): performs a dry run and sends the request.
	//
	// example:
	//
	// true
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the export directory for the protocol service.
	//
	// This parameter is required.
	//
	// example:
	//
	// exp-19abf5beab8d****
	ExportId *string `json:"ExportId,omitempty" xml:"ExportId,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// cpfs-099394bd928c****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The ID of the protocol service.
	//
	// This parameter is required.
	//
	// example:
	//
	// ptc-197ed6a00f2b****
	ProtocolServiceId *string `json:"ProtocolServiceId,omitempty" xml:"ProtocolServiceId,omitempty"`
}

func (s ModifyProtocolMountTargetRequest) String() string {
	return dara.Prettify(s)
}

func (s ModifyProtocolMountTargetRequest) GoString() string {
	return s.String()
}

func (s *ModifyProtocolMountTargetRequest) GetAccessGroupName() *string {
	return s.AccessGroupName
}

func (s *ModifyProtocolMountTargetRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *ModifyProtocolMountTargetRequest) GetDescription() *string {
	return s.Description
}

func (s *ModifyProtocolMountTargetRequest) GetDryRun() *bool {
	return s.DryRun
}

func (s *ModifyProtocolMountTargetRequest) GetExportId() *string {
	return s.ExportId
}

func (s *ModifyProtocolMountTargetRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *ModifyProtocolMountTargetRequest) GetProtocolServiceId() *string {
	return s.ProtocolServiceId
}

func (s *ModifyProtocolMountTargetRequest) SetAccessGroupName(v string) *ModifyProtocolMountTargetRequest {
	s.AccessGroupName = &v
	return s
}

func (s *ModifyProtocolMountTargetRequest) SetClientToken(v string) *ModifyProtocolMountTargetRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyProtocolMountTargetRequest) SetDescription(v string) *ModifyProtocolMountTargetRequest {
	s.Description = &v
	return s
}

func (s *ModifyProtocolMountTargetRequest) SetDryRun(v bool) *ModifyProtocolMountTargetRequest {
	s.DryRun = &v
	return s
}

func (s *ModifyProtocolMountTargetRequest) SetExportId(v string) *ModifyProtocolMountTargetRequest {
	s.ExportId = &v
	return s
}

func (s *ModifyProtocolMountTargetRequest) SetFileSystemId(v string) *ModifyProtocolMountTargetRequest {
	s.FileSystemId = &v
	return s
}

func (s *ModifyProtocolMountTargetRequest) SetProtocolServiceId(v string) *ModifyProtocolMountTargetRequest {
	s.ProtocolServiceId = &v
	return s
}

func (s *ModifyProtocolMountTargetRequest) Validate() error {
	return dara.Validate(s)
}

type iModifyProtocolMountTargetResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *ModifyProtocolMountTargetResponseBody
	GetRequestId() *string
}

type ModifyProtocolMountTargetResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyProtocolMountTargetResponseBody) String() string {
	return dara.Prettify(s)
}

func (s ModifyProtocolMountTargetResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyProtocolMountTargetResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *ModifyProtocolMountTargetResponseBody) SetRequestId(v string) *ModifyProtocolMountTargetResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyProtocolMountTargetResponseBody) Validate() error {
	return dara.Validate(s)
}

type iModifyProtocolMountTargetResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *ModifyProtocolMountTargetResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *ModifyProtocolMountTargetResponse
	GetStatusCode() *int32
	SetBody(v *ModifyProtocolMountTargetResponseBody) *ModifyProtocolMountTargetResponse
	GetBody() *ModifyProtocolMountTargetResponseBody
}

type ModifyProtocolMountTargetResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyProtocolMountTargetResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyProtocolMountTargetResponse) String() string {
	return dara.Prettify(s)
}

func (s ModifyProtocolMountTargetResponse) GoString() string {
	return s.String()
}

func (s *ModifyProtocolMountTargetResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *ModifyProtocolMountTargetResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *ModifyProtocolMountTargetResponse) GetBody() *ModifyProtocolMountTargetResponseBody {
	return s.Body
}

func (s *ModifyProtocolMountTargetResponse) SetHeaders(v map[string]*string) *ModifyProtocolMountTargetResponse {
	s.Headers = v
	return s
}

func (s *ModifyProtocolMountTargetResponse) SetStatusCode(v int32) *ModifyProtocolMountTargetResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyProtocolMountTargetResponse) SetBody(v *ModifyProtocolMountTargetResponseBody) *ModifyProtocolMountTargetResponse {
	s.Body = v
	return s
}

func (s *ModifyProtocolMountTargetResponse) Validate() error {
	return dara.Validate(s)
}

type iModifyProtocolServiceRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientToken(v string) *ModifyProtocolServiceRequest
	GetClientToken() *string
	SetDescription(v string) *ModifyProtocolServiceRequest
	GetDescription() *string
	SetDryRun(v bool) *ModifyProtocolServiceRequest
	GetDryRun() *bool
	SetFileSystemId(v string) *ModifyProtocolServiceRequest
	GetFileSystemId() *string
	SetProtocolServiceId(v string) *ModifyProtocolServiceRequest
	GetProtocolServiceId() *string
	SetProtocolSpec(v string) *ModifyProtocolServiceRequest
	GetProtocolSpec() *string
	SetThroughput(v string) *ModifyProtocolServiceRequest
	GetThroughput() *string
}

type ModifyProtocolServiceRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// >  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-42665544****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the protocol service.
	//
	// Limits:
	//
	// 	- The description must be 2 to 128 characters in length.
	//
	// 	- The description must start with a letter and cannot start with `http://` or `https://`.
	//
	// 	- The description can contain letters, digits, colons (:), underscores (_), and hyphens (-).
	//
	// if can be null:
	// false
	//
	// example:
	//
	// test
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to perform only a dry run, without performing the actual request. The dry run checks parameter validity and prerequisites. The dry run does not modify a file system or incur fees.
	//
	// Valid values:
	//
	// 	- true: performs only a dry run and does not modify the protocol service. The system checks the request format, service limits, prerequisites, and whether the required parameters are specified. If the request fails the dry run, an error message is returned. If the request passes the dry run, a 200 HTTP status code is returned.
	//
	// 	- false (default): performs a dry run and performs the actual request. If the request passes the dry run, the service protocol is modified.
	//
	// example:
	//
	// false
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// cpfs-123****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The ID of the protocol service.
	//
	// This parameter is required.
	//
	// example:
	//
	// ptc-123****
	ProtocolServiceId *string `json:"ProtocolServiceId,omitempty" xml:"ProtocolServiceId,omitempty"`
	ProtocolSpec      *string `json:"ProtocolSpec,omitempty" xml:"ProtocolSpec,omitempty"`
	Throughput        *string `json:"Throughput,omitempty" xml:"Throughput,omitempty"`
}

func (s ModifyProtocolServiceRequest) String() string {
	return dara.Prettify(s)
}

func (s ModifyProtocolServiceRequest) GoString() string {
	return s.String()
}

func (s *ModifyProtocolServiceRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *ModifyProtocolServiceRequest) GetDescription() *string {
	return s.Description
}

func (s *ModifyProtocolServiceRequest) GetDryRun() *bool {
	return s.DryRun
}

func (s *ModifyProtocolServiceRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *ModifyProtocolServiceRequest) GetProtocolServiceId() *string {
	return s.ProtocolServiceId
}

func (s *ModifyProtocolServiceRequest) GetProtocolSpec() *string {
	return s.ProtocolSpec
}

func (s *ModifyProtocolServiceRequest) GetThroughput() *string {
	return s.Throughput
}

func (s *ModifyProtocolServiceRequest) SetClientToken(v string) *ModifyProtocolServiceRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyProtocolServiceRequest) SetDescription(v string) *ModifyProtocolServiceRequest {
	s.Description = &v
	return s
}

func (s *ModifyProtocolServiceRequest) SetDryRun(v bool) *ModifyProtocolServiceRequest {
	s.DryRun = &v
	return s
}

func (s *ModifyProtocolServiceRequest) SetFileSystemId(v string) *ModifyProtocolServiceRequest {
	s.FileSystemId = &v
	return s
}

func (s *ModifyProtocolServiceRequest) SetProtocolServiceId(v string) *ModifyProtocolServiceRequest {
	s.ProtocolServiceId = &v
	return s
}

func (s *ModifyProtocolServiceRequest) SetProtocolSpec(v string) *ModifyProtocolServiceRequest {
	s.ProtocolSpec = &v
	return s
}

func (s *ModifyProtocolServiceRequest) SetThroughput(v string) *ModifyProtocolServiceRequest {
	s.Throughput = &v
	return s
}

func (s *ModifyProtocolServiceRequest) Validate() error {
	return dara.Validate(s)
}

type iModifyProtocolServiceResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *ModifyProtocolServiceResponseBody
	GetRequestId() *string
}

type ModifyProtocolServiceResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 98696EF0-1607-4E9D-B01D-F20930B6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyProtocolServiceResponseBody) String() string {
	return dara.Prettify(s)
}

func (s ModifyProtocolServiceResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyProtocolServiceResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *ModifyProtocolServiceResponseBody) SetRequestId(v string) *ModifyProtocolServiceResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyProtocolServiceResponseBody) Validate() error {
	return dara.Validate(s)
}

type iModifyProtocolServiceResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *ModifyProtocolServiceResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *ModifyProtocolServiceResponse
	GetStatusCode() *int32
	SetBody(v *ModifyProtocolServiceResponseBody) *ModifyProtocolServiceResponse
	GetBody() *ModifyProtocolServiceResponseBody
}

type ModifyProtocolServiceResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyProtocolServiceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyProtocolServiceResponse) String() string {
	return dara.Prettify(s)
}

func (s ModifyProtocolServiceResponse) GoString() string {
	return s.String()
}

func (s *ModifyProtocolServiceResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *ModifyProtocolServiceResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *ModifyProtocolServiceResponse) GetBody() *ModifyProtocolServiceResponseBody {
	return s.Body
}

func (s *ModifyProtocolServiceResponse) SetHeaders(v map[string]*string) *ModifyProtocolServiceResponse {
	s.Headers = v
	return s
}

func (s *ModifyProtocolServiceResponse) SetStatusCode(v int32) *ModifyProtocolServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyProtocolServiceResponse) SetBody(v *ModifyProtocolServiceResponseBody) *ModifyProtocolServiceResponse {
	s.Body = v
	return s
}

func (s *ModifyProtocolServiceResponse) Validate() error {
	return dara.Validate(s)
}

type iModifySmbAclRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAuthCenter(v string) *ModifySmbAclRequest
	GetAuthCenter() *string
	SetAuthMethod(v string) *ModifySmbAclRequest
	GetAuthMethod() *string
	SetEnableAnonymousAccess(v bool) *ModifySmbAclRequest
	GetEnableAnonymousAccess() *bool
	SetEncryptData(v bool) *ModifySmbAclRequest
	GetEncryptData() *bool
	SetFileSystemId(v string) *ModifySmbAclRequest
	GetFileSystemId() *string
	SetHomeDirPath(v string) *ModifySmbAclRequest
	GetHomeDirPath() *string
	SetKeytab(v string) *ModifySmbAclRequest
	GetKeytab() *string
	SetKeytabMd5(v string) *ModifySmbAclRequest
	GetKeytabMd5() *string
	SetRejectUnencryptedAccess(v bool) *ModifySmbAclRequest
	GetRejectUnencryptedAccess() *bool
	SetSuperAdminSid(v string) *ModifySmbAclRequest
	GetSuperAdminSid() *string
}

type ModifySmbAclRequest struct {
	AuthCenter *string `json:"AuthCenter,omitempty" xml:"AuthCenter,omitempty"`
	AuthMethod *string `json:"AuthMethod,omitempty" xml:"AuthMethod,omitempty"`
	// Specifies whether to allow anonymous access. Valid values:
	//
	// 	- true: The file system allows anonymous access.
	//
	// 	- false (default): The file system denies anonymous access.
	//
	// if can be null:
	// false
	//
	// example:
	//
	// false
	EnableAnonymousAccess *bool `json:"EnableAnonymousAccess,omitempty" xml:"EnableAnonymousAccess,omitempty"`
	// Specifies whether to enable encryption in transit. Valid values:
	//
	// 	- true: enables encryption in transit.
	//
	// 	- false (default): disables encryption in transit.
	//
	// example:
	//
	// false
	EncryptData *bool `json:"EncryptData,omitempty" xml:"EncryptData,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1ca404****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The home directory of each user. Each user-specific home directory must meet the following requirements:
	//
	// 	- Each segment starts with a forward slash (/) or a backward slash (\\\\).
	//
	// 	- Each segment does not contain the following special characters: `<>":|?*`.
	//
	// 	- Each segment is 0 to 255 characters in length.
	//
	// 	- The total length is 0 to 32,767 characters.
	//
	// For example, if you create a user named A and the home directory is `/home`, the file system automatically creates a directory named `/home/A` when User A logs on to the file system. If the `/home/A` directory already exists, the file system does not create the directory.
	//
	// > User A must have the permissions to create folders in the \\home directory. Otherwise, the file system cannot create the `/home/A` directory when User A logs on to the file system.
	//
	// example:
	//
	// /home
	HomeDirPath *string `json:"HomeDirPath,omitempty" xml:"HomeDirPath,omitempty"`
	// The string that is generated after the system encodes the keytab file by using Base64.
	//
	// example:
	//
	// BQIAAABHAAIADUFMSUFEVEVTVC5DT00ABGNpZnMAGXNtYnNlcnZlcjI0LmFsaWFkdGVzdC5jb20AAAABAAAAAAEAAQAIqIx6v7p11oUAAABHAAIADUFMSUFEVEVTVC5DT00ABGNpZnMAGXNtYnNlcnZlcjI0LmFsaWFkdGVzdC5jb20AAAABAAAAAAEAAwAIqIx6v7p11oUAAABPAAIADUFMSUFEVEVTVC5DT00ABGNpZnMAGXNtYnNlcnZlcjI0LmFsaWFkdGVzdC5jb20AAAABAAAAAAEAFwAQnQZWB3RAPHU7PMIJyBWePAAAAF8AAgANQUxJQURURVNULkNPTQAEY2lmcwAZc21ic2VydmVyMjQuYWxpYWR0ZXN0LmNvbQAAAAEAAAAAAQASACAGJ7F0s+bcBjf6jD5HlvlRLmPSOW+qDZe0Qk0lQcf8WwAAAE8AAgANQUxJQURURVNULkNPTQAEY2lmcwAZc21ic2VydmVyMjQuYWxpYWR0ZXN0LmNvbQAAAAEAAAAAAQARABDdFmanrSIatnDDh****
	Keytab *string `json:"Keytab,omitempty" xml:"Keytab,omitempty"`
	// The string that is generated after the system encodes the keytab file by using MD5.
	//
	// example:
	//
	// E3CCF7E2416DF04FA958AA4513EA****
	KeytabMd5 *string `json:"KeytabMd5,omitempty" xml:"KeytabMd5,omitempty"`
	// Specifies whether to deny access from non-encrypted clients. Valid values:
	//
	// 	- true: The file system denies access from non-encrypted clients.
	//
	// 	- false (default): The file system allows access from non-encrypted clients.
	//
	// example:
	//
	// false
	RejectUnencryptedAccess *bool `json:"RejectUnencryptedAccess,omitempty" xml:"RejectUnencryptedAccess,omitempty"`
	// The ID of a super admin. The ID must meet the following requirements:
	//
	// 	- The ID starts with `S` and does not contain letters except S.
	//
	// 	- The ID contains at least three hyphens (-) as delimiters.
	//
	// Examples: `S-1-5-22` and `S-1-5-22-23`.
	//
	// example:
	//
	// S-1-5-22
	SuperAdminSid *string `json:"SuperAdminSid,omitempty" xml:"SuperAdminSid,omitempty"`
}

func (s ModifySmbAclRequest) String() string {
	return dara.Prettify(s)
}

func (s ModifySmbAclRequest) GoString() string {
	return s.String()
}

func (s *ModifySmbAclRequest) GetAuthCenter() *string {
	return s.AuthCenter
}

func (s *ModifySmbAclRequest) GetAuthMethod() *string {
	return s.AuthMethod
}

func (s *ModifySmbAclRequest) GetEnableAnonymousAccess() *bool {
	return s.EnableAnonymousAccess
}

func (s *ModifySmbAclRequest) GetEncryptData() *bool {
	return s.EncryptData
}

func (s *ModifySmbAclRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *ModifySmbAclRequest) GetHomeDirPath() *string {
	return s.HomeDirPath
}

func (s *ModifySmbAclRequest) GetKeytab() *string {
	return s.Keytab
}

func (s *ModifySmbAclRequest) GetKeytabMd5() *string {
	return s.KeytabMd5
}

func (s *ModifySmbAclRequest) GetRejectUnencryptedAccess() *bool {
	return s.RejectUnencryptedAccess
}

func (s *ModifySmbAclRequest) GetSuperAdminSid() *string {
	return s.SuperAdminSid
}

func (s *ModifySmbAclRequest) SetAuthCenter(v string) *ModifySmbAclRequest {
	s.AuthCenter = &v
	return s
}

func (s *ModifySmbAclRequest) SetAuthMethod(v string) *ModifySmbAclRequest {
	s.AuthMethod = &v
	return s
}

func (s *ModifySmbAclRequest) SetEnableAnonymousAccess(v bool) *ModifySmbAclRequest {
	s.EnableAnonymousAccess = &v
	return s
}

func (s *ModifySmbAclRequest) SetEncryptData(v bool) *ModifySmbAclRequest {
	s.EncryptData = &v
	return s
}

func (s *ModifySmbAclRequest) SetFileSystemId(v string) *ModifySmbAclRequest {
	s.FileSystemId = &v
	return s
}

func (s *ModifySmbAclRequest) SetHomeDirPath(v string) *ModifySmbAclRequest {
	s.HomeDirPath = &v
	return s
}

func (s *ModifySmbAclRequest) SetKeytab(v string) *ModifySmbAclRequest {
	s.Keytab = &v
	return s
}

func (s *ModifySmbAclRequest) SetKeytabMd5(v string) *ModifySmbAclRequest {
	s.KeytabMd5 = &v
	return s
}

func (s *ModifySmbAclRequest) SetRejectUnencryptedAccess(v bool) *ModifySmbAclRequest {
	s.RejectUnencryptedAccess = &v
	return s
}

func (s *ModifySmbAclRequest) SetSuperAdminSid(v string) *ModifySmbAclRequest {
	s.SuperAdminSid = &v
	return s
}

func (s *ModifySmbAclRequest) Validate() error {
	return dara.Validate(s)
}

type iModifySmbAclResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *ModifySmbAclResponseBody
	GetRequestId() *string
}

type ModifySmbAclResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 98696EF0-1607-4E9D-B01D-F20930B6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifySmbAclResponseBody) String() string {
	return dara.Prettify(s)
}

func (s ModifySmbAclResponseBody) GoString() string {
	return s.String()
}

func (s *ModifySmbAclResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *ModifySmbAclResponseBody) SetRequestId(v string) *ModifySmbAclResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifySmbAclResponseBody) Validate() error {
	return dara.Validate(s)
}

type iModifySmbAclResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *ModifySmbAclResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *ModifySmbAclResponse
	GetStatusCode() *int32
	SetBody(v *ModifySmbAclResponseBody) *ModifySmbAclResponse
	GetBody() *ModifySmbAclResponseBody
}

type ModifySmbAclResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifySmbAclResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifySmbAclResponse) String() string {
	return dara.Prettify(s)
}

func (s ModifySmbAclResponse) GoString() string {
	return s.String()
}

func (s *ModifySmbAclResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *ModifySmbAclResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *ModifySmbAclResponse) GetBody() *ModifySmbAclResponseBody {
	return s.Body
}

func (s *ModifySmbAclResponse) SetHeaders(v map[string]*string) *ModifySmbAclResponse {
	s.Headers = v
	return s
}

func (s *ModifySmbAclResponse) SetStatusCode(v int32) *ModifySmbAclResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifySmbAclResponse) SetBody(v *ModifySmbAclResponseBody) *ModifySmbAclResponse {
	s.Body = v
	return s
}

func (s *ModifySmbAclResponse) Validate() error {
	return dara.Validate(s)
}

type iOpenNASServiceResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetAccessDeniedDetail(v string) *OpenNASServiceResponseBody
	GetAccessDeniedDetail() *string
	SetOrderId(v string) *OpenNASServiceResponseBody
	GetOrderId() *string
	SetRequestId(v string) *OpenNASServiceResponseBody
	GetRequestId() *string
}

type OpenNASServiceResponseBody struct {
	// The details about the failed permission verification.
	//
	// example:
	//
	// {
	//
	//     "PolicyType": "AccountLevelIdentityBasedPolicy",
	//
	//     "AuthPrincipalOwnerId": "178321033379****",
	//
	//     "EncodedDiagnosticMessage": "AJpt/382mjxDSIYIqa/cUIFvOg9tajlLyN+LJA0C78kWfKIl****",
	//
	//     "AuthPrincipalType": "SubUser",
	//
	//     "AuthPrincipalDisplayName": "21794847602038****",
	//
	//     "NoPermissionType": "ImplicitDeny",
	//
	//     "AuthAction": "nas:OpenNASService"
	//
	//   }
	AccessDeniedDetail *string `json:"AccessDeniedDetail,omitempty" xml:"AccessDeniedDetail,omitempty"`
	// The order ID.
	//
	// example:
	//
	// 20671870151****
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 427DB0B3-9436-4A3C-B2BC-B961F95E****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s OpenNASServiceResponseBody) String() string {
	return dara.Prettify(s)
}

func (s OpenNASServiceResponseBody) GoString() string {
	return s.String()
}

func (s *OpenNASServiceResponseBody) GetAccessDeniedDetail() *string {
	return s.AccessDeniedDetail
}

func (s *OpenNASServiceResponseBody) GetOrderId() *string {
	return s.OrderId
}

func (s *OpenNASServiceResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *OpenNASServiceResponseBody) SetAccessDeniedDetail(v string) *OpenNASServiceResponseBody {
	s.AccessDeniedDetail = &v
	return s
}

func (s *OpenNASServiceResponseBody) SetOrderId(v string) *OpenNASServiceResponseBody {
	s.OrderId = &v
	return s
}

func (s *OpenNASServiceResponseBody) SetRequestId(v string) *OpenNASServiceResponseBody {
	s.RequestId = &v
	return s
}

func (s *OpenNASServiceResponseBody) Validate() error {
	return dara.Validate(s)
}

type iOpenNASServiceResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *OpenNASServiceResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *OpenNASServiceResponse
	GetStatusCode() *int32
	SetBody(v *OpenNASServiceResponseBody) *OpenNASServiceResponse
	GetBody() *OpenNASServiceResponseBody
}

type OpenNASServiceResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *OpenNASServiceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s OpenNASServiceResponse) String() string {
	return dara.Prettify(s)
}

func (s OpenNASServiceResponse) GoString() string {
	return s.String()
}

func (s *OpenNASServiceResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *OpenNASServiceResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *OpenNASServiceResponse) GetBody() *OpenNASServiceResponseBody {
	return s.Body
}

func (s *OpenNASServiceResponse) SetHeaders(v map[string]*string) *OpenNASServiceResponse {
	s.Headers = v
	return s
}

func (s *OpenNASServiceResponse) SetStatusCode(v int32) *OpenNASServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *OpenNASServiceResponse) SetBody(v *OpenNASServiceResponseBody) *OpenNASServiceResponse {
	s.Body = v
	return s
}

func (s *OpenNASServiceResponse) Validate() error {
	return dara.Validate(s)
}

type iRemoveClientFromBlackListRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientIP(v string) *RemoveClientFromBlackListRequest
	GetClientIP() *string
	SetClientToken(v string) *RemoveClientFromBlackListRequest
	GetClientToken() *string
	SetFileSystemId(v string) *RemoveClientFromBlackListRequest
	GetFileSystemId() *string
	SetRegionId(v string) *RemoveClientFromBlackListRequest
	GetRegionId() *string
}

type RemoveClientFromBlackListRequest struct {
	// This parameter is required.
	//
	// example:
	//
	// 192.168.0.0
	ClientIP *string `json:"ClientIP,omitempty" xml:"ClientIP,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-42665544****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// This parameter is required.
	//
	// example:
	//
	// cpfs-00d91ca404a348****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The ID of the request.
	//
	// This parameter is required.
	//
	// example:
	//
	// cn-hangzhou
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s RemoveClientFromBlackListRequest) String() string {
	return dara.Prettify(s)
}

func (s RemoveClientFromBlackListRequest) GoString() string {
	return s.String()
}

func (s *RemoveClientFromBlackListRequest) GetClientIP() *string {
	return s.ClientIP
}

func (s *RemoveClientFromBlackListRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *RemoveClientFromBlackListRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *RemoveClientFromBlackListRequest) GetRegionId() *string {
	return s.RegionId
}

func (s *RemoveClientFromBlackListRequest) SetClientIP(v string) *RemoveClientFromBlackListRequest {
	s.ClientIP = &v
	return s
}

func (s *RemoveClientFromBlackListRequest) SetClientToken(v string) *RemoveClientFromBlackListRequest {
	s.ClientToken = &v
	return s
}

func (s *RemoveClientFromBlackListRequest) SetFileSystemId(v string) *RemoveClientFromBlackListRequest {
	s.FileSystemId = &v
	return s
}

func (s *RemoveClientFromBlackListRequest) SetRegionId(v string) *RemoveClientFromBlackListRequest {
	s.RegionId = &v
	return s
}

func (s *RemoveClientFromBlackListRequest) Validate() error {
	return dara.Validate(s)
}

type iRemoveClientFromBlackListResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *RemoveClientFromBlackListResponseBody
	GetRequestId() *string
}

type RemoveClientFromBlackListResponseBody struct {
	// example:
	//
	// A70BEE5D-76D3-49FB-B58F-1F398211****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RemoveClientFromBlackListResponseBody) String() string {
	return dara.Prettify(s)
}

func (s RemoveClientFromBlackListResponseBody) GoString() string {
	return s.String()
}

func (s *RemoveClientFromBlackListResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *RemoveClientFromBlackListResponseBody) SetRequestId(v string) *RemoveClientFromBlackListResponseBody {
	s.RequestId = &v
	return s
}

func (s *RemoveClientFromBlackListResponseBody) Validate() error {
	return dara.Validate(s)
}

type iRemoveClientFromBlackListResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *RemoveClientFromBlackListResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *RemoveClientFromBlackListResponse
	GetStatusCode() *int32
	SetBody(v *RemoveClientFromBlackListResponseBody) *RemoveClientFromBlackListResponse
	GetBody() *RemoveClientFromBlackListResponseBody
}

type RemoveClientFromBlackListResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RemoveClientFromBlackListResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RemoveClientFromBlackListResponse) String() string {
	return dara.Prettify(s)
}

func (s RemoveClientFromBlackListResponse) GoString() string {
	return s.String()
}

func (s *RemoveClientFromBlackListResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *RemoveClientFromBlackListResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *RemoveClientFromBlackListResponse) GetBody() *RemoveClientFromBlackListResponseBody {
	return s.Body
}

func (s *RemoveClientFromBlackListResponse) SetHeaders(v map[string]*string) *RemoveClientFromBlackListResponse {
	s.Headers = v
	return s
}

func (s *RemoveClientFromBlackListResponse) SetStatusCode(v int32) *RemoveClientFromBlackListResponse {
	s.StatusCode = &v
	return s
}

func (s *RemoveClientFromBlackListResponse) SetBody(v *RemoveClientFromBlackListResponseBody) *RemoveClientFromBlackListResponse {
	s.Body = v
	return s
}

func (s *RemoveClientFromBlackListResponse) Validate() error {
	return dara.Validate(s)
}

type iResetFileSystemRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *ResetFileSystemRequest
	GetFileSystemId() *string
	SetSnapshotId(v string) *ResetFileSystemRequest
	GetSnapshotId() *string
}

type ResetFileSystemRequest struct {
	// The ID of the advanced Extreme NAS file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// extreme-012dd****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The snapshot ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// s-extreme-snapsho****
	SnapshotId *string `json:"SnapshotId,omitempty" xml:"SnapshotId,omitempty"`
}

func (s ResetFileSystemRequest) String() string {
	return dara.Prettify(s)
}

func (s ResetFileSystemRequest) GoString() string {
	return s.String()
}

func (s *ResetFileSystemRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *ResetFileSystemRequest) GetSnapshotId() *string {
	return s.SnapshotId
}

func (s *ResetFileSystemRequest) SetFileSystemId(v string) *ResetFileSystemRequest {
	s.FileSystemId = &v
	return s
}

func (s *ResetFileSystemRequest) SetSnapshotId(v string) *ResetFileSystemRequest {
	s.SnapshotId = &v
	return s
}

func (s *ResetFileSystemRequest) Validate() error {
	return dara.Validate(s)
}

type iResetFileSystemResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *ResetFileSystemResponseBody
	GetRequestId() *string
}

type ResetFileSystemResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 473469C7-AA6F-4DC5-B3DB-A3DC0DE3****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ResetFileSystemResponseBody) String() string {
	return dara.Prettify(s)
}

func (s ResetFileSystemResponseBody) GoString() string {
	return s.String()
}

func (s *ResetFileSystemResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *ResetFileSystemResponseBody) SetRequestId(v string) *ResetFileSystemResponseBody {
	s.RequestId = &v
	return s
}

func (s *ResetFileSystemResponseBody) Validate() error {
	return dara.Validate(s)
}

type iResetFileSystemResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *ResetFileSystemResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *ResetFileSystemResponse
	GetStatusCode() *int32
	SetBody(v *ResetFileSystemResponseBody) *ResetFileSystemResponse
	GetBody() *ResetFileSystemResponseBody
}

type ResetFileSystemResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ResetFileSystemResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ResetFileSystemResponse) String() string {
	return dara.Prettify(s)
}

func (s ResetFileSystemResponse) GoString() string {
	return s.String()
}

func (s *ResetFileSystemResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *ResetFileSystemResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *ResetFileSystemResponse) GetBody() *ResetFileSystemResponseBody {
	return s.Body
}

func (s *ResetFileSystemResponse) SetHeaders(v map[string]*string) *ResetFileSystemResponse {
	s.Headers = v
	return s
}

func (s *ResetFileSystemResponse) SetStatusCode(v int32) *ResetFileSystemResponse {
	s.StatusCode = &v
	return s
}

func (s *ResetFileSystemResponse) SetBody(v *ResetFileSystemResponseBody) *ResetFileSystemResponse {
	s.Body = v
	return s
}

func (s *ResetFileSystemResponse) Validate() error {
	return dara.Validate(s)
}

type iRetryLifecycleRetrieveJobRequest interface {
	dara.Model
	String() string
	GoString() string
	SetJobId(v string) *RetryLifecycleRetrieveJobRequest
	GetJobId() *string
}

type RetryLifecycleRetrieveJobRequest struct {
	// The ID of the data retrieval task.
	//
	// This parameter is required.
	//
	// example:
	//
	// lrj-nfstest-ia-160****853-hshvw
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
}

func (s RetryLifecycleRetrieveJobRequest) String() string {
	return dara.Prettify(s)
}

func (s RetryLifecycleRetrieveJobRequest) GoString() string {
	return s.String()
}

func (s *RetryLifecycleRetrieveJobRequest) GetJobId() *string {
	return s.JobId
}

func (s *RetryLifecycleRetrieveJobRequest) SetJobId(v string) *RetryLifecycleRetrieveJobRequest {
	s.JobId = &v
	return s
}

func (s *RetryLifecycleRetrieveJobRequest) Validate() error {
	return dara.Validate(s)
}

type iRetryLifecycleRetrieveJobResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *RetryLifecycleRetrieveJobResponseBody
	GetRequestId() *string
}

type RetryLifecycleRetrieveJobResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// BC7C825C-5F65-4B56-BEF6-98C56C7C****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RetryLifecycleRetrieveJobResponseBody) String() string {
	return dara.Prettify(s)
}

func (s RetryLifecycleRetrieveJobResponseBody) GoString() string {
	return s.String()
}

func (s *RetryLifecycleRetrieveJobResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *RetryLifecycleRetrieveJobResponseBody) SetRequestId(v string) *RetryLifecycleRetrieveJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *RetryLifecycleRetrieveJobResponseBody) Validate() error {
	return dara.Validate(s)
}

type iRetryLifecycleRetrieveJobResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *RetryLifecycleRetrieveJobResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *RetryLifecycleRetrieveJobResponse
	GetStatusCode() *int32
	SetBody(v *RetryLifecycleRetrieveJobResponseBody) *RetryLifecycleRetrieveJobResponse
	GetBody() *RetryLifecycleRetrieveJobResponseBody
}

type RetryLifecycleRetrieveJobResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RetryLifecycleRetrieveJobResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RetryLifecycleRetrieveJobResponse) String() string {
	return dara.Prettify(s)
}

func (s RetryLifecycleRetrieveJobResponse) GoString() string {
	return s.String()
}

func (s *RetryLifecycleRetrieveJobResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *RetryLifecycleRetrieveJobResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *RetryLifecycleRetrieveJobResponse) GetBody() *RetryLifecycleRetrieveJobResponseBody {
	return s.Body
}

func (s *RetryLifecycleRetrieveJobResponse) SetHeaders(v map[string]*string) *RetryLifecycleRetrieveJobResponse {
	s.Headers = v
	return s
}

func (s *RetryLifecycleRetrieveJobResponse) SetStatusCode(v int32) *RetryLifecycleRetrieveJobResponse {
	s.StatusCode = &v
	return s
}

func (s *RetryLifecycleRetrieveJobResponse) SetBody(v *RetryLifecycleRetrieveJobResponseBody) *RetryLifecycleRetrieveJobResponse {
	s.Body = v
	return s
}

func (s *RetryLifecycleRetrieveJobResponse) Validate() error {
	return dara.Validate(s)
}

type iSetDirQuotaRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileCountLimit(v int64) *SetDirQuotaRequest
	GetFileCountLimit() *int64
	SetFileSystemId(v string) *SetDirQuotaRequest
	GetFileSystemId() *string
	SetPath(v string) *SetDirQuotaRequest
	GetPath() *string
	SetQuotaType(v string) *SetDirQuotaRequest
	GetQuotaType() *string
	SetSizeLimit(v int64) *SetDirQuotaRequest
	GetSizeLimit() *int64
	SetUserId(v string) *SetDirQuotaRequest
	GetUserId() *string
	SetUserType(v string) *SetDirQuotaRequest
	GetUserType() *string
}

type SetDirQuotaRequest struct {
	// The number of files that a user can create in the directory.
	//
	// This number includes the number of files, subdirectories, and special files.
	//
	// If you set the QuotaType parameter to Enforcement, you must specify at least one of the SizeLimit and FileCountLimit parameters.
	//
	// example:
	//
	// 10000
	FileCountLimit *int64 `json:"FileCountLimit,omitempty" xml:"FileCountLimit,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1ca404****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The absolute path of the directory in the file system.
	//
	// > 	- You can set quotas only for the directories that have been created in a NAS file system. The path of the directory that you specify for a quota is the absolute path of the directory in the NAS file system, but not the local path of the compute node, such as an Elastic Compute Service (ECS) instance or a container.
	//
	// > 	- Directories whose names contain Chinese characters are not supported.
	//
	// This parameter is required.
	//
	// example:
	//
	// /data/sub1
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The type of the quota.
	//
	// Valid values:
	//
	// 	- Accounting: a statistical quota. If you set this parameter to Accounting, NAS calculates only the storage usage of the directory.
	//
	// 	- Enforcement: a restricted quota. If you set this parameter to Enforcement and the storage usage exceeds the quota, you can no longer create files or subdirectories for the directory, or write data to the directory.
	//
	// This parameter is required.
	//
	// example:
	//
	// Accounting
	QuotaType *string `json:"QuotaType,omitempty" xml:"QuotaType,omitempty"`
	// The size of files that a user can create in the directory.
	//
	// Unit: GiB.
	//
	// If you set the QuotaType parameter to Enforcement, you must specify at least one of the SizeLimit and FileCountLimit parameters.
	//
	// example:
	//
	// 1024
	SizeLimit *int64 `json:"SizeLimit,omitempty" xml:"SizeLimit,omitempty"`
	// The UID or GID of the user for whom you want to set a directory quota.
	//
	// This parameter is required and valid only if the UserType parameter is set to Uid or Gid.
	//
	// Examples:
	//
	// 	- If you want to set a directory quota for a user whose UID is 500, set the UserType parameter to Uid and set the UserId parameter to 500.
	//
	// 	- If you want to set a directory quota for a user group whose GID is 100, set the UserType parameter to Gid and set the UserId parameter to 100.
	//
	// example:
	//
	// 500
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The type of the user.
	//
	// Valid values:
	//
	// 	- Uid: user ID
	//
	// 	- Gid: user group ID
	//
	// 	- AllUsers: all users
	//
	// This parameter is required.
	//
	// example:
	//
	// Uid
	UserType *string `json:"UserType,omitempty" xml:"UserType,omitempty"`
}

func (s SetDirQuotaRequest) String() string {
	return dara.Prettify(s)
}

func (s SetDirQuotaRequest) GoString() string {
	return s.String()
}

func (s *SetDirQuotaRequest) GetFileCountLimit() *int64 {
	return s.FileCountLimit
}

func (s *SetDirQuotaRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *SetDirQuotaRequest) GetPath() *string {
	return s.Path
}

func (s *SetDirQuotaRequest) GetQuotaType() *string {
	return s.QuotaType
}

func (s *SetDirQuotaRequest) GetSizeLimit() *int64 {
	return s.SizeLimit
}

func (s *SetDirQuotaRequest) GetUserId() *string {
	return s.UserId
}

func (s *SetDirQuotaRequest) GetUserType() *string {
	return s.UserType
}

func (s *SetDirQuotaRequest) SetFileCountLimit(v int64) *SetDirQuotaRequest {
	s.FileCountLimit = &v
	return s
}

func (s *SetDirQuotaRequest) SetFileSystemId(v string) *SetDirQuotaRequest {
	s.FileSystemId = &v
	return s
}

func (s *SetDirQuotaRequest) SetPath(v string) *SetDirQuotaRequest {
	s.Path = &v
	return s
}

func (s *SetDirQuotaRequest) SetQuotaType(v string) *SetDirQuotaRequest {
	s.QuotaType = &v
	return s
}

func (s *SetDirQuotaRequest) SetSizeLimit(v int64) *SetDirQuotaRequest {
	s.SizeLimit = &v
	return s
}

func (s *SetDirQuotaRequest) SetUserId(v string) *SetDirQuotaRequest {
	s.UserId = &v
	return s
}

func (s *SetDirQuotaRequest) SetUserType(v string) *SetDirQuotaRequest {
	s.UserType = &v
	return s
}

func (s *SetDirQuotaRequest) Validate() error {
	return dara.Validate(s)
}

type iSetDirQuotaResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *SetDirQuotaResponseBody
	GetRequestId() *string
	SetSuccess(v bool) *SetDirQuotaResponseBody
	GetSuccess() *bool
}

type SetDirQuotaResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 5BC5CB97-9F28-42FE-84A4-0CD0DF42****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	//
	// Valid values:
	//
	// 	- true
	//
	// 	- false
	//
	// example:
	//
	// true
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SetDirQuotaResponseBody) String() string {
	return dara.Prettify(s)
}

func (s SetDirQuotaResponseBody) GoString() string {
	return s.String()
}

func (s *SetDirQuotaResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *SetDirQuotaResponseBody) GetSuccess() *bool {
	return s.Success
}

func (s *SetDirQuotaResponseBody) SetRequestId(v string) *SetDirQuotaResponseBody {
	s.RequestId = &v
	return s
}

func (s *SetDirQuotaResponseBody) SetSuccess(v bool) *SetDirQuotaResponseBody {
	s.Success = &v
	return s
}

func (s *SetDirQuotaResponseBody) Validate() error {
	return dara.Validate(s)
}

type iSetDirQuotaResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *SetDirQuotaResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *SetDirQuotaResponse
	GetStatusCode() *int32
	SetBody(v *SetDirQuotaResponseBody) *SetDirQuotaResponse
	GetBody() *SetDirQuotaResponseBody
}

type SetDirQuotaResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SetDirQuotaResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SetDirQuotaResponse) String() string {
	return dara.Prettify(s)
}

func (s SetDirQuotaResponse) GoString() string {
	return s.String()
}

func (s *SetDirQuotaResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *SetDirQuotaResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *SetDirQuotaResponse) GetBody() *SetDirQuotaResponseBody {
	return s.Body
}

func (s *SetDirQuotaResponse) SetHeaders(v map[string]*string) *SetDirQuotaResponse {
	s.Headers = v
	return s
}

func (s *SetDirQuotaResponse) SetStatusCode(v int32) *SetDirQuotaResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDirQuotaResponse) SetBody(v *SetDirQuotaResponseBody) *SetDirQuotaResponse {
	s.Body = v
	return s
}

func (s *SetDirQuotaResponse) Validate() error {
	return dara.Validate(s)
}

type iSetFilesetQuotaRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientToken(v string) *SetFilesetQuotaRequest
	GetClientToken() *string
	SetDryRun(v bool) *SetFilesetQuotaRequest
	GetDryRun() *bool
	SetFileCountLimit(v int64) *SetFilesetQuotaRequest
	GetFileCountLimit() *int64
	SetFileSystemId(v string) *SetFilesetQuotaRequest
	GetFileSystemId() *string
	SetFsetId(v string) *SetFilesetQuotaRequest
	GetFsetId() *string
	SetSizeLimit(v int64) *SetFilesetQuotaRequest
	GetSizeLimit() *int64
}

type SetFilesetQuotaRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// >  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-42665544****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. The dry run checks parameter validity and prerequisites. The dry run does not delete the specified quota or incur fees.
	//
	// Valid values:
	//
	// 	- true: performs only a dry run. The system checks the required parameters, request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned.
	//
	// 	- false (default): performs a dry run and sends the request. If the request passes the dry run, the quota is deleted.
	//
	// example:
	//
	// false
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The limit of the file quantity of the quota. Valid values:
	//
	// 	- Minimum value: 10000.
	//
	// 	- Maximum value: 10000000000.
	//
	// example:
	//
	// 10000
	FileCountLimit *int64 `json:"FileCountLimit,omitempty" xml:"FileCountLimit,omitempty"`
	// The ID of the CPFS for LINGJUN file system. The IDs of CPFS for LINGJUN file systems must start with `bmcpfs-`. Example: bmcpfs-290w65p03ok64ya\\*\\*\\*\\*.
	//
	// This parameter is required.
	//
	// example:
	//
	// bmcpfs-290w65p03ok64ya****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The fileset ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// fset-1902718ea0ae****
	FsetId *string `json:"FsetId,omitempty" xml:"FsetId,omitempty"`
	// The limit of the total capacity of the quota. Unit: bytes.
	//
	// Valid values:
	//
	// 	- Minimum value: 10737418240 (10 GiB).
	//
	// 	- Maximum value: 1073741824000 (1024000 GiB).
	//
	// 	- Step size: 1073741824 (1 GiB).
	//
	// example:
	//
	// 10737418240
	SizeLimit *int64 `json:"SizeLimit,omitempty" xml:"SizeLimit,omitempty"`
}

func (s SetFilesetQuotaRequest) String() string {
	return dara.Prettify(s)
}

func (s SetFilesetQuotaRequest) GoString() string {
	return s.String()
}

func (s *SetFilesetQuotaRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *SetFilesetQuotaRequest) GetDryRun() *bool {
	return s.DryRun
}

func (s *SetFilesetQuotaRequest) GetFileCountLimit() *int64 {
	return s.FileCountLimit
}

func (s *SetFilesetQuotaRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *SetFilesetQuotaRequest) GetFsetId() *string {
	return s.FsetId
}

func (s *SetFilesetQuotaRequest) GetSizeLimit() *int64 {
	return s.SizeLimit
}

func (s *SetFilesetQuotaRequest) SetClientToken(v string) *SetFilesetQuotaRequest {
	s.ClientToken = &v
	return s
}

func (s *SetFilesetQuotaRequest) SetDryRun(v bool) *SetFilesetQuotaRequest {
	s.DryRun = &v
	return s
}

func (s *SetFilesetQuotaRequest) SetFileCountLimit(v int64) *SetFilesetQuotaRequest {
	s.FileCountLimit = &v
	return s
}

func (s *SetFilesetQuotaRequest) SetFileSystemId(v string) *SetFilesetQuotaRequest {
	s.FileSystemId = &v
	return s
}

func (s *SetFilesetQuotaRequest) SetFsetId(v string) *SetFilesetQuotaRequest {
	s.FsetId = &v
	return s
}

func (s *SetFilesetQuotaRequest) SetSizeLimit(v int64) *SetFilesetQuotaRequest {
	s.SizeLimit = &v
	return s
}

func (s *SetFilesetQuotaRequest) Validate() error {
	return dara.Validate(s)
}

type iSetFilesetQuotaResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *SetFilesetQuotaResponseBody
	GetRequestId() *string
}

type SetFilesetQuotaResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 2D69A58F-345C-4FDE-88E4-BF518948****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetFilesetQuotaResponseBody) String() string {
	return dara.Prettify(s)
}

func (s SetFilesetQuotaResponseBody) GoString() string {
	return s.String()
}

func (s *SetFilesetQuotaResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *SetFilesetQuotaResponseBody) SetRequestId(v string) *SetFilesetQuotaResponseBody {
	s.RequestId = &v
	return s
}

func (s *SetFilesetQuotaResponseBody) Validate() error {
	return dara.Validate(s)
}

type iSetFilesetQuotaResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *SetFilesetQuotaResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *SetFilesetQuotaResponse
	GetStatusCode() *int32
	SetBody(v *SetFilesetQuotaResponseBody) *SetFilesetQuotaResponse
	GetBody() *SetFilesetQuotaResponseBody
}

type SetFilesetQuotaResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SetFilesetQuotaResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SetFilesetQuotaResponse) String() string {
	return dara.Prettify(s)
}

func (s SetFilesetQuotaResponse) GoString() string {
	return s.String()
}

func (s *SetFilesetQuotaResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *SetFilesetQuotaResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *SetFilesetQuotaResponse) GetBody() *SetFilesetQuotaResponseBody {
	return s.Body
}

func (s *SetFilesetQuotaResponse) SetHeaders(v map[string]*string) *SetFilesetQuotaResponse {
	s.Headers = v
	return s
}

func (s *SetFilesetQuotaResponse) SetStatusCode(v int32) *SetFilesetQuotaResponse {
	s.StatusCode = &v
	return s
}

func (s *SetFilesetQuotaResponse) SetBody(v *SetFilesetQuotaResponseBody) *SetFilesetQuotaResponse {
	s.Body = v
	return s
}

func (s *SetFilesetQuotaResponse) Validate() error {
	return dara.Validate(s)
}

type iStartDataFlowRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientToken(v string) *StartDataFlowRequest
	GetClientToken() *string
	SetDataFlowId(v string) *StartDataFlowRequest
	GetDataFlowId() *string
	SetDryRun(v bool) *StartDataFlowRequest
	GetDryRun() *bool
	SetFileSystemId(v string) *StartDataFlowRequest
	GetFileSystemId() *string
}

type StartDataFlowRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// >  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-42665544****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The dataflow ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// df-194433a5be31****
	DataFlowId *string `json:"DataFlowId,omitempty" xml:"DataFlowId,omitempty"`
	// Specifies whether to perform only a dry run, without performing the actual request.
	//
	// During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. The dry run does not enable the specified dataflow or incur fees.
	//
	// Valid values:
	//
	// 	- true: performs only a dry run. The system checks the required parameters, request syntax, service limits, and available NAS resources. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned.
	//
	// 	- false (default): performs a dry run and sends the request. If the request passes the dry run, the specified dataflow is enabled.
	//
	// example:
	//
	// false
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// cpfs-099394bd928c****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
}

func (s StartDataFlowRequest) String() string {
	return dara.Prettify(s)
}

func (s StartDataFlowRequest) GoString() string {
	return s.String()
}

func (s *StartDataFlowRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *StartDataFlowRequest) GetDataFlowId() *string {
	return s.DataFlowId
}

func (s *StartDataFlowRequest) GetDryRun() *bool {
	return s.DryRun
}

func (s *StartDataFlowRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *StartDataFlowRequest) SetClientToken(v string) *StartDataFlowRequest {
	s.ClientToken = &v
	return s
}

func (s *StartDataFlowRequest) SetDataFlowId(v string) *StartDataFlowRequest {
	s.DataFlowId = &v
	return s
}

func (s *StartDataFlowRequest) SetDryRun(v bool) *StartDataFlowRequest {
	s.DryRun = &v
	return s
}

func (s *StartDataFlowRequest) SetFileSystemId(v string) *StartDataFlowRequest {
	s.FileSystemId = &v
	return s
}

func (s *StartDataFlowRequest) Validate() error {
	return dara.Validate(s)
}

type iStartDataFlowResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *StartDataFlowResponseBody
	GetRequestId() *string
}

type StartDataFlowResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 98696EF0-1607-4E9D-B01D-F20930B6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StartDataFlowResponseBody) String() string {
	return dara.Prettify(s)
}

func (s StartDataFlowResponseBody) GoString() string {
	return s.String()
}

func (s *StartDataFlowResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *StartDataFlowResponseBody) SetRequestId(v string) *StartDataFlowResponseBody {
	s.RequestId = &v
	return s
}

func (s *StartDataFlowResponseBody) Validate() error {
	return dara.Validate(s)
}

type iStartDataFlowResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *StartDataFlowResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *StartDataFlowResponse
	GetStatusCode() *int32
	SetBody(v *StartDataFlowResponseBody) *StartDataFlowResponse
	GetBody() *StartDataFlowResponseBody
}

type StartDataFlowResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *StartDataFlowResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s StartDataFlowResponse) String() string {
	return dara.Prettify(s)
}

func (s StartDataFlowResponse) GoString() string {
	return s.String()
}

func (s *StartDataFlowResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *StartDataFlowResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *StartDataFlowResponse) GetBody() *StartDataFlowResponseBody {
	return s.Body
}

func (s *StartDataFlowResponse) SetHeaders(v map[string]*string) *StartDataFlowResponse {
	s.Headers = v
	return s
}

func (s *StartDataFlowResponse) SetStatusCode(v int32) *StartDataFlowResponse {
	s.StatusCode = &v
	return s
}

func (s *StartDataFlowResponse) SetBody(v *StartDataFlowResponseBody) *StartDataFlowResponse {
	s.Body = v
	return s
}

func (s *StartDataFlowResponse) Validate() error {
	return dara.Validate(s)
}

type iStopDataFlowRequest interface {
	dara.Model
	String() string
	GoString() string
	SetClientToken(v string) *StopDataFlowRequest
	GetClientToken() *string
	SetDataFlowId(v string) *StopDataFlowRequest
	GetDataFlowId() *string
	SetDryRun(v bool) *StopDataFlowRequest
	GetDryRun() *bool
	SetFileSystemId(v string) *StopDataFlowRequest
	GetFileSystemId() *string
}

type StopDataFlowRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// >  If you do not specify this parameter, the system automatically uses the request ID as the client token. The value of RequestId may be different for each API request.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-42665544****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The dataflow ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// df-194433a5be31****
	DataFlowId *string `json:"DataFlowId,omitempty" xml:"DataFlowId,omitempty"`
	// Specifies whether to perform a dry run.
	//
	// During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no file system is created and no fee is incurred.
	//
	// Valid values:
	//
	// 	- true: performs a dry run. The system checks the required parameters, request syntax, limits, and available NAS resources. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the FileSystemId parameter.
	//
	// 	- false (default): performs a dry run and sends the request. If the request passes the dry run, a file system is created.
	//
	// example:
	//
	// false
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// cpfs-099394bd928c****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
}

func (s StopDataFlowRequest) String() string {
	return dara.Prettify(s)
}

func (s StopDataFlowRequest) GoString() string {
	return s.String()
}

func (s *StopDataFlowRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *StopDataFlowRequest) GetDataFlowId() *string {
	return s.DataFlowId
}

func (s *StopDataFlowRequest) GetDryRun() *bool {
	return s.DryRun
}

func (s *StopDataFlowRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *StopDataFlowRequest) SetClientToken(v string) *StopDataFlowRequest {
	s.ClientToken = &v
	return s
}

func (s *StopDataFlowRequest) SetDataFlowId(v string) *StopDataFlowRequest {
	s.DataFlowId = &v
	return s
}

func (s *StopDataFlowRequest) SetDryRun(v bool) *StopDataFlowRequest {
	s.DryRun = &v
	return s
}

func (s *StopDataFlowRequest) SetFileSystemId(v string) *StopDataFlowRequest {
	s.FileSystemId = &v
	return s
}

func (s *StopDataFlowRequest) Validate() error {
	return dara.Validate(s)
}

type iStopDataFlowResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *StopDataFlowResponseBody
	GetRequestId() *string
}

type StopDataFlowResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 98696EF0-1607-4E9D-B01D-F20930B6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StopDataFlowResponseBody) String() string {
	return dara.Prettify(s)
}

func (s StopDataFlowResponseBody) GoString() string {
	return s.String()
}

func (s *StopDataFlowResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *StopDataFlowResponseBody) SetRequestId(v string) *StopDataFlowResponseBody {
	s.RequestId = &v
	return s
}

func (s *StopDataFlowResponseBody) Validate() error {
	return dara.Validate(s)
}

type iStopDataFlowResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *StopDataFlowResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *StopDataFlowResponse
	GetStatusCode() *int32
	SetBody(v *StopDataFlowResponseBody) *StopDataFlowResponse
	GetBody() *StopDataFlowResponseBody
}

type StopDataFlowResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *StopDataFlowResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s StopDataFlowResponse) String() string {
	return dara.Prettify(s)
}

func (s StopDataFlowResponse) GoString() string {
	return s.String()
}

func (s *StopDataFlowResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *StopDataFlowResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *StopDataFlowResponse) GetBody() *StopDataFlowResponseBody {
	return s.Body
}

func (s *StopDataFlowResponse) SetHeaders(v map[string]*string) *StopDataFlowResponse {
	s.Headers = v
	return s
}

func (s *StopDataFlowResponse) SetStatusCode(v int32) *StopDataFlowResponse {
	s.StatusCode = &v
	return s
}

func (s *StopDataFlowResponse) SetBody(v *StopDataFlowResponseBody) *StopDataFlowResponse {
	s.Body = v
	return s
}

func (s *StopDataFlowResponse) Validate() error {
	return dara.Validate(s)
}

type iTagResourcesRequest interface {
	dara.Model
	String() string
	GoString() string
	SetResourceId(v []*string) *TagResourcesRequest
	GetResourceId() []*string
	SetResourceType(v string) *TagResourcesRequest
	GetResourceType() *string
	SetTag(v []*TagResourcesRequestTag) *TagResourcesRequest
	GetTag() []*TagResourcesRequestTag
}

type TagResourcesRequest struct {
	// The resource IDs. Valid values of N: 1 to 50.
	//
	// This parameter is required.
	//
	// example:
	//
	// 03e08484f0
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The resource type. Set the value to filesystem.
	//
	// This parameter is required.
	//
	// example:
	//
	// filesystem
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The details about the tags.
	//
	// This parameter is required.
	Tag []*TagResourcesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s TagResourcesRequest) String() string {
	return dara.Prettify(s)
}

func (s TagResourcesRequest) GoString() string {
	return s.String()
}

func (s *TagResourcesRequest) GetResourceId() []*string {
	return s.ResourceId
}

func (s *TagResourcesRequest) GetResourceType() *string {
	return s.ResourceType
}

func (s *TagResourcesRequest) GetTag() []*TagResourcesRequestTag {
	return s.Tag
}

func (s *TagResourcesRequest) SetResourceId(v []*string) *TagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *TagResourcesRequest) SetResourceType(v string) *TagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *TagResourcesRequest) SetTag(v []*TagResourcesRequestTag) *TagResourcesRequest {
	s.Tag = v
	return s
}

func (s *TagResourcesRequest) Validate() error {
	return dara.Validate(s)
}

type TagResourcesRequestTag struct {
	// The key of tag N to add to the resource.
	//
	// Limits:
	//
	// 	- The tag key cannot be left empty.
	//
	// 	- Valid values of N: 1 to 20.
	//
	// 	- The tag key must be 1 to 128 characters in length.
	//
	// 	- The tag key cannot start with `aliyun` or `acs:`.
	//
	// 	- The tag key cannot contain `http://` or `https://`.
	//
	// This parameter is required.
	//
	// example:
	//
	// nastest
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of tag N to add to the resource.
	//
	// Limits:
	//
	// 	- Valid values of N: 1 to 20.
	//
	// 	- The tag value must be 1 to 128 characters in length.
	//
	// 	- The tag value cannot start with `aliyun` or `acs:`.
	//
	// 	- The tag value cannot contain `http://` or `https://`.
	//
	// This parameter is required.
	//
	// example:
	//
	// filetest
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s TagResourcesRequestTag) String() string {
	return dara.Prettify(s)
}

func (s TagResourcesRequestTag) GoString() string {
	return s.String()
}

func (s *TagResourcesRequestTag) GetKey() *string {
	return s.Key
}

func (s *TagResourcesRequestTag) GetValue() *string {
	return s.Value
}

func (s *TagResourcesRequestTag) SetKey(v string) *TagResourcesRequestTag {
	s.Key = &v
	return s
}

func (s *TagResourcesRequestTag) SetValue(v string) *TagResourcesRequestTag {
	s.Value = &v
	return s
}

func (s *TagResourcesRequestTag) Validate() error {
	return dara.Validate(s)
}

type iTagResourcesResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *TagResourcesResponseBody
	GetRequestId() *string
}

type TagResourcesResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 2D69A58F-345C-4FDE-88E4-BF518948****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s TagResourcesResponseBody) String() string {
	return dara.Prettify(s)
}

func (s TagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *TagResourcesResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *TagResourcesResponseBody) SetRequestId(v string) *TagResourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *TagResourcesResponseBody) Validate() error {
	return dara.Validate(s)
}

type iTagResourcesResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *TagResourcesResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *TagResourcesResponse
	GetStatusCode() *int32
	SetBody(v *TagResourcesResponseBody) *TagResourcesResponse
	GetBody() *TagResourcesResponseBody
}

type TagResourcesResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *TagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s TagResourcesResponse) String() string {
	return dara.Prettify(s)
}

func (s TagResourcesResponse) GoString() string {
	return s.String()
}

func (s *TagResourcesResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *TagResourcesResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *TagResourcesResponse) GetBody() *TagResourcesResponseBody {
	return s.Body
}

func (s *TagResourcesResponse) SetHeaders(v map[string]*string) *TagResourcesResponse {
	s.Headers = v
	return s
}

func (s *TagResourcesResponse) SetStatusCode(v int32) *TagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *TagResourcesResponse) SetBody(v *TagResourcesResponseBody) *TagResourcesResponse {
	s.Body = v
	return s
}

func (s *TagResourcesResponse) Validate() error {
	return dara.Validate(s)
}

type iUntagResourcesRequest interface {
	dara.Model
	String() string
	GoString() string
	SetAll(v bool) *UntagResourcesRequest
	GetAll() *bool
	SetResourceId(v []*string) *UntagResourcesRequest
	GetResourceId() []*string
	SetResourceType(v string) *UntagResourcesRequest
	GetResourceType() *string
	SetTagKey(v []*string) *UntagResourcesRequest
	GetTagKey() []*string
}

type UntagResourcesRequest struct {
	// Specifies whether to remove all tags from the file system.
	//
	// This parameter is valid only if the TagKey.N parameter is not specified.
	//
	// Valid values:
	//
	// 	- true: All tags are removed from the file system. If the file system does not have tags, a success message is returned.
	//
	// 	- false (default): No tags are removed from the file system and a success message is returned.
	//
	// example:
	//
	// false
	All *bool `json:"All,omitempty" xml:"All,omitempty"`
	// The resource IDs. Valid values of N: 1 to 50.
	//
	// This parameter is required.
	//
	// example:
	//
	// 03e08484f0
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The resource type.
	//
	// Set the value to filesystem.
	//
	// This parameter is required.
	//
	// example:
	//
	// filesystem
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tag keys of the resources. Valid values of N: 1 to 20.
	//
	// example:
	//
	// nastest
	TagKey []*string `json:"TagKey,omitempty" xml:"TagKey,omitempty" type:"Repeated"`
}

func (s UntagResourcesRequest) String() string {
	return dara.Prettify(s)
}

func (s UntagResourcesRequest) GoString() string {
	return s.String()
}

func (s *UntagResourcesRequest) GetAll() *bool {
	return s.All
}

func (s *UntagResourcesRequest) GetResourceId() []*string {
	return s.ResourceId
}

func (s *UntagResourcesRequest) GetResourceType() *string {
	return s.ResourceType
}

func (s *UntagResourcesRequest) GetTagKey() []*string {
	return s.TagKey
}

func (s *UntagResourcesRequest) SetAll(v bool) *UntagResourcesRequest {
	s.All = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceId(v []*string) *UntagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *UntagResourcesRequest) SetResourceType(v string) *UntagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *UntagResourcesRequest) SetTagKey(v []*string) *UntagResourcesRequest {
	s.TagKey = v
	return s
}

func (s *UntagResourcesRequest) Validate() error {
	return dara.Validate(s)
}

type iUntagResourcesResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *UntagResourcesResponseBody
	GetRequestId() *string
}

type UntagResourcesResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 2D69A58F-345C-4FDE-88E4-BF518948****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UntagResourcesResponseBody) String() string {
	return dara.Prettify(s)
}

func (s UntagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *UntagResourcesResponseBody) SetRequestId(v string) *UntagResourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *UntagResourcesResponseBody) Validate() error {
	return dara.Validate(s)
}

type iUntagResourcesResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *UntagResourcesResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *UntagResourcesResponse
	GetStatusCode() *int32
	SetBody(v *UntagResourcesResponseBody) *UntagResourcesResponse
	GetBody() *UntagResourcesResponseBody
}

type UntagResourcesResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UntagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UntagResourcesResponse) String() string {
	return dara.Prettify(s)
}

func (s UntagResourcesResponse) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *UntagResourcesResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *UntagResourcesResponse) GetBody() *UntagResourcesResponseBody {
	return s.Body
}

func (s *UntagResourcesResponse) SetHeaders(v map[string]*string) *UntagResourcesResponse {
	s.Headers = v
	return s
}

func (s *UntagResourcesResponse) SetStatusCode(v int32) *UntagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *UntagResourcesResponse) SetBody(v *UntagResourcesResponseBody) *UntagResourcesResponse {
	s.Body = v
	return s
}

func (s *UntagResourcesResponse) Validate() error {
	return dara.Validate(s)
}

type iUpdateRecycleBinAttributeRequest interface {
	dara.Model
	String() string
	GoString() string
	SetFileSystemId(v string) *UpdateRecycleBinAttributeRequest
	GetFileSystemId() *string
	SetReservedDays(v int64) *UpdateRecycleBinAttributeRequest
	GetReservedDays() *int64
}

type UpdateRecycleBinAttributeRequest struct {
	// The ID of the file system.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1ca404****
	FileSystemId *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	// The retention period of the files in the recycle bin. Unit: days.
	//
	// Valid values: 1 to 180.
	//
	// Default value: 3.
	//
	// This parameter is required.
	//
	// example:
	//
	// 3
	ReservedDays *int64 `json:"ReservedDays,omitempty" xml:"ReservedDays,omitempty"`
}

func (s UpdateRecycleBinAttributeRequest) String() string {
	return dara.Prettify(s)
}

func (s UpdateRecycleBinAttributeRequest) GoString() string {
	return s.String()
}

func (s *UpdateRecycleBinAttributeRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *UpdateRecycleBinAttributeRequest) GetReservedDays() *int64 {
	return s.ReservedDays
}

func (s *UpdateRecycleBinAttributeRequest) SetFileSystemId(v string) *UpdateRecycleBinAttributeRequest {
	s.FileSystemId = &v
	return s
}

func (s *UpdateRecycleBinAttributeRequest) SetReservedDays(v int64) *UpdateRecycleBinAttributeRequest {
	s.ReservedDays = &v
	return s
}

func (s *UpdateRecycleBinAttributeRequest) Validate() error {
	return dara.Validate(s)
}

type iUpdateRecycleBinAttributeResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *UpdateRecycleBinAttributeResponseBody
	GetRequestId() *string
}

type UpdateRecycleBinAttributeResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// BC7C825C-5F65-4B56-BEF6-98C5****546E
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateRecycleBinAttributeResponseBody) String() string {
	return dara.Prettify(s)
}

func (s UpdateRecycleBinAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateRecycleBinAttributeResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *UpdateRecycleBinAttributeResponseBody) SetRequestId(v string) *UpdateRecycleBinAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateRecycleBinAttributeResponseBody) Validate() error {
	return dara.Validate(s)
}

type iUpdateRecycleBinAttributeResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *UpdateRecycleBinAttributeResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *UpdateRecycleBinAttributeResponse
	GetStatusCode() *int32
	SetBody(v *UpdateRecycleBinAttributeResponseBody) *UpdateRecycleBinAttributeResponse
	GetBody() *UpdateRecycleBinAttributeResponseBody
}

type UpdateRecycleBinAttributeResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateRecycleBinAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateRecycleBinAttributeResponse) String() string {
	return dara.Prettify(s)
}

func (s UpdateRecycleBinAttributeResponse) GoString() string {
	return s.String()
}

func (s *UpdateRecycleBinAttributeResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *UpdateRecycleBinAttributeResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *UpdateRecycleBinAttributeResponse) GetBody() *UpdateRecycleBinAttributeResponseBody {
	return s.Body
}

func (s *UpdateRecycleBinAttributeResponse) SetHeaders(v map[string]*string) *UpdateRecycleBinAttributeResponse {
	s.Headers = v
	return s
}

func (s *UpdateRecycleBinAttributeResponse) SetStatusCode(v int32) *UpdateRecycleBinAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateRecycleBinAttributeResponse) SetBody(v *UpdateRecycleBinAttributeResponseBody) *UpdateRecycleBinAttributeResponse {
	s.Body = v
	return s
}

func (s *UpdateRecycleBinAttributeResponse) Validate() error {
	return dara.Validate(s)
}

type iUpgradeFileSystemRequest interface {
	dara.Model
	String() string
	GoString() string
	SetCapacity(v int64) *UpgradeFileSystemRequest
	GetCapacity() *int64
	SetClientToken(v string) *UpgradeFileSystemRequest
	GetClientToken() *string
	SetDryRun(v bool) *UpgradeFileSystemRequest
	GetDryRun() *bool
	SetFileSystemId(v string) *UpgradeFileSystemRequest
	GetFileSystemId() *string
	SetFileSystemType(v string) *UpgradeFileSystemRequest
	GetFileSystemType() *string
}

type UpgradeFileSystemRequest struct {
	// The desired capacity of the file system.
	//
	// The desired capacity of the file system must be greater than the original capacity of the file system. Unit: GiB.
	//
	// This parameter is required.
	//
	// example:
	//
	// 100
	Capacity *int64 `json:"Capacity,omitempty" xml:"Capacity,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)
	//
	// > If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.
	//
	// example:
	//
	// 123e4567-e89b-12d3-a456-42665544****
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run.
	//
	// During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no file system is created and no fee is incurred.
	//
	// Valid values:
	//
	// 	- true: performs a dry run. The system checks the required parameters, request syntax, limits, and available NAS resources. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the FileSystemId parameter.
	//
	// 	- false (default): performs a dry run and sends the request. If the request passes the dry run, a file system is created.
	//
	// example:
	//
	// true
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the file system.
	//
	// 	- The IDs of Extreme NAS file systems must start with `extreme-`, for example, extreme-0015\\*\\*\\*\\*.
	//
	// 	- The IDs of CPFS file systems must start with `cpfs-`, for example, cpfs-125487\\*\\*\\*\\*.
	//
	// > CPFS file systems are available only on the China site (aliyun.com).
	//
	// This parameter is required.
	//
	// example:
	//
	// 1ca404****
	FileSystemId   *string `json:"FileSystemId,omitempty" xml:"FileSystemId,omitempty"`
	FileSystemType *string `json:"FileSystemType,omitempty" xml:"FileSystemType,omitempty"`
}

func (s UpgradeFileSystemRequest) String() string {
	return dara.Prettify(s)
}

func (s UpgradeFileSystemRequest) GoString() string {
	return s.String()
}

func (s *UpgradeFileSystemRequest) GetCapacity() *int64 {
	return s.Capacity
}

func (s *UpgradeFileSystemRequest) GetClientToken() *string {
	return s.ClientToken
}

func (s *UpgradeFileSystemRequest) GetDryRun() *bool {
	return s.DryRun
}

func (s *UpgradeFileSystemRequest) GetFileSystemId() *string {
	return s.FileSystemId
}

func (s *UpgradeFileSystemRequest) GetFileSystemType() *string {
	return s.FileSystemType
}

func (s *UpgradeFileSystemRequest) SetCapacity(v int64) *UpgradeFileSystemRequest {
	s.Capacity = &v
	return s
}

func (s *UpgradeFileSystemRequest) SetClientToken(v string) *UpgradeFileSystemRequest {
	s.ClientToken = &v
	return s
}

func (s *UpgradeFileSystemRequest) SetDryRun(v bool) *UpgradeFileSystemRequest {
	s.DryRun = &v
	return s
}

func (s *UpgradeFileSystemRequest) SetFileSystemId(v string) *UpgradeFileSystemRequest {
	s.FileSystemId = &v
	return s
}

func (s *UpgradeFileSystemRequest) SetFileSystemType(v string) *UpgradeFileSystemRequest {
	s.FileSystemType = &v
	return s
}

func (s *UpgradeFileSystemRequest) Validate() error {
	return dara.Validate(s)
}

type iUpgradeFileSystemResponseBody interface {
	dara.Model
	String() string
	GoString() string
	SetRequestId(v string) *UpgradeFileSystemResponseBody
	GetRequestId() *string
}

type UpgradeFileSystemResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 98696EF0-1607-4E9D-B01D-F20930B6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpgradeFileSystemResponseBody) String() string {
	return dara.Prettify(s)
}

func (s UpgradeFileSystemResponseBody) GoString() string {
	return s.String()
}

func (s *UpgradeFileSystemResponseBody) GetRequestId() *string {
	return s.RequestId
}

func (s *UpgradeFileSystemResponseBody) SetRequestId(v string) *UpgradeFileSystemResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpgradeFileSystemResponseBody) Validate() error {
	return dara.Validate(s)
}

type iUpgradeFileSystemResponse interface {
	dara.Model
	String() string
	GoString() string
	SetHeaders(v map[string]*string) *UpgradeFileSystemResponse
	GetHeaders() map[string]*string
	SetStatusCode(v int32) *UpgradeFileSystemResponse
	GetStatusCode() *int32
	SetBody(v *UpgradeFileSystemResponseBody) *UpgradeFileSystemResponse
	GetBody() *UpgradeFileSystemResponseBody
}

type UpgradeFileSystemResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpgradeFileSystemResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpgradeFileSystemResponse) String() string {
	return dara.Prettify(s)
}

func (s UpgradeFileSystemResponse) GoString() string {
	return s.String()
}

func (s *UpgradeFileSystemResponse) GetHeaders() map[string]*string {
	return s.Headers
}

func (s *UpgradeFileSystemResponse) GetStatusCode() *int32 {
	return s.StatusCode
}

func (s *UpgradeFileSystemResponse) GetBody() *UpgradeFileSystemResponseBody {
	return s.Body
}

func (s *UpgradeFileSystemResponse) SetHeaders(v map[string]*string) *UpgradeFileSystemResponse {
	s.Headers = v
	return s
}

func (s *UpgradeFileSystemResponse) SetStatusCode(v int32) *UpgradeFileSystemResponse {
	s.StatusCode = &v
	return s
}

func (s *UpgradeFileSystemResponse) SetBody(v *UpgradeFileSystemResponseBody) *UpgradeFileSystemResponse {
	s.Body = v
	return s
}

func (s *UpgradeFileSystemResponse) Validate() error {
	return dara.Validate(s)
}

type Client struct {
	openapi.Client
	DisableSDKError *bool
}

func NewClient(config *openapiutil.Config) (*Client, error) {
	client := new(Client)
	err := client.Init(config)
	return client, err
}

func (client *Client) Init(config *openapiutil.Config) (_err error) {
	_err = client.Client.Init(config)
	if _err != nil {
		return _err
	}
	client.EndpointRule = dara.String("regional")
	client.EndpointMap = map[string]*string{
		"cn-chengdu":          dara.String("nas.aliyuncs.com"),
		"me-east-1":           dara.String("nas.ap-northeast-1.aliyuncs.com"),
		"cn-hangzhou-finance": dara.String("nas.aliyuncs.com"),
	}
	_err = client.CheckConfig(config)
	if _err != nil {
		return _err
	}
	client.Endpoint, _err = client.GetEndpoint(dara.String("nas"), client.RegionId, client.EndpointRule, client.Network, client.Suffix, client.EndpointMap, client.Endpoint)
	if _err != nil {
		return _err
	}

	return nil
}

func (client *Client) GetEndpoint(productId *string, regionId *string, endpointRule *string, network *string, suffix *string, endpointMap map[string]*string, endpoint *string) (_result *string, _err error) {
	if !dara.IsNil(endpoint) {
		_result = endpoint
		return _result, _err
	}

	if !dara.IsNil(endpointMap) && !dara.IsNil(endpointMap[dara.StringValue(regionId)]) {
		_result = endpointMap[dara.StringValue(regionId)]
		return _result, _err
	}

	_body, _err := openapiutil.GetEndpointRules(productId, regionId, endpointRule, network, suffix)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Deprecated: OpenAPI AddClientToBlackList is deprecated
//
// Summary:
//
// 将客户端加入黑名单
//
// Description:
//
// The API operation is available only for CPFS file systems.
//
// @param request - AddClientToBlackListRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AddClientToBlackListResponse
// Deprecated
func (client *Client) AddClientToBlackListWithOptions(request *AddClientToBlackListRequest, runtime *dara.RuntimeOptions) (_result *AddClientToBlackListResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientIP) {
		query["ClientIP"] = request.ClientIP
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AddClientToBlackList"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Deprecated: OpenAPI AddClientToBlackList is deprecated
//
// Summary:
//
// 将客户端加入黑名单
//
// Description:
//
// The API operation is available only for CPFS file systems.
//
// @param request - AddClientToBlackListRequest
//
// @return AddClientToBlackListResponse
// Deprecated
func (client *Client) AddClientToBlackList(request *AddClientToBlackListRequest) (_result *AddClientToBlackListResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.AddClientToBlackListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Applies an automatic snapshot policy to one or more file systems.
//
// Description:
//
//	  The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
//
//		- Only advanced Extreme NAS file systems support this feature.
//
//		- You can apply only one automatic snapshot policy to each file system.
//
//		- Each automatic snapshot policy can be applied to multiple file systems.
//
//		- If an automatic snapshot policy is applied to a file system, you can call the ApplyAutoSnapshotPolicy operation to change the automatic snapshot policy.
//
// @param request - ApplyAutoSnapshotPolicyRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ApplyAutoSnapshotPolicyResponse
func (client *Client) ApplyAutoSnapshotPolicyWithOptions(request *ApplyAutoSnapshotPolicyRequest, runtime *dara.RuntimeOptions) (_result *ApplyAutoSnapshotPolicyResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AutoSnapshotPolicyId) {
		query["AutoSnapshotPolicyId"] = request.AutoSnapshotPolicyId
	}

	if !dara.IsNil(request.FileSystemIds) {
		query["FileSystemIds"] = request.FileSystemIds
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ApplyAutoSnapshotPolicy"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Applies an automatic snapshot policy to one or more file systems.
//
// Description:
//
//	  The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
//
//		- Only advanced Extreme NAS file systems support this feature.
//
//		- You can apply only one automatic snapshot policy to each file system.
//
//		- Each automatic snapshot policy can be applied to multiple file systems.
//
//		- If an automatic snapshot policy is applied to a file system, you can call the ApplyAutoSnapshotPolicy operation to change the automatic snapshot policy.
//
// @param request - ApplyAutoSnapshotPolicyRequest
//
// @return ApplyAutoSnapshotPolicyResponse
func (client *Client) ApplyAutoSnapshotPolicy(request *ApplyAutoSnapshotPolicyRequest) (_result *ApplyAutoSnapshotPolicyResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.ApplyAutoSnapshotPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Adds AutoRefresh configurations to a dataflow.
//
// Description:
//
//	  This operation is available only to Cloud Parallel File Storage (CPFS) file systems on the China site (aliyun.com).
//
//		- Only CPFS V2.2.0 and later support dataflows. You can view the version information on the file system details page in the console.
//
//		- You can add AutoRefresh configurations only to the dataflows that are in the `Running` state.
//
//		- You can add a maximum of five AutoRefresh configurations to a dataflow.
//
//		- It generally takes 2 to 5 minutes to create an AutoRefresh configuration. You can call the [DescribeDataFlows](https://help.aliyun.com/document_detail/2838084.html) operation to query the dataflow status.
//
//		- AutoRefresh depends on the object modification events collected by EventBridge from the source Object Storage Service (OSS) bucket. You must first [activate EventBridge](https://help.aliyun.com/document_detail/182246.html).
//
//	    > The event buses and event rules created for CPFS in the EventBridge console contain the `Create for cpfs auto refresh` description. The event buses and event rules cannot be modified or deleted. Otherwise, AutoRefresh cannot work properly.
//
//		- The AutoRefresh configuration applies only to the prefix and is specified by the RefreshPath parameter. When you add an AutoRefresh configuration to the prefix for a CPFS dataflow, an event bus is created at the user side and an event rule is created for the prefix of the source OSS bucket. When an object is modified in the prefix of the source OSS bucket, an OSS event is generated in the EventBridge console. The event is processed by the CPFS dataflow.
//
//		- After AutoRefresh is configured, if the data in the source OSS bucket is updated, the updated metadata is automatically synchronized to the CPFS file system. You can load the updated data when you access files, or run a dataflow task to load the updated data.
//
//		- AutoRefreshInterval refers to the interval at which CPFS checks whether data is updated in the prefix of the source OSS bucket. If data is updated, CPFS runs an AutoRefresh task. If the frequency of triggering the object modification event in the source OSS bucket exceeds the processing capability of the CPFS dataflow, AutoRefresh tasks are accumulated, metadata updates are delayed, and the dataflow status becomes Misconfigured. To resolve these issues, you can increase the dataflow specifications or reduce the frequency of triggering the object modification event.
//
// @param request - ApplyDataFlowAutoRefreshRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ApplyDataFlowAutoRefreshResponse
func (client *Client) ApplyDataFlowAutoRefreshWithOptions(request *ApplyDataFlowAutoRefreshRequest, runtime *dara.RuntimeOptions) (_result *ApplyDataFlowAutoRefreshResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AutoRefreshInterval) {
		query["AutoRefreshInterval"] = request.AutoRefreshInterval
	}

	if !dara.IsNil(request.AutoRefreshPolicy) {
		query["AutoRefreshPolicy"] = request.AutoRefreshPolicy
	}

	if !dara.IsNil(request.AutoRefreshs) {
		query["AutoRefreshs"] = request.AutoRefreshs
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DataFlowId) {
		query["DataFlowId"] = request.DataFlowId
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ApplyDataFlowAutoRefresh"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Adds AutoRefresh configurations to a dataflow.
//
// Description:
//
//	  This operation is available only to Cloud Parallel File Storage (CPFS) file systems on the China site (aliyun.com).
//
//		- Only CPFS V2.2.0 and later support dataflows. You can view the version information on the file system details page in the console.
//
//		- You can add AutoRefresh configurations only to the dataflows that are in the `Running` state.
//
//		- You can add a maximum of five AutoRefresh configurations to a dataflow.
//
//		- It generally takes 2 to 5 minutes to create an AutoRefresh configuration. You can call the [DescribeDataFlows](https://help.aliyun.com/document_detail/2838084.html) operation to query the dataflow status.
//
//		- AutoRefresh depends on the object modification events collected by EventBridge from the source Object Storage Service (OSS) bucket. You must first [activate EventBridge](https://help.aliyun.com/document_detail/182246.html).
//
//	    > The event buses and event rules created for CPFS in the EventBridge console contain the `Create for cpfs auto refresh` description. The event buses and event rules cannot be modified or deleted. Otherwise, AutoRefresh cannot work properly.
//
//		- The AutoRefresh configuration applies only to the prefix and is specified by the RefreshPath parameter. When you add an AutoRefresh configuration to the prefix for a CPFS dataflow, an event bus is created at the user side and an event rule is created for the prefix of the source OSS bucket. When an object is modified in the prefix of the source OSS bucket, an OSS event is generated in the EventBridge console. The event is processed by the CPFS dataflow.
//
//		- After AutoRefresh is configured, if the data in the source OSS bucket is updated, the updated metadata is automatically synchronized to the CPFS file system. You can load the updated data when you access files, or run a dataflow task to load the updated data.
//
//		- AutoRefreshInterval refers to the interval at which CPFS checks whether data is updated in the prefix of the source OSS bucket. If data is updated, CPFS runs an AutoRefresh task. If the frequency of triggering the object modification event in the source OSS bucket exceeds the processing capability of the CPFS dataflow, AutoRefresh tasks are accumulated, metadata updates are delayed, and the dataflow status becomes Misconfigured. To resolve these issues, you can increase the dataflow specifications or reduce the frequency of triggering the object modification event.
//
// @param request - ApplyDataFlowAutoRefreshRequest
//
// @return ApplyDataFlowAutoRefreshResponse
func (client *Client) ApplyDataFlowAutoRefresh(request *ApplyDataFlowAutoRefreshRequest) (_result *ApplyDataFlowAutoRefreshResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.ApplyDataFlowAutoRefreshWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 绑定挂载点
//
// @param request - AttachVscMountPointRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AttachVscMountPointResponse
func (client *Client) AttachVscMountPointWithOptions(request *AttachVscMountPointRequest, runtime *dara.RuntimeOptions) (_result *AttachVscMountPointResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.MountPointDomain) {
		query["MountPointDomain"] = request.MountPointDomain
	}

	if !dara.IsNil(request.VscAttachInfos) {
		query["VscAttachInfos"] = request.VscAttachInfos
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AttachVscMountPoint"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// 绑定挂载点
//
// @param request - AttachVscMountPointRequest
//
// @return AttachVscMountPointResponse
func (client *Client) AttachVscMountPoint(request *AttachVscMountPointRequest) (_result *AttachVscMountPointResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.AttachVscMountPointWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 绑定文件系统
//
// @param request - AttachVscToFilesystemsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AttachVscToFilesystemsResponse
func (client *Client) AttachVscToFilesystemsWithOptions(request *AttachVscToFilesystemsRequest, runtime *dara.RuntimeOptions) (_result *AttachVscToFilesystemsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ResourceIds) {
		query["ResourceIds"] = request.ResourceIds
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("AttachVscToFilesystems"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// 绑定文件系统
//
// @param request - AttachVscToFilesystemsRequest
//
// @return AttachVscToFilesystemsResponse
func (client *Client) AttachVscToFilesystems(request *AttachVscToFilesystemsRequest) (_result *AttachVscToFilesystemsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.AttachVscToFilesystemsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 存储包绑定文件系统
//
// @param request - BindStoragePackageRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return BindStoragePackageResponse
func (client *Client) BindStoragePackageWithOptions(request *BindStoragePackageRequest, runtime *dara.RuntimeOptions) (_result *BindStoragePackageResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.PackageId) {
		query["PackageId"] = request.PackageId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("BindStoragePackage"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// 存储包绑定文件系统
//
// @param request - BindStoragePackageRequest
//
// @return BindStoragePackageResponse
func (client *Client) BindStoragePackage(request *BindStoragePackageRequest) (_result *BindStoragePackageResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.BindStoragePackageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Removes automatic snapshot policies from one or more file systems.
//
// Description:
//
//	  The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
//
//		- Only advanced Extreme NAS file systems support this feature.
//
// @param request - CancelAutoSnapshotPolicyRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CancelAutoSnapshotPolicyResponse
func (client *Client) CancelAutoSnapshotPolicyWithOptions(request *CancelAutoSnapshotPolicyRequest, runtime *dara.RuntimeOptions) (_result *CancelAutoSnapshotPolicyResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemIds) {
		query["FileSystemIds"] = request.FileSystemIds
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CancelAutoSnapshotPolicy"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Removes automatic snapshot policies from one or more file systems.
//
// Description:
//
//	  The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
//
//		- Only advanced Extreme NAS file systems support this feature.
//
// @param request - CancelAutoSnapshotPolicyRequest
//
// @return CancelAutoSnapshotPolicyResponse
func (client *Client) CancelAutoSnapshotPolicy(request *CancelAutoSnapshotPolicyRequest) (_result *CancelAutoSnapshotPolicyResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CancelAutoSnapshotPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Cancels the AutoRefresh configuration for a dataflow.
//
// Description:
//
//	  This operation is available only to Cloud Parallel File Storage (CPFS) file systems on the China site (aliyun.com).
//
//		- Only CPFS V2.2.0 and later support dataflows. You can view the version information on the file system details page in the console.
//
//		- You can cancel AutoRefresh configurations only for the dataflows that are in the `Running` or `Stopped` state.
//
//		- It generally takes 2 to 5 minutes to cancel the AutoRefresh configurations. You can call the [DescribeDataFlows](https://help.aliyun.com/document_detail/2838084.html) operation to query the status of the AutoRefresh tasks.
//
// @param request - CancelDataFlowAutoRefreshRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CancelDataFlowAutoRefreshResponse
func (client *Client) CancelDataFlowAutoRefreshWithOptions(request *CancelDataFlowAutoRefreshRequest, runtime *dara.RuntimeOptions) (_result *CancelDataFlowAutoRefreshResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DataFlowId) {
		query["DataFlowId"] = request.DataFlowId
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.RefreshPath) {
		query["RefreshPath"] = request.RefreshPath
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CancelDataFlowAutoRefresh"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Cancels the AutoRefresh configuration for a dataflow.
//
// Description:
//
//	  This operation is available only to Cloud Parallel File Storage (CPFS) file systems on the China site (aliyun.com).
//
//		- Only CPFS V2.2.0 and later support dataflows. You can view the version information on the file system details page in the console.
//
//		- You can cancel AutoRefresh configurations only for the dataflows that are in the `Running` or `Stopped` state.
//
//		- It generally takes 2 to 5 minutes to cancel the AutoRefresh configurations. You can call the [DescribeDataFlows](https://help.aliyun.com/document_detail/2838084.html) operation to query the status of the AutoRefresh tasks.
//
// @param request - CancelDataFlowAutoRefreshRequest
//
// @return CancelDataFlowAutoRefreshResponse
func (client *Client) CancelDataFlowAutoRefresh(request *CancelDataFlowAutoRefreshRequest) (_result *CancelDataFlowAutoRefreshResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CancelDataFlowAutoRefreshWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Cancels a data streaming task.
//
// Description:
//
//	  Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.6.0 and later support this operation. You can view the version information on the file system details page in the console.
//
//		- You can cancel a data streaming task only when the task is in the CREATED or RUNNING state.
//
//		- Data streaming tasks are executed asynchronously. You can call the DescribeDataFlowSubTasks operation to query the task execution status.
//
// @param request - CancelDataFlowSubTaskRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CancelDataFlowSubTaskResponse
func (client *Client) CancelDataFlowSubTaskWithOptions(request *CancelDataFlowSubTaskRequest, runtime *dara.RuntimeOptions) (_result *CancelDataFlowSubTaskResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DataFlowId) {
		query["DataFlowId"] = request.DataFlowId
	}

	if !dara.IsNil(request.DataFlowSubTaskId) {
		query["DataFlowSubTaskId"] = request.DataFlowSubTaskId
	}

	if !dara.IsNil(request.DataFlowTaskId) {
		query["DataFlowTaskId"] = request.DataFlowTaskId
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CancelDataFlowSubTask"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Cancels a data streaming task.
//
// Description:
//
//	  Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.6.0 and later support this operation. You can view the version information on the file system details page in the console.
//
//		- You can cancel a data streaming task only when the task is in the CREATED or RUNNING state.
//
//		- Data streaming tasks are executed asynchronously. You can call the DescribeDataFlowSubTasks operation to query the task execution status.
//
// @param request - CancelDataFlowSubTaskRequest
//
// @return CancelDataFlowSubTaskResponse
func (client *Client) CancelDataFlowSubTask(request *CancelDataFlowSubTaskRequest) (_result *CancelDataFlowSubTaskResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CancelDataFlowSubTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Cancels a dataflow task that is not running.
//
// Description:
//
//	  Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.4.0 and later support data flow tasks. You can view the version information on the file system details page in the console.
//
//		- You can cancel only the data flow tasks that are in the `Pending` and `Executing` states.
//
//		- It generally takes 5 to 10 minutes to cancel a data flow task. You can query the task execution status by calling the [DescribeDataFlowTasks](https://help.aliyun.com/document_detail/2838089.html) operation.
//
// @param request - CancelDataFlowTaskRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CancelDataFlowTaskResponse
func (client *Client) CancelDataFlowTaskWithOptions(request *CancelDataFlowTaskRequest, runtime *dara.RuntimeOptions) (_result *CancelDataFlowTaskResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DataFlowId) {
		query["DataFlowId"] = request.DataFlowId
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.TaskId) {
		query["TaskId"] = request.TaskId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CancelDataFlowTask"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Cancels a dataflow task that is not running.
//
// Description:
//
//	  Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.4.0 and later support data flow tasks. You can view the version information on the file system details page in the console.
//
//		- You can cancel only the data flow tasks that are in the `Pending` and `Executing` states.
//
//		- It generally takes 5 to 10 minutes to cancel a data flow task. You can query the task execution status by calling the [DescribeDataFlowTasks](https://help.aliyun.com/document_detail/2838089.html) operation.
//
// @param request - CancelDataFlowTaskRequest
//
// @return CancelDataFlowTaskResponse
func (client *Client) CancelDataFlowTask(request *CancelDataFlowTaskRequest) (_result *CancelDataFlowTaskResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CancelDataFlowTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Cancels the directory quota of a file system.
//
// Description:
//
// Only General-purpose file systems support the directory quota feature.
//
// @param request - CancelDirQuotaRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CancelDirQuotaResponse
func (client *Client) CancelDirQuotaWithOptions(request *CancelDirQuotaRequest, runtime *dara.RuntimeOptions) (_result *CancelDirQuotaResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.Path) {
		query["Path"] = request.Path
	}

	if !dara.IsNil(request.UserId) {
		query["UserId"] = request.UserId
	}

	if !dara.IsNil(request.UserType) {
		query["UserType"] = request.UserType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CancelDirQuota"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Cancels the directory quota of a file system.
//
// Description:
//
// Only General-purpose file systems support the directory quota feature.
//
// @param request - CancelDirQuotaRequest
//
// @return CancelDirQuotaResponse
func (client *Client) CancelDirQuota(request *CancelDirQuotaRequest) (_result *CancelDirQuotaResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CancelDirQuotaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Cancels the quota set for a fileset.
//
// Description:
//
// Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.7.0 and later support this operation.
//
// @param request - CancelFilesetQuotaRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CancelFilesetQuotaResponse
func (client *Client) CancelFilesetQuotaWithOptions(request *CancelFilesetQuotaRequest, runtime *dara.RuntimeOptions) (_result *CancelFilesetQuotaResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.FsetId) {
		query["FsetId"] = request.FsetId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CancelFilesetQuota"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Cancels the quota set for a fileset.
//
// Description:
//
// Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.7.0 and later support this operation.
//
// @param request - CancelFilesetQuotaRequest
//
// @return CancelFilesetQuotaResponse
func (client *Client) CancelFilesetQuota(request *CancelFilesetQuotaRequest) (_result *CancelFilesetQuotaResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CancelFilesetQuotaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Cancels a running data retrieval task.
//
// Description:
//
// Only General-purpose NAS file systems support this operation.
//
// @param request - CancelLifecycleRetrieveJobRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CancelLifecycleRetrieveJobResponse
func (client *Client) CancelLifecycleRetrieveJobWithOptions(request *CancelLifecycleRetrieveJobRequest, runtime *dara.RuntimeOptions) (_result *CancelLifecycleRetrieveJobResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.JobId) {
		query["JobId"] = request.JobId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CancelLifecycleRetrieveJob"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Cancels a running data retrieval task.
//
// Description:
//
// Only General-purpose NAS file systems support this operation.
//
// @param request - CancelLifecycleRetrieveJobRequest
//
// @return CancelLifecycleRetrieveJobResponse
func (client *Client) CancelLifecycleRetrieveJob(request *CancelLifecycleRetrieveJobRequest) (_result *CancelLifecycleRetrieveJobResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CancelLifecycleRetrieveJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Cancels a running job of the recycle bin.
//
// Description:
//
//	  Only General-purpose NAS file systems support this operation.
//
//		- You can cancel only jobs that are in the Running state. You cannot cancel jobs that are in the PartialSuccess, Success, Fail, or Cancelled state.
//
//		- If you cancel a running job that permanently deletes files, you cannot restore the files that are already permanently deleted.
//
//		- If you cancel a running job that restores files, you can query the restored files from the file system, and query the unrestored files from the recycle bin.
//
// @param request - CancelRecycleBinJobRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CancelRecycleBinJobResponse
func (client *Client) CancelRecycleBinJobWithOptions(request *CancelRecycleBinJobRequest, runtime *dara.RuntimeOptions) (_result *CancelRecycleBinJobResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(dara.ToMap(request))
	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CancelRecycleBinJob"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("GET"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Cancels a running job of the recycle bin.
//
// Description:
//
//	  Only General-purpose NAS file systems support this operation.
//
//		- You can cancel only jobs that are in the Running state. You cannot cancel jobs that are in the PartialSuccess, Success, Fail, or Cancelled state.
//
//		- If you cancel a running job that permanently deletes files, you cannot restore the files that are already permanently deleted.
//
//		- If you cancel a running job that restores files, you can query the restored files from the file system, and query the unrestored files from the recycle bin.
//
// @param request - CancelRecycleBinJobRequest
//
// @return CancelRecycleBinJobResponse
func (client *Client) CancelRecycleBinJob(request *CancelRecycleBinJobRequest) (_result *CancelRecycleBinJobResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CancelRecycleBinJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Changes the resource group to which a file system belongs.
//
// @param request - ChangeResourceGroupRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ChangeResourceGroupResponse
func (client *Client) ChangeResourceGroupWithOptions(request *ChangeResourceGroupRequest, runtime *dara.RuntimeOptions) (_result *ChangeResourceGroupResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.NewResourceGroupId) {
		query["NewResourceGroupId"] = request.NewResourceGroupId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.ResourceId) {
		query["ResourceId"] = request.ResourceId
	}

	if !dara.IsNil(request.ResourceType) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ChangeResourceGroup"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Changes the resource group to which a file system belongs.
//
// @param request - ChangeResourceGroupRequest
//
// @return ChangeResourceGroupResponse
func (client *Client) ChangeResourceGroup(request *ChangeResourceGroupRequest) (_result *ChangeResourceGroupResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.ChangeResourceGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a permission group.
//
// @param request - CreateAccessGroupRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateAccessGroupResponse
func (client *Client) CreateAccessGroupWithOptions(request *CreateAccessGroupRequest, runtime *dara.RuntimeOptions) (_result *CreateAccessGroupResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AccessGroupName) {
		query["AccessGroupName"] = request.AccessGroupName
	}

	if !dara.IsNil(request.AccessGroupType) {
		query["AccessGroupType"] = request.AccessGroupType
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.FileSystemType) {
		query["FileSystemType"] = request.FileSystemType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateAccessGroup"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Creates a permission group.
//
// @param request - CreateAccessGroupRequest
//
// @return CreateAccessGroupResponse
func (client *Client) CreateAccessGroup(request *CreateAccessGroupRequest) (_result *CreateAccessGroupResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CreateAccessGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates an access point.
//
// Description:
//
//	  After you call the CreateAccessPoint operation, an access point is not immediately created. Therefore, after you call the CreateAccessPoint operation successfully, call the [DescribeAccessPoints](https://help.aliyun.com/document_detail/2712239.html) or [DescribeAccessPoint](https://help.aliyun.com/document_detail/2712240.html) operation to query the status of the access point. If the status is **Active**, mount the file system. Otherwise, the file system may fail to be mounted.
//
//		- Only General-purpose Network File System (NFS) file systems support access points.
//
//		- If you want to call the EnabledRam operation to enable a Resource Access Management (RAM) policy, you must configure the corresponding RAM permissions. For more information, see [Manage endpoints](https://help.aliyun.com/document_detail/2545998.html).
//
// @param request - CreateAccessPointRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateAccessPointResponse
func (client *Client) CreateAccessPointWithOptions(request *CreateAccessPointRequest, runtime *dara.RuntimeOptions) (_result *CreateAccessPointResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AccessGroup) {
		query["AccessGroup"] = request.AccessGroup
	}

	if !dara.IsNil(request.AccessPointName) {
		query["AccessPointName"] = request.AccessPointName
	}

	if !dara.IsNil(request.EnabledRam) {
		query["EnabledRam"] = request.EnabledRam
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.OwnerGroupId) {
		query["OwnerGroupId"] = request.OwnerGroupId
	}

	if !dara.IsNil(request.OwnerUserId) {
		query["OwnerUserId"] = request.OwnerUserId
	}

	if !dara.IsNil(request.Permission) {
		query["Permission"] = request.Permission
	}

	if !dara.IsNil(request.PosixGroupId) {
		query["PosixGroupId"] = request.PosixGroupId
	}

	if !dara.IsNil(request.PosixSecondaryGroupIds) {
		query["PosixSecondaryGroupIds"] = request.PosixSecondaryGroupIds
	}

	if !dara.IsNil(request.PosixUserId) {
		query["PosixUserId"] = request.PosixUserId
	}

	if !dara.IsNil(request.ProtocolType) {
		query["ProtocolType"] = request.ProtocolType
	}

	if !dara.IsNil(request.RootDirectory) {
		query["RootDirectory"] = request.RootDirectory
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	if !dara.IsNil(request.VswId) {
		query["VswId"] = request.VswId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateAccessPoint"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Creates an access point.
//
// Description:
//
//	  After you call the CreateAccessPoint operation, an access point is not immediately created. Therefore, after you call the CreateAccessPoint operation successfully, call the [DescribeAccessPoints](https://help.aliyun.com/document_detail/2712239.html) or [DescribeAccessPoint](https://help.aliyun.com/document_detail/2712240.html) operation to query the status of the access point. If the status is **Active**, mount the file system. Otherwise, the file system may fail to be mounted.
//
//		- Only General-purpose Network File System (NFS) file systems support access points.
//
//		- If you want to call the EnabledRam operation to enable a Resource Access Management (RAM) policy, you must configure the corresponding RAM permissions. For more information, see [Manage endpoints](https://help.aliyun.com/document_detail/2545998.html).
//
// @param request - CreateAccessPointRequest
//
// @return CreateAccessPointResponse
func (client *Client) CreateAccessPoint(request *CreateAccessPointRequest) (_result *CreateAccessPointResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CreateAccessPointWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a rule for a permission group.
//
// @param request - CreateAccessRuleRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateAccessRuleResponse
func (client *Client) CreateAccessRuleWithOptions(request *CreateAccessRuleRequest, runtime *dara.RuntimeOptions) (_result *CreateAccessRuleResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AccessGroupName) {
		query["AccessGroupName"] = request.AccessGroupName
	}

	if !dara.IsNil(request.FileSystemType) {
		query["FileSystemType"] = request.FileSystemType
	}

	if !dara.IsNil(request.Ipv6SourceCidrIp) {
		query["Ipv6SourceCidrIp"] = request.Ipv6SourceCidrIp
	}

	if !dara.IsNil(request.Priority) {
		query["Priority"] = request.Priority
	}

	if !dara.IsNil(request.RWAccessType) {
		query["RWAccessType"] = request.RWAccessType
	}

	if !dara.IsNil(request.SourceCidrIp) {
		query["SourceCidrIp"] = request.SourceCidrIp
	}

	if !dara.IsNil(request.UserAccessType) {
		query["UserAccessType"] = request.UserAccessType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateAccessRule"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Creates a rule for a permission group.
//
// @param request - CreateAccessRuleRequest
//
// @return CreateAccessRuleResponse
func (client *Client) CreateAccessRule(request *CreateAccessRuleRequest) (_result *CreateAccessRuleResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CreateAccessRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates an automatic snapshot policy.
//
// Description:
//
//	  The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
//
//		- Only advanced Extreme NAS file systems support the snapshot feature.
//
//		- You can create a maximum of 100 automatic snapshot policies in each region for an Alibaba Cloud account.
//
//		- If an auto snapshot is being created when the scheduled time for a new auto snapshot arrives, the creation of the new snapshot is skipped. This occurs if the file system stores a large volume of data. For example, you have scheduled auto snapshots to be created at 09:00:00, 10:00:00, 11:00:00, and 12:00:00 for a file system. The system starts to create an auto snapshot at 09:00:00 and does not complete the process until 10:20:00. The process takes 80 minutes because the file system has a large volume of data. In this case, the system does not create an auto snapshot at 10:00:00, but creates an auto snapshot at 11:00:00.
//
//		- A maximum of 128 auto snapshots can be created for a file system. If the upper limit is reached, the earliest auto snapshot is deleted. This rule does not apply to manual snapshots.
//
//		- If you modify the retention period of an automatic snapshot policy, the modification applies only to subsequent snapshots, but not to the existing snapshots.
//
//		- If an auto snapshot is being created for a file system, you cannot create a manual snapshot for the file system. You must wait after the auto snapshot is created.
//
//		- You can only apply automatic snapshot policies to a file system that is in the Running state.
//
//		- All auto snapshots are named in the `auto_yyyyMMdd_X` format, where: `auto` indicates that the snapshot is created based on an automatic snapshot policy. `yyyyMMdd` indicates the date on which the snapshot is created. `y` indicates the year. `M` indicates the month. `d` indicates the day. `X` indicates the ordinal number of the snapshot on the current day. For example, `auto_20201018_1` indicates the first auto snapshot that was created on October 18, 2020.
//
//		- After an automatic snapshot policy is created, you can call the ApplyAutoSnapshotPolicy operation to apply the policy to a file system and call the ModifyAutoSnapshotPolicy operation to modify the policy.
//
// @param request - CreateAutoSnapshotPolicyRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateAutoSnapshotPolicyResponse
func (client *Client) CreateAutoSnapshotPolicyWithOptions(request *CreateAutoSnapshotPolicyRequest, runtime *dara.RuntimeOptions) (_result *CreateAutoSnapshotPolicyResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AutoSnapshotPolicyName) {
		query["AutoSnapshotPolicyName"] = request.AutoSnapshotPolicyName
	}

	if !dara.IsNil(request.FileSystemType) {
		query["FileSystemType"] = request.FileSystemType
	}

	if !dara.IsNil(request.RepeatWeekdays) {
		query["RepeatWeekdays"] = request.RepeatWeekdays
	}

	if !dara.IsNil(request.RetentionDays) {
		query["RetentionDays"] = request.RetentionDays
	}

	if !dara.IsNil(request.TimePoints) {
		query["TimePoints"] = request.TimePoints
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateAutoSnapshotPolicy"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Creates an automatic snapshot policy.
//
// Description:
//
//	  The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
//
//		- Only advanced Extreme NAS file systems support the snapshot feature.
//
//		- You can create a maximum of 100 automatic snapshot policies in each region for an Alibaba Cloud account.
//
//		- If an auto snapshot is being created when the scheduled time for a new auto snapshot arrives, the creation of the new snapshot is skipped. This occurs if the file system stores a large volume of data. For example, you have scheduled auto snapshots to be created at 09:00:00, 10:00:00, 11:00:00, and 12:00:00 for a file system. The system starts to create an auto snapshot at 09:00:00 and does not complete the process until 10:20:00. The process takes 80 minutes because the file system has a large volume of data. In this case, the system does not create an auto snapshot at 10:00:00, but creates an auto snapshot at 11:00:00.
//
//		- A maximum of 128 auto snapshots can be created for a file system. If the upper limit is reached, the earliest auto snapshot is deleted. This rule does not apply to manual snapshots.
//
//		- If you modify the retention period of an automatic snapshot policy, the modification applies only to subsequent snapshots, but not to the existing snapshots.
//
//		- If an auto snapshot is being created for a file system, you cannot create a manual snapshot for the file system. You must wait after the auto snapshot is created.
//
//		- You can only apply automatic snapshot policies to a file system that is in the Running state.
//
//		- All auto snapshots are named in the `auto_yyyyMMdd_X` format, where: `auto` indicates that the snapshot is created based on an automatic snapshot policy. `yyyyMMdd` indicates the date on which the snapshot is created. `y` indicates the year. `M` indicates the month. `d` indicates the day. `X` indicates the ordinal number of the snapshot on the current day. For example, `auto_20201018_1` indicates the first auto snapshot that was created on October 18, 2020.
//
//		- After an automatic snapshot policy is created, you can call the ApplyAutoSnapshotPolicy operation to apply the policy to a file system and call the ModifyAutoSnapshotPolicy operation to modify the policy.
//
// @param request - CreateAutoSnapshotPolicyRequest
//
// @return CreateAutoSnapshotPolicyResponse
func (client *Client) CreateAutoSnapshotPolicy(request *CreateAutoSnapshotPolicyRequest) (_result *CreateAutoSnapshotPolicyResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CreateAutoSnapshotPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a dataflow for a Cloud Parallel File Storage (CPFS) file system and source storage.
//
// Description:
//
//	  Basic operations
//
//	    	- Cloud Parallel File Storage (CPFS) for LINGJUN V2.4.0 and later support data flows.
//
//	    	- You can create a data flow only when a CPFS for LINGJUN file system is in the Running state.
//
//	    	- A maximum of 10 data flows can be created for a CPFS for LINGJUN file system.
//
//	    	- It generally takes 2 to 5 minutes to create a data flow. You can call the DescribeDataFlows operation to check whether the data flow has been created.
//
//		- Permissions
//
//	    When you create a data flow, CPFS for LINGJUN obtains the following two service-linked roles: `AliyunServiceRoleForNasOssDataflow` and `AliyunServiceRoleForNasEventNotification`. For more information, see [CPFS service-linked roles](https://help.aliyun.com/document_detail/2837688.html).
//
//		- CPFS for LINGJUN usage notes
//
//	     	- Source storage
//
//	         	- The source storage is an Object Storage Service (OSS) bucket. SourceStorage for a data flow must be an OSS bucket.
//
//	         	- CPFS for LINGJUN data flows support both encrypted and unencrypted access to OSS. If you select SSL-encrypted access to OSS, make sure that encryption in transit for OSS buckets supports encrypted access.
//
//	         	- If data flows for multiple CPFS for LINGJUN file systems or multiple data flows for the same CPFS for LINGJUN file system are stored in the same OSS bucket, you must enable versioning for the OSS bucket to prevent data conflicts caused by data export from multiple CPFS for LINGJUN file systems to one OSS bucket.
//
//	         	- Data flows are not supported for OSS buckets across regions. The OSS bucket must reside in the same region as the CPFS file system.
//
//	         	- CPFS for LINGJUN V2.6.0 and later allow you to create data flows for OSS buckets across accounts.
//
//	         	- The account id parameter is required only when you use OSS buckets across accounts.
//
//	         	- To use OSS buckets across accounts, you must first grant permissions to the related accounts. For more information, see [Cross-account authorization on data flows](https://help.aliyun.com/document_detail/2713462.html).
//
//	         >  Before you create a data flow, you must configure a tag (key: cpfs-dataflow, value: true) for the source OSS bucket. This way, the created data flow can access the data in the OSS bucket. When a data flow is being used, do not delete or modify the tag. Otherwise, the data flow for CPFS for LINGJUN cannot access the data in the OSS bucket.
//
//	    	- Limits of data flows on file systems
//
//	        	- You cannot rename a non-empty directory in a path that is associated with a data flow. Otherwise, the Permission Denied error message or an error message indicating that the directory is not empty is returned.
//
//	        	- Proceed with caution when you use special characters in the names of directories and files. The following characters are supported: letters, digits, exclamation points (!), hyphens (-), underscores (_), periods (.), asterisks (\\*), and parentheses (()).
//
//	        	- The path can be up to 1,023 characters in length.
//
//	    	- Limits of data flows on import
//
//	        	- After a symbolic link is imported to CPFS for LINGJUN, the symbolic link is converted into a common data file that contains no symbolic link information.
//
//	        	- If an OSS bucket has multiple versions, only data of the latest version is used.
//
//	        	- The name of a file or a subdirectory can be up to 255 bytes in length.
//
//	    	- Limits of data flows on export
//
//	        	- After a symbolic link is synchronized to OSS, the file that the symbolic link points to is not synchronized to OSS. In this case, the symbolic link is converted into a common object that contains no data.
//
//	        	- Hard links can be synchronized to OSS only as common files that contain no link information.
//
//	        	- After a file of the Socket, Device, or Pipe type is exported to an OSS bucket, the file is converted into a common object that contains no data.
//
//	        	- The directory path can be up to 1,023 characters in length.
//
// @param request - CreateDataFlowRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateDataFlowResponse
func (client *Client) CreateDataFlowWithOptions(request *CreateDataFlowRequest, runtime *dara.RuntimeOptions) (_result *CreateDataFlowResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AutoRefreshInterval) {
		query["AutoRefreshInterval"] = request.AutoRefreshInterval
	}

	if !dara.IsNil(request.AutoRefreshPolicy) {
		query["AutoRefreshPolicy"] = request.AutoRefreshPolicy
	}

	if !dara.IsNil(request.AutoRefreshs) {
		query["AutoRefreshs"] = request.AutoRefreshs
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.FileSystemPath) {
		query["FileSystemPath"] = request.FileSystemPath
	}

	if !dara.IsNil(request.FsetId) {
		query["FsetId"] = request.FsetId
	}

	if !dara.IsNil(request.SourceSecurityType) {
		query["SourceSecurityType"] = request.SourceSecurityType
	}

	if !dara.IsNil(request.SourceStorage) {
		query["SourceStorage"] = request.SourceStorage
	}

	if !dara.IsNil(request.SourceStoragePath) {
		query["SourceStoragePath"] = request.SourceStoragePath
	}

	if !dara.IsNil(request.Throughput) {
		query["Throughput"] = request.Throughput
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateDataFlow"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Creates a dataflow for a Cloud Parallel File Storage (CPFS) file system and source storage.
//
// Description:
//
//	  Basic operations
//
//	    	- Cloud Parallel File Storage (CPFS) for LINGJUN V2.4.0 and later support data flows.
//
//	    	- You can create a data flow only when a CPFS for LINGJUN file system is in the Running state.
//
//	    	- A maximum of 10 data flows can be created for a CPFS for LINGJUN file system.
//
//	    	- It generally takes 2 to 5 minutes to create a data flow. You can call the DescribeDataFlows operation to check whether the data flow has been created.
//
//		- Permissions
//
//	    When you create a data flow, CPFS for LINGJUN obtains the following two service-linked roles: `AliyunServiceRoleForNasOssDataflow` and `AliyunServiceRoleForNasEventNotification`. For more information, see [CPFS service-linked roles](https://help.aliyun.com/document_detail/2837688.html).
//
//		- CPFS for LINGJUN usage notes
//
//	     	- Source storage
//
//	         	- The source storage is an Object Storage Service (OSS) bucket. SourceStorage for a data flow must be an OSS bucket.
//
//	         	- CPFS for LINGJUN data flows support both encrypted and unencrypted access to OSS. If you select SSL-encrypted access to OSS, make sure that encryption in transit for OSS buckets supports encrypted access.
//
//	         	- If data flows for multiple CPFS for LINGJUN file systems or multiple data flows for the same CPFS for LINGJUN file system are stored in the same OSS bucket, you must enable versioning for the OSS bucket to prevent data conflicts caused by data export from multiple CPFS for LINGJUN file systems to one OSS bucket.
//
//	         	- Data flows are not supported for OSS buckets across regions. The OSS bucket must reside in the same region as the CPFS file system.
//
//	         	- CPFS for LINGJUN V2.6.0 and later allow you to create data flows for OSS buckets across accounts.
//
//	         	- The account id parameter is required only when you use OSS buckets across accounts.
//
//	         	- To use OSS buckets across accounts, you must first grant permissions to the related accounts. For more information, see [Cross-account authorization on data flows](https://help.aliyun.com/document_detail/2713462.html).
//
//	         >  Before you create a data flow, you must configure a tag (key: cpfs-dataflow, value: true) for the source OSS bucket. This way, the created data flow can access the data in the OSS bucket. When a data flow is being used, do not delete or modify the tag. Otherwise, the data flow for CPFS for LINGJUN cannot access the data in the OSS bucket.
//
//	    	- Limits of data flows on file systems
//
//	        	- You cannot rename a non-empty directory in a path that is associated with a data flow. Otherwise, the Permission Denied error message or an error message indicating that the directory is not empty is returned.
//
//	        	- Proceed with caution when you use special characters in the names of directories and files. The following characters are supported: letters, digits, exclamation points (!), hyphens (-), underscores (_), periods (.), asterisks (\\*), and parentheses (()).
//
//	        	- The path can be up to 1,023 characters in length.
//
//	    	- Limits of data flows on import
//
//	        	- After a symbolic link is imported to CPFS for LINGJUN, the symbolic link is converted into a common data file that contains no symbolic link information.
//
//	        	- If an OSS bucket has multiple versions, only data of the latest version is used.
//
//	        	- The name of a file or a subdirectory can be up to 255 bytes in length.
//
//	    	- Limits of data flows on export
//
//	        	- After a symbolic link is synchronized to OSS, the file that the symbolic link points to is not synchronized to OSS. In this case, the symbolic link is converted into a common object that contains no data.
//
//	        	- Hard links can be synchronized to OSS only as common files that contain no link information.
//
//	        	- After a file of the Socket, Device, or Pipe type is exported to an OSS bucket, the file is converted into a common object that contains no data.
//
//	        	- The directory path can be up to 1,023 characters in length.
//
// @param request - CreateDataFlowRequest
//
// @return CreateDataFlowResponse
func (client *Client) CreateDataFlow(request *CreateDataFlowRequest) (_result *CreateDataFlowResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CreateDataFlowWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a data streaming subtask.
//
// Description:
//
//	  Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.6.0 and later support this operation. You can view the version information on the file system details page in the console.
//
//		- You can create subtasks only for a data streaming subtask in the Executing state.
//
//		- Data streaming tasks are executed asynchronously. You can call the DescribeDataFlowSubTasks operation to query the task execution status.
//
//		- When the type of data flow task is streaming, the running status only indicates that a streaming import or export task can be created. It does not indicate that the import or export task is running.
//
// @param request - CreateDataFlowSubTaskRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateDataFlowSubTaskResponse
func (client *Client) CreateDataFlowSubTaskWithOptions(request *CreateDataFlowSubTaskRequest, runtime *dara.RuntimeOptions) (_result *CreateDataFlowSubTaskResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Condition) {
		query["Condition"] = request.Condition
	}

	if !dara.IsNil(request.DataFlowId) {
		query["DataFlowId"] = request.DataFlowId
	}

	if !dara.IsNil(request.DataFlowTaskId) {
		query["DataFlowTaskId"] = request.DataFlowTaskId
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.DstFilePath) {
		query["DstFilePath"] = request.DstFilePath
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.SrcFilePath) {
		query["SrcFilePath"] = request.SrcFilePath
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateDataFlowSubTask"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Creates a data streaming subtask.
//
// Description:
//
//	  Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.6.0 and later support this operation. You can view the version information on the file system details page in the console.
//
//		- You can create subtasks only for a data streaming subtask in the Executing state.
//
//		- Data streaming tasks are executed asynchronously. You can call the DescribeDataFlowSubTasks operation to query the task execution status.
//
//		- When the type of data flow task is streaming, the running status only indicates that a streaming import or export task can be created. It does not indicate that the import or export task is running.
//
// @param request - CreateDataFlowSubTaskRequest
//
// @return CreateDataFlowSubTaskResponse
func (client *Client) CreateDataFlowSubTask(request *CreateDataFlowSubTaskRequest) (_result *CreateDataFlowSubTaskResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CreateDataFlowSubTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a dataflow task.
//
// Description:
//
//	  Only Cloud Parallel File Storage CPFS for LINGJUN V2.4.0 and later support data flows. You can view the version information on the file system details page in the console.
//
//		- You can create a data flow task only for a data flow that is in the Running state.
//
//		- Data flow tasks are executed asynchronously. You can call the [DescribeDataFlowTasks](https://help.aliyun.com/document_detail/2838089.html) operation to query the task execution status. The task duration depends on the amount of data to be imported and exported. If a large amount of data exists, we recommend that you create multiple tasks.
//
//		- When you manually run a data flow task, the automatic data update task for the data flow is interrupted and enters the pending state.
//
//		- When you create an export task, make sure that the total length of the absolute path of the files to be exported from a CPFS or CPFS for LINGJUN file system does not exceed 1,023 characters.
//
//		- CPFS for LINGJUN supports two types of tasks: batch tasks and streaming tasks. For more information, see [Task types](https://help.aliyun.com/document_detail/2845429.html).
//
// @param request - CreateDataFlowTaskRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateDataFlowTaskResponse
func (client *Client) CreateDataFlowTaskWithOptions(request *CreateDataFlowTaskRequest, runtime *dara.RuntimeOptions) (_result *CreateDataFlowTaskResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ConflictPolicy) {
		query["ConflictPolicy"] = request.ConflictPolicy
	}

	if !dara.IsNil(request.CreateDirIfNotExist) {
		query["CreateDirIfNotExist"] = request.CreateDirIfNotExist
	}

	if !dara.IsNil(request.DataFlowId) {
		query["DataFlowId"] = request.DataFlowId
	}

	if !dara.IsNil(request.DataType) {
		query["DataType"] = request.DataType
	}

	if !dara.IsNil(request.Directory) {
		query["Directory"] = request.Directory
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.DstDirectory) {
		query["DstDirectory"] = request.DstDirectory
	}

	if !dara.IsNil(request.EntryList) {
		query["EntryList"] = request.EntryList
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.SrcTaskId) {
		query["SrcTaskId"] = request.SrcTaskId
	}

	if !dara.IsNil(request.TaskAction) {
		query["TaskAction"] = request.TaskAction
	}

	if !dara.IsNil(request.TransferFileListPath) {
		query["TransferFileListPath"] = request.TransferFileListPath
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateDataFlowTask"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Creates a dataflow task.
//
// Description:
//
//	  Only Cloud Parallel File Storage CPFS for LINGJUN V2.4.0 and later support data flows. You can view the version information on the file system details page in the console.
//
//		- You can create a data flow task only for a data flow that is in the Running state.
//
//		- Data flow tasks are executed asynchronously. You can call the [DescribeDataFlowTasks](https://help.aliyun.com/document_detail/2838089.html) operation to query the task execution status. The task duration depends on the amount of data to be imported and exported. If a large amount of data exists, we recommend that you create multiple tasks.
//
//		- When you manually run a data flow task, the automatic data update task for the data flow is interrupted and enters the pending state.
//
//		- When you create an export task, make sure that the total length of the absolute path of the files to be exported from a CPFS or CPFS for LINGJUN file system does not exceed 1,023 characters.
//
//		- CPFS for LINGJUN supports two types of tasks: batch tasks and streaming tasks. For more information, see [Task types](https://help.aliyun.com/document_detail/2845429.html).
//
// @param request - CreateDataFlowTaskRequest
//
// @return CreateDataFlowTaskResponse
func (client *Client) CreateDataFlowTask(request *CreateDataFlowTaskRequest) (_result *CreateDataFlowTaskResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CreateDataFlowTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a directory in a file system.
//
// Description:
//
// Only General-purpose Network File System (NFS) file systems support this operation.
//
// @param request - CreateDirRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateDirResponse
func (client *Client) CreateDirWithOptions(request *CreateDirRequest, runtime *dara.RuntimeOptions) (_result *CreateDirResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.OwnerGroupId) {
		query["OwnerGroupId"] = request.OwnerGroupId
	}

	if !dara.IsNil(request.OwnerUserId) {
		query["OwnerUserId"] = request.OwnerUserId
	}

	if !dara.IsNil(request.Permission) {
		query["Permission"] = request.Permission
	}

	if !dara.IsNil(request.Recursion) {
		query["Recursion"] = request.Recursion
	}

	if !dara.IsNil(request.RootDirectory) {
		query["RootDirectory"] = request.RootDirectory
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateDir"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Creates a directory in a file system.
//
// Description:
//
// Only General-purpose Network File System (NFS) file systems support this operation.
//
// @param request - CreateDirRequest
//
// @return CreateDirResponse
func (client *Client) CreateDir(request *CreateDirRequest) (_result *CreateDirResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CreateDirWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a directory or file.
//
// Description:
//
//	  This operation is only available to some users.
//
//		- This operation supports only General-purpose NAS file systems that use the Server Message Block (SMB) protocol and have Resource Access Management (RAM) enabled.
//
// @param request - CreateFileRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateFileResponse
func (client *Client) CreateFileWithOptions(request *CreateFileRequest, runtime *dara.RuntimeOptions) (_result *CreateFileResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.Owner) {
		query["Owner"] = request.Owner
	}

	if !dara.IsNil(request.OwnerAccessInheritable) {
		query["OwnerAccessInheritable"] = request.OwnerAccessInheritable
	}

	if !dara.IsNil(request.Path) {
		query["Path"] = request.Path
	}

	if !dara.IsNil(request.Type) {
		query["Type"] = request.Type
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateFile"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Creates a directory or file.
//
// Description:
//
//	  This operation is only available to some users.
//
//		- This operation supports only General-purpose NAS file systems that use the Server Message Block (SMB) protocol and have Resource Access Management (RAM) enabled.
//
// @param request - CreateFileRequest
//
// @return CreateFileResponse
func (client *Client) CreateFile(request *CreateFileRequest) (_result *CreateFileResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CreateFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a file system.
//
// Description:
//
//	  Before you call this operation, you must understand the billing and pricing of File Storage NAS. For more information, see [Billing](https://help.aliyun.com/document_detail/178365.html) and [Pricing](https://www.alibabacloud.com/product/nas/pricing).
//
//		- Before you create a file system, you must complete real-name verification.
//
//		- When you call this operation, a service-linked role of NAS is automatically created. For more information, see [Manage the service-linked roles of NAS](https://help.aliyun.com/document_detail/208530.html).
//
// @param request - CreateFileSystemRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateFileSystemResponse
func (client *Client) CreateFileSystemWithOptions(request *CreateFileSystemRequest, runtime *dara.RuntimeOptions) (_result *CreateFileSystemResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Bandwidth) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !dara.IsNil(request.Capacity) {
		query["Capacity"] = request.Capacity
	}

	if !dara.IsNil(request.ChargeType) {
		query["ChargeType"] = request.ChargeType
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.Duration) {
		query["Duration"] = request.Duration
	}

	if !dara.IsNil(request.EncryptType) {
		query["EncryptType"] = request.EncryptType
	}

	if !dara.IsNil(request.FileSystemType) {
		query["FileSystemType"] = request.FileSystemType
	}

	if !dara.IsNil(request.KmsKeyId) {
		query["KmsKeyId"] = request.KmsKeyId
	}

	if !dara.IsNil(request.ProtocolType) {
		query["ProtocolType"] = request.ProtocolType
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.SnapshotId) {
		query["SnapshotId"] = request.SnapshotId
	}

	if !dara.IsNil(request.StorageType) {
		query["StorageType"] = request.StorageType
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.VSwitchId) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	if !dara.IsNil(request.ZoneId) {
		query["ZoneId"] = request.ZoneId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateFileSystem"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Creates a file system.
//
// Description:
//
//	  Before you call this operation, you must understand the billing and pricing of File Storage NAS. For more information, see [Billing](https://help.aliyun.com/document_detail/178365.html) and [Pricing](https://www.alibabacloud.com/product/nas/pricing).
//
//		- Before you create a file system, you must complete real-name verification.
//
//		- When you call this operation, a service-linked role of NAS is automatically created. For more information, see [Manage the service-linked roles of NAS](https://help.aliyun.com/document_detail/208530.html).
//
// @param request - CreateFileSystemRequest
//
// @return CreateFileSystemResponse
func (client *Client) CreateFileSystem(request *CreateFileSystemRequest) (_result *CreateFileSystemResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CreateFileSystemWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a fileset.
//
// Description:
//
//	  Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.7.0 and later support this operation. You can view the version information on the file system details page in the console.
//
//		- A maximum of 500 filesets can be created for a CPFS file system.
//
//		- The fileset path must be a new path and cannot be an existing path. Fileset paths cannot be renamed and cannot be symbolic links.
//
//		- The maximum depth supported by a fileset path is eight levels. The depth of the root directory / is 0 levels. For example, the fileset path /test/aaa/ccc/ has three levels.
//
//		- If the fileset path is a multi-level path, the parent directory must be an existing directory.
//
//		- Nested filesets are not supported. If a fileset is specified as a parent directory, its subdirectory cannot be a fileset. A fileset path supports only one quota.
//
//		- The minimum capacity quota of a fileset is 10 GiB. The scaling step size is 1 GiB. The maximum capacity quota is 1,000 TiB. The capacity quota cannot exceed the total capacity of the file system.
//
//		- A fileset supports a minimum of 10,000 files or directories and a maximum of 10 billion files or directories. The scaling step size is 1.
//
//		- When you modify a directory quota, you must set the quota capacity or the number of files to be greater than the capacity or file quantity that has been used.
//
//		- The quota statistics have a 5-minute latency. The actual usage takes effect after 5 minutes.
//
// @param request - CreateFilesetRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateFilesetResponse
func (client *Client) CreateFilesetWithOptions(request *CreateFilesetRequest, runtime *dara.RuntimeOptions) (_result *CreateFilesetResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DeletionProtection) {
		query["DeletionProtection"] = request.DeletionProtection
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.FileSystemPath) {
		query["FileSystemPath"] = request.FileSystemPath
	}

	if !dara.IsNil(request.Quota) {
		query["Quota"] = request.Quota
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateFileset"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Creates a fileset.
//
// Description:
//
//	  Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.7.0 and later support this operation. You can view the version information on the file system details page in the console.
//
//		- A maximum of 500 filesets can be created for a CPFS file system.
//
//		- The fileset path must be a new path and cannot be an existing path. Fileset paths cannot be renamed and cannot be symbolic links.
//
//		- The maximum depth supported by a fileset path is eight levels. The depth of the root directory / is 0 levels. For example, the fileset path /test/aaa/ccc/ has three levels.
//
//		- If the fileset path is a multi-level path, the parent directory must be an existing directory.
//
//		- Nested filesets are not supported. If a fileset is specified as a parent directory, its subdirectory cannot be a fileset. A fileset path supports only one quota.
//
//		- The minimum capacity quota of a fileset is 10 GiB. The scaling step size is 1 GiB. The maximum capacity quota is 1,000 TiB. The capacity quota cannot exceed the total capacity of the file system.
//
//		- A fileset supports a minimum of 10,000 files or directories and a maximum of 10 billion files or directories. The scaling step size is 1.
//
//		- When you modify a directory quota, you must set the quota capacity or the number of files to be greater than the capacity or file quantity that has been used.
//
//		- The quota statistics have a 5-minute latency. The actual usage takes effect after 5 minutes.
//
// @param request - CreateFilesetRequest
//
// @return CreateFilesetResponse
func (client *Client) CreateFileset(request *CreateFilesetRequest) (_result *CreateFilesetResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CreateFilesetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Deprecated: OpenAPI CreateLDAPConfig is deprecated
//
// Summary:
//
// Creates LDAP configurations.
//
// @param request - CreateLDAPConfigRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateLDAPConfigResponse
// Deprecated
func (client *Client) CreateLDAPConfigWithOptions(request *CreateLDAPConfigRequest, runtime *dara.RuntimeOptions) (_result *CreateLDAPConfigResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.BindDN) {
		query["BindDN"] = request.BindDN
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.SearchBase) {
		query["SearchBase"] = request.SearchBase
	}

	if !dara.IsNil(request.URI) {
		query["URI"] = request.URI
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateLDAPConfig"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Deprecated: OpenAPI CreateLDAPConfig is deprecated
//
// Summary:
//
// Creates LDAP configurations.
//
// @param request - CreateLDAPConfigRequest
//
// @return CreateLDAPConfigResponse
// Deprecated
func (client *Client) CreateLDAPConfig(request *CreateLDAPConfigRequest) (_result *CreateLDAPConfigResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CreateLDAPConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a lifecycle policy.
//
// Description:
//
//	  You can create lifecycle policies only for General-purpose NAS file systems.
//
//		- You can create up to 20 lifecycle policies in each region within an Alibaba Cloud account.
//
// @param request - CreateLifecyclePolicyRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateLifecyclePolicyResponse
func (client *Client) CreateLifecyclePolicyWithOptions(request *CreateLifecyclePolicyRequest, runtime *dara.RuntimeOptions) (_result *CreateLifecyclePolicyResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.FsetIds) {
		query["FsetIds"] = request.FsetIds
	}

	if !dara.IsNil(request.LifecyclePolicyName) {
		query["LifecyclePolicyName"] = request.LifecyclePolicyName
	}

	if !dara.IsNil(request.LifecycleRuleInactiveDays) {
		query["LifecycleRuleInactiveDays"] = request.LifecycleRuleInactiveDays
	}

	if !dara.IsNil(request.LifecycleRuleName) {
		query["LifecycleRuleName"] = request.LifecycleRuleName
	}

	if !dara.IsNil(request.LifecycleRuleType) {
		query["LifecycleRuleType"] = request.LifecycleRuleType
	}

	if !dara.IsNil(request.Path) {
		query["Path"] = request.Path
	}

	if !dara.IsNil(request.Paths) {
		query["Paths"] = request.Paths
	}

	if !dara.IsNil(request.StorageType) {
		query["StorageType"] = request.StorageType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateLifecyclePolicy"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Creates a lifecycle policy.
//
// Description:
//
//	  You can create lifecycle policies only for General-purpose NAS file systems.
//
//		- You can create up to 20 lifecycle policies in each region within an Alibaba Cloud account.
//
// @param request - CreateLifecyclePolicyRequest
//
// @return CreateLifecyclePolicyResponse
func (client *Client) CreateLifecyclePolicy(request *CreateLifecyclePolicyRequest) (_result *CreateLifecyclePolicyResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CreateLifecyclePolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a data retrieval task.
//
// Description:
//
//	  Only General-purpose NAS file systems support this operation.
//
//		- You can run a maximum of 20 data retrieval tasks in each region within an Alibaba Cloud account.
//
// @param request - CreateLifecycleRetrieveJobRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateLifecycleRetrieveJobResponse
func (client *Client) CreateLifecycleRetrieveJobWithOptions(request *CreateLifecycleRetrieveJobRequest, runtime *dara.RuntimeOptions) (_result *CreateLifecycleRetrieveJobResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.Paths) {
		query["Paths"] = request.Paths
	}

	if !dara.IsNil(request.StorageType) {
		query["StorageType"] = request.StorageType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateLifecycleRetrieveJob"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Creates a data retrieval task.
//
// Description:
//
//	  Only General-purpose NAS file systems support this operation.
//
//		- You can run a maximum of 20 data retrieval tasks in each region within an Alibaba Cloud account.
//
// @param request - CreateLifecycleRetrieveJobRequest
//
// @return CreateLifecycleRetrieveJobResponse
func (client *Client) CreateLifecycleRetrieveJob(request *CreateLifecycleRetrieveJobRequest) (_result *CreateLifecycleRetrieveJobResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CreateLifecycleRetrieveJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Dumps the logs of a General-purpose NAS file system to Simple Log Service.
//
// @param request - CreateLogAnalysisRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateLogAnalysisResponse
func (client *Client) CreateLogAnalysisWithOptions(request *CreateLogAnalysisRequest, runtime *dara.RuntimeOptions) (_result *CreateLogAnalysisResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateLogAnalysis"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Dumps the logs of a General-purpose NAS file system to Simple Log Service.
//
// @param request - CreateLogAnalysisRequest
//
// @return CreateLogAnalysisResponse
func (client *Client) CreateLogAnalysis(request *CreateLogAnalysisRequest) (_result *CreateLogAnalysisResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CreateLogAnalysisWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a mount target.
//
// Description:
//
//	  After you call the CreateMountTarget operation, a mount target is not immediately created. Therefore, we recommend that you call the DescribeMountTargets operation to query the status of the mount target. If the mount target is in the **Active*	- state, you can then mount the file system. Otherwise, the file system may fail to be mounted.
//
//		- When you call this operation, a service-linked role of NAS is automatically created. For more information, see [Manage the service-linked roles of NAS](https://help.aliyun.com/document_detail/208530.html).
//
// @param request - CreateMountTargetRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateMountTargetResponse
func (client *Client) CreateMountTargetWithOptions(request *CreateMountTargetRequest, runtime *dara.RuntimeOptions) (_result *CreateMountTargetResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AccessGroupName) {
		query["AccessGroupName"] = request.AccessGroupName
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.EnableIpv6) {
		query["EnableIpv6"] = request.EnableIpv6
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.NetworkType) {
		query["NetworkType"] = request.NetworkType
	}

	if !dara.IsNil(request.SecurityGroupId) {
		query["SecurityGroupId"] = request.SecurityGroupId
	}

	if !dara.IsNil(request.VSwitchId) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateMountTarget"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Creates a mount target.
//
// Description:
//
//	  After you call the CreateMountTarget operation, a mount target is not immediately created. Therefore, we recommend that you call the DescribeMountTargets operation to query the status of the mount target. If the mount target is in the **Active*	- state, you can then mount the file system. Otherwise, the file system may fail to be mounted.
//
//		- When you call this operation, a service-linked role of NAS is automatically created. For more information, see [Manage the service-linked roles of NAS](https://help.aliyun.com/document_detail/208530.html).
//
// @param request - CreateMountTargetRequest
//
// @return CreateMountTargetResponse
func (client *Client) CreateMountTarget(request *CreateMountTargetRequest) (_result *CreateMountTargetResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CreateMountTargetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates an export directory for a protocol service.
//
// Description:
//
//	  This operation is available only to Cloud Parallel File Storage (CPFS) file systems on the China site (aliyun.com).
//
//		- Prerequisites
//
//	    A protocol service is created.
//
//		- Others
//
//	    	- The virtual private cloud (VPC) CIDR block of the export directory for the protocol service cannot overlap with the VPC CIDR block of the file system.
//
//	    	- The VPC CIDR blocks of multiple export directories of a protocol service cannot overlap.
//
//	    	- You can create a maximum of 10 export directories for a protocol service.
//
//	    	- When you create export directories for a protocol service, a maximum of 32 IP addresses that are allocated by the specified vSwitch are used. Make sure that the vSwitch can provide sufficient IP addresses.
//
// @param request - CreateProtocolMountTargetRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateProtocolMountTargetResponse
func (client *Client) CreateProtocolMountTargetWithOptions(request *CreateProtocolMountTargetRequest, runtime *dara.RuntimeOptions) (_result *CreateProtocolMountTargetResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AccessGroupName) {
		query["AccessGroupName"] = request.AccessGroupName
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.FsetId) {
		query["FsetId"] = request.FsetId
	}

	if !dara.IsNil(request.Path) {
		query["Path"] = request.Path
	}

	if !dara.IsNil(request.ProtocolServiceId) {
		query["ProtocolServiceId"] = request.ProtocolServiceId
	}

	if !dara.IsNil(request.VSwitchId) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateProtocolMountTarget"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Creates an export directory for a protocol service.
//
// Description:
//
//	  This operation is available only to Cloud Parallel File Storage (CPFS) file systems on the China site (aliyun.com).
//
//		- Prerequisites
//
//	    A protocol service is created.
//
//		- Others
//
//	    	- The virtual private cloud (VPC) CIDR block of the export directory for the protocol service cannot overlap with the VPC CIDR block of the file system.
//
//	    	- The VPC CIDR blocks of multiple export directories of a protocol service cannot overlap.
//
//	    	- You can create a maximum of 10 export directories for a protocol service.
//
//	    	- When you create export directories for a protocol service, a maximum of 32 IP addresses that are allocated by the specified vSwitch are used. Make sure that the vSwitch can provide sufficient IP addresses.
//
// @param request - CreateProtocolMountTargetRequest
//
// @return CreateProtocolMountTargetResponse
func (client *Client) CreateProtocolMountTarget(request *CreateProtocolMountTargetRequest) (_result *CreateProtocolMountTargetResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CreateProtocolMountTargetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a protocol service for a Cloud Parallel File Storage (CPFS) file system. The creation takes about 5 to 10 minutes.
//
// Description:
//
//	  This operation is available only to CPFS file systems on the China site (aliyun.com).
//
//		- Only CPFS V2.3.0 and later support protocol services. You can query the version information of the file system by calling the [DescribeFileSystems](~~2402188.~~) operation.
//
//		- Protocol service types
//
//	    Protocol services are classified into general-purpose protocol services and cache protocol services. Different from general-purpose protocol services, cache protocol services can cache hot data. If data exists in the cache, the bandwidth of the cache protocol service may exceed the bandwidth of the CPFS file system, reaching the maximum bandwidth specified for the protocol service.
//
//	    	- General-purpose protocol services: provide NFS access and [directory-level mount targets](https://help.aliyun.com/document_detail/427175.html) for CPFS file systems. You do not need to configure a POSIX client to manage clusters. General-purpose protocol services are provided free of charge.
//
//	    	- Cache protocol services: provide the server memory cache based on the least recently used (LRU) policy. When data is cached in the memory, CPFS provides higher internal bandwidth. Cache protocol services are divided into Cache L1 and Cache L2 specifications. The differences are the internal bandwidth size and memory cache size.
//
//	       >   Note You are charged for using cache protocol services, which are in invitational preview. For more information about the billing method of cache protocol services, see [Billable items](https://help.aliyun.com/document_detail/111858.html). If you have any feedback or questions, you can join the DingTalk group (group number: 31045006299).
//
//		- Protocol type
//
//	    Only NFSv3 is supported.
//
//		- Others
//
//	    	- Only one protocol service can be created for a CPFS file system.
//
//	    	- A protocol service can use a maximum of 32 IP addresses that are allocated by a specified vSwitch. Make sure that the vSwitch can provide sufficient IP addresses.
//
// @param request - CreateProtocolServiceRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateProtocolServiceResponse
func (client *Client) CreateProtocolServiceWithOptions(request *CreateProtocolServiceRequest, runtime *dara.RuntimeOptions) (_result *CreateProtocolServiceResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.MountTargetAccessGroupName) {
		query["MountTargetAccessGroupName"] = request.MountTargetAccessGroupName
	}

	if !dara.IsNil(request.MountTargetDescription) {
		query["MountTargetDescription"] = request.MountTargetDescription
	}

	if !dara.IsNil(request.MountTargetFsetId) {
		query["MountTargetFsetId"] = request.MountTargetFsetId
	}

	if !dara.IsNil(request.MountTargetPath) {
		query["MountTargetPath"] = request.MountTargetPath
	}

	if !dara.IsNil(request.MountTargetVSwitchId) {
		query["MountTargetVSwitchId"] = request.MountTargetVSwitchId
	}

	if !dara.IsNil(request.MountTargetVpcId) {
		query["MountTargetVpcId"] = request.MountTargetVpcId
	}

	if !dara.IsNil(request.ProtocolSpec) {
		query["ProtocolSpec"] = request.ProtocolSpec
	}

	if !dara.IsNil(request.ProtocolType) {
		query["ProtocolType"] = request.ProtocolType
	}

	if !dara.IsNil(request.Throughput) {
		query["Throughput"] = request.Throughput
	}

	if !dara.IsNil(request.VSwitchId) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateProtocolService"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Creates a protocol service for a Cloud Parallel File Storage (CPFS) file system. The creation takes about 5 to 10 minutes.
//
// Description:
//
//	  This operation is available only to CPFS file systems on the China site (aliyun.com).
//
//		- Only CPFS V2.3.0 and later support protocol services. You can query the version information of the file system by calling the [DescribeFileSystems](~~2402188.~~) operation.
//
//		- Protocol service types
//
//	    Protocol services are classified into general-purpose protocol services and cache protocol services. Different from general-purpose protocol services, cache protocol services can cache hot data. If data exists in the cache, the bandwidth of the cache protocol service may exceed the bandwidth of the CPFS file system, reaching the maximum bandwidth specified for the protocol service.
//
//	    	- General-purpose protocol services: provide NFS access and [directory-level mount targets](https://help.aliyun.com/document_detail/427175.html) for CPFS file systems. You do not need to configure a POSIX client to manage clusters. General-purpose protocol services are provided free of charge.
//
//	    	- Cache protocol services: provide the server memory cache based on the least recently used (LRU) policy. When data is cached in the memory, CPFS provides higher internal bandwidth. Cache protocol services are divided into Cache L1 and Cache L2 specifications. The differences are the internal bandwidth size and memory cache size.
//
//	       >   Note You are charged for using cache protocol services, which are in invitational preview. For more information about the billing method of cache protocol services, see [Billable items](https://help.aliyun.com/document_detail/111858.html). If you have any feedback or questions, you can join the DingTalk group (group number: 31045006299).
//
//		- Protocol type
//
//	    Only NFSv3 is supported.
//
//		- Others
//
//	    	- Only one protocol service can be created for a CPFS file system.
//
//	    	- A protocol service can use a maximum of 32 IP addresses that are allocated by a specified vSwitch. Make sure that the vSwitch can provide sufficient IP addresses.
//
// @param request - CreateProtocolServiceRequest
//
// @return CreateProtocolServiceResponse
func (client *Client) CreateProtocolService(request *CreateProtocolServiceRequest) (_result *CreateProtocolServiceResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CreateProtocolServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a job to permanently delete a file or directory from the recycle bin.
//
// Description:
//
//	  Only General-purpose NAS file systems support this operation.
//
//		- If you permanently delete a directory, the files in the directory are recursively cleared.
//
//		- You can run only one job at a time for a single file system to permanently delete the files from the file system. You cannot create a restoration or deletion job when a file or directory is being deleted.
//
// @param request - CreateRecycleBinDeleteJobRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateRecycleBinDeleteJobResponse
func (client *Client) CreateRecycleBinDeleteJobWithOptions(request *CreateRecycleBinDeleteJobRequest, runtime *dara.RuntimeOptions) (_result *CreateRecycleBinDeleteJobResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(dara.ToMap(request))
	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateRecycleBinDeleteJob"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("GET"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Creates a job to permanently delete a file or directory from the recycle bin.
//
// Description:
//
//	  Only General-purpose NAS file systems support this operation.
//
//		- If you permanently delete a directory, the files in the directory are recursively cleared.
//
//		- You can run only one job at a time for a single file system to permanently delete the files from the file system. You cannot create a restoration or deletion job when a file or directory is being deleted.
//
// @param request - CreateRecycleBinDeleteJobRequest
//
// @return CreateRecycleBinDeleteJobResponse
func (client *Client) CreateRecycleBinDeleteJob(request *CreateRecycleBinDeleteJobRequest) (_result *CreateRecycleBinDeleteJobResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CreateRecycleBinDeleteJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Restores a file or directory from the recycle bin.
//
// Description:
//
// ### Usage notes
//
//   - Only General-purpose NAS file systems support this operation.
//
//   - You can run only one job at a time for a single file system to restore files to or clear files from the file system. You cannot create a restore or cleanup job when files are being restored from the recycle bin.
//
//   - You can restore only one file or directory in a single restore job. If you restore a specified directory, all files in the directory are recursively restored.
//
//   - After files are restored, the data of the files is defragmented. When the data is being defragmented, the read performance is slightly degraded.
//
// @param request - CreateRecycleBinRestoreJobRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateRecycleBinRestoreJobResponse
func (client *Client) CreateRecycleBinRestoreJobWithOptions(request *CreateRecycleBinRestoreJobRequest, runtime *dara.RuntimeOptions) (_result *CreateRecycleBinRestoreJobResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(dara.ToMap(request))
	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateRecycleBinRestoreJob"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("GET"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Restores a file or directory from the recycle bin.
//
// Description:
//
// ### Usage notes
//
//   - Only General-purpose NAS file systems support this operation.
//
//   - You can run only one job at a time for a single file system to restore files to or clear files from the file system. You cannot create a restore or cleanup job when files are being restored from the recycle bin.
//
//   - You can restore only one file or directory in a single restore job. If you restore a specified directory, all files in the directory are recursively restored.
//
//   - After files are restored, the data of the files is defragmented. When the data is being defragmented, the read performance is slightly degraded.
//
// @param request - CreateRecycleBinRestoreJobRequest
//
// @return CreateRecycleBinRestoreJobResponse
func (client *Client) CreateRecycleBinRestoreJob(request *CreateRecycleBinRestoreJobRequest) (_result *CreateRecycleBinRestoreJobResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CreateRecycleBinRestoreJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 从控制台为用户补创缺失SLR
//
// @param request - CreateServicePolicyRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateServicePolicyResponse
func (client *Client) CreateServicePolicyWithOptions(request *CreateServicePolicyRequest, runtime *dara.RuntimeOptions) (_result *CreateServicePolicyResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ServiceLinkedRoleName) {
		query["ServiceLinkedRoleName"] = request.ServiceLinkedRoleName
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateServicePolicy"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// 从控制台为用户补创缺失SLR
//
// @param request - CreateServicePolicyRequest
//
// @return CreateServicePolicyResponse
func (client *Client) CreateServicePolicy(request *CreateServicePolicyRequest) (_result *CreateServicePolicyResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CreateServicePolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a snapshot.
//
// Description:
//
//	  The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
//
//		- Only advanced Extreme NAS file systems support the snapshot feature.
//
//		- You can create a maximum of 128 snapshots for a file system.
//
//		- The compute node on which a file system is mounted must function as expected. Otherwise, you cannot create a snapshot for the file system.
//
//		- You can create only one snapshot for a file system at a time.
//
//		- If the file system expires when a snapshot is being created, the file system is released and the snapshot is deleted.
//
//		- When you create a snapshot for a file system, the I/O performance of the file system may be degraded for a short period of time. We recommend that you create snapshots during off-peak hours.
//
//		- A snapshot is a backup of a file system at a specific point in time. After you create a snapshot, incremental data that is generated in the file system will not be synchronized to the snapshot.
//
//		- Manually created snapshots will not be deleted until 15 days after the service is suspended due to overdue payments. We recommend that you delete unnecessary snapshots at regular intervals to prevent extra fees incurred by the snapshots.
//
// @param request - CreateSnapshotRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateSnapshotResponse
func (client *Client) CreateSnapshotWithOptions(request *CreateSnapshotRequest, runtime *dara.RuntimeOptions) (_result *CreateSnapshotResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.RetentionDays) {
		query["RetentionDays"] = request.RetentionDays
	}

	if !dara.IsNil(request.SnapshotName) {
		query["SnapshotName"] = request.SnapshotName
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateSnapshot"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Creates a snapshot.
//
// Description:
//
//	  The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
//
//		- Only advanced Extreme NAS file systems support the snapshot feature.
//
//		- You can create a maximum of 128 snapshots for a file system.
//
//		- The compute node on which a file system is mounted must function as expected. Otherwise, you cannot create a snapshot for the file system.
//
//		- You can create only one snapshot for a file system at a time.
//
//		- If the file system expires when a snapshot is being created, the file system is released and the snapshot is deleted.
//
//		- When you create a snapshot for a file system, the I/O performance of the file system may be degraded for a short period of time. We recommend that you create snapshots during off-peak hours.
//
//		- A snapshot is a backup of a file system at a specific point in time. After you create a snapshot, incremental data that is generated in the file system will not be synchronized to the snapshot.
//
//		- Manually created snapshots will not be deleted until 15 days after the service is suspended due to overdue payments. We recommend that you delete unnecessary snapshots at regular intervals to prevent extra fees incurred by the snapshots.
//
// @param request - CreateSnapshotRequest
//
// @return CreateSnapshotResponse
func (client *Client) CreateSnapshot(request *CreateSnapshotRequest) (_result *CreateSnapshotResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CreateSnapshotWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 创建 VSC 挂载点
//
// @param request - CreateVscMountPointRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateVscMountPointResponse
func (client *Client) CreateVscMountPointWithOptions(request *CreateVscMountPointRequest, runtime *dara.RuntimeOptions) (_result *CreateVscMountPointResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("CreateVscMountPoint"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// 创建 VSC 挂载点
//
// @param request - CreateVscMountPointRequest
//
// @return CreateVscMountPointResponse
func (client *Client) CreateVscMountPoint(request *CreateVscMountPointRequest) (_result *CreateVscMountPointResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.CreateVscMountPointWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a permission group.
//
// Description:
//
// The default permission group (DEFAULT_VPC_GROUP_NAME) cannot be deleted.
//
// @param request - DeleteAccessGroupRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteAccessGroupResponse
func (client *Client) DeleteAccessGroupWithOptions(request *DeleteAccessGroupRequest, runtime *dara.RuntimeOptions) (_result *DeleteAccessGroupResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AccessGroupName) {
		query["AccessGroupName"] = request.AccessGroupName
	}

	if !dara.IsNil(request.FileSystemType) {
		query["FileSystemType"] = request.FileSystemType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteAccessGroup"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes a permission group.
//
// Description:
//
// The default permission group (DEFAULT_VPC_GROUP_NAME) cannot be deleted.
//
// @param request - DeleteAccessGroupRequest
//
// @return DeleteAccessGroupResponse
func (client *Client) DeleteAccessGroup(request *DeleteAccessGroupRequest) (_result *DeleteAccessGroupResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DeleteAccessGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an access point.
//
// Description:
//
//	  Only General-purpose Network File System (NFS) file systems support access points.
//
//		- After an access point is deleted, all I/O operations that are being performed on the directory accessed over the access point are interrupted immediately. Exercise caution when you perform this operation.
//
// @param request - DeleteAccessPointRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteAccessPointResponse
func (client *Client) DeleteAccessPointWithOptions(request *DeleteAccessPointRequest, runtime *dara.RuntimeOptions) (_result *DeleteAccessPointResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AccessPointId) {
		query["AccessPointId"] = request.AccessPointId
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteAccessPoint"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes an access point.
//
// Description:
//
//	  Only General-purpose Network File System (NFS) file systems support access points.
//
//		- After an access point is deleted, all I/O operations that are being performed on the directory accessed over the access point are interrupted immediately. Exercise caution when you perform this operation.
//
// @param request - DeleteAccessPointRequest
//
// @return DeleteAccessPointResponse
func (client *Client) DeleteAccessPoint(request *DeleteAccessPointRequest) (_result *DeleteAccessPointResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DeleteAccessPointWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a rule from a permission group.
//
// Description:
//
// Rules in the default permission group (DEFAULT_VPC_GROUP_NAME) cannot be deleted.
//
// @param request - DeleteAccessRuleRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteAccessRuleResponse
func (client *Client) DeleteAccessRuleWithOptions(request *DeleteAccessRuleRequest, runtime *dara.RuntimeOptions) (_result *DeleteAccessRuleResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AccessGroupName) {
		query["AccessGroupName"] = request.AccessGroupName
	}

	if !dara.IsNil(request.AccessRuleId) {
		query["AccessRuleId"] = request.AccessRuleId
	}

	if !dara.IsNil(request.FileSystemType) {
		query["FileSystemType"] = request.FileSystemType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteAccessRule"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes a rule from a permission group.
//
// Description:
//
// Rules in the default permission group (DEFAULT_VPC_GROUP_NAME) cannot be deleted.
//
// @param request - DeleteAccessRuleRequest
//
// @return DeleteAccessRuleResponse
func (client *Client) DeleteAccessRule(request *DeleteAccessRuleRequest) (_result *DeleteAccessRuleResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DeleteAccessRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an automatic snapshot policy.
//
// Description:
//
//	  The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
//
//		- Only advanced Extreme NAS file systems support the snapshot feature.
//
//		- If you delete an automatic snapshot policy that is applied to a file system, snapshots for the file system are no longer created based on the policy.
//
// @param request - DeleteAutoSnapshotPolicyRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteAutoSnapshotPolicyResponse
func (client *Client) DeleteAutoSnapshotPolicyWithOptions(request *DeleteAutoSnapshotPolicyRequest, runtime *dara.RuntimeOptions) (_result *DeleteAutoSnapshotPolicyResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AutoSnapshotPolicyId) {
		query["AutoSnapshotPolicyId"] = request.AutoSnapshotPolicyId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteAutoSnapshotPolicy"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes an automatic snapshot policy.
//
// Description:
//
//	  The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
//
//		- Only advanced Extreme NAS file systems support the snapshot feature.
//
//		- If you delete an automatic snapshot policy that is applied to a file system, snapshots for the file system are no longer created based on the policy.
//
// @param request - DeleteAutoSnapshotPolicyRequest
//
// @return DeleteAutoSnapshotPolicyResponse
func (client *Client) DeleteAutoSnapshotPolicy(request *DeleteAutoSnapshotPolicyRequest) (_result *DeleteAutoSnapshotPolicyResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DeleteAutoSnapshotPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a dataflow.
//
// Description:
//
//	  Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.4.0 and later support data flows. You can view the version information on the file system details page in the console.
//
//		- You can delete the data flows that are only in the `Running` or `Stopped` state.
//
//		- After a data flow is deleted, the resources related to the data flow are released and cannot be restored. You must create a data flow again if required.
//
// @param request - DeleteDataFlowRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteDataFlowResponse
func (client *Client) DeleteDataFlowWithOptions(request *DeleteDataFlowRequest, runtime *dara.RuntimeOptions) (_result *DeleteDataFlowResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DataFlowId) {
		query["DataFlowId"] = request.DataFlowId
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteDataFlow"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes a dataflow.
//
// Description:
//
//	  Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.4.0 and later support data flows. You can view the version information on the file system details page in the console.
//
//		- You can delete the data flows that are only in the `Running` or `Stopped` state.
//
//		- After a data flow is deleted, the resources related to the data flow are released and cannot be restored. You must create a data flow again if required.
//
// @param request - DeleteDataFlowRequest
//
// @return DeleteDataFlowResponse
func (client *Client) DeleteDataFlow(request *DeleteDataFlowRequest) (_result *DeleteDataFlowResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DeleteDataFlowWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a file system.
//
// Description:
//
//	  Before you delete a file system, you must delete all mount targets of the file system.
//
//		- Before you delete a file system, you must make sure that no lifecycle policy is created for the file system.
//
//		- After a file system is deleted, the data on the file system cannot be restored. Proceed with caution.
//
// @param request - DeleteFileSystemRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteFileSystemResponse
func (client *Client) DeleteFileSystemWithOptions(request *DeleteFileSystemRequest, runtime *dara.RuntimeOptions) (_result *DeleteFileSystemResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteFileSystem"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes a file system.
//
// Description:
//
//	  Before you delete a file system, you must delete all mount targets of the file system.
//
//		- Before you delete a file system, you must make sure that no lifecycle policy is created for the file system.
//
//		- After a file system is deleted, the data on the file system cannot be restored. Proceed with caution.
//
// @param request - DeleteFileSystemRequest
//
// @return DeleteFileSystemResponse
func (client *Client) DeleteFileSystem(request *DeleteFileSystemRequest) (_result *DeleteFileSystemResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DeleteFileSystemWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a fileset.
//
// Description:
//
//	  Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.7.0 and later support this operation. After you delete a fileset, all data in the fileset is deleted and cannot be restored. Proceed with caution.
//
//		- If deletion protection is enabled for the fileset, you must disable deletion protection before you delete the fileset.
//
// @param request - DeleteFilesetRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteFilesetResponse
func (client *Client) DeleteFilesetWithOptions(request *DeleteFilesetRequest, runtime *dara.RuntimeOptions) (_result *DeleteFilesetResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.FsetId) {
		query["FsetId"] = request.FsetId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteFileset"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes a fileset.
//
// Description:
//
//	  Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.7.0 and later support this operation. After you delete a fileset, all data in the fileset is deleted and cannot be restored. Proceed with caution.
//
//		- If deletion protection is enabled for the fileset, you must disable deletion protection before you delete the fileset.
//
// @param request - DeleteFilesetRequest
//
// @return DeleteFilesetResponse
func (client *Client) DeleteFileset(request *DeleteFilesetRequest) (_result *DeleteFilesetResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DeleteFilesetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Deprecated: OpenAPI DeleteLDAPConfig is deprecated
//
// Summary:
//
// 删除LDAP配置
//
// @param request - DeleteLDAPConfigRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteLDAPConfigResponse
// Deprecated
func (client *Client) DeleteLDAPConfigWithOptions(request *DeleteLDAPConfigRequest, runtime *dara.RuntimeOptions) (_result *DeleteLDAPConfigResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteLDAPConfig"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Deprecated: OpenAPI DeleteLDAPConfig is deprecated
//
// Summary:
//
// 删除LDAP配置
//
// @param request - DeleteLDAPConfigRequest
//
// @return DeleteLDAPConfigResponse
// Deprecated
func (client *Client) DeleteLDAPConfig(request *DeleteLDAPConfigRequest) (_result *DeleteLDAPConfigResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DeleteLDAPConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a lifecycle policy.
//
// Description:
//
// Only General-purpose NAS file systems support this operation.
//
// @param request - DeleteLifecyclePolicyRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteLifecyclePolicyResponse
func (client *Client) DeleteLifecyclePolicyWithOptions(request *DeleteLifecyclePolicyRequest, runtime *dara.RuntimeOptions) (_result *DeleteLifecyclePolicyResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.LifecyclePolicyName) {
		query["LifecyclePolicyName"] = request.LifecyclePolicyName
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteLifecyclePolicy"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes a lifecycle policy.
//
// Description:
//
// Only General-purpose NAS file systems support this operation.
//
// @param request - DeleteLifecyclePolicyRequest
//
// @return DeleteLifecyclePolicyResponse
func (client *Client) DeleteLifecyclePolicy(request *DeleteLifecyclePolicyRequest) (_result *DeleteLifecyclePolicyResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DeleteLifecyclePolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Disables log dumping for a General-purpose NAS file system.
//
// @param request - DeleteLogAnalysisRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteLogAnalysisResponse
func (client *Client) DeleteLogAnalysisWithOptions(request *DeleteLogAnalysisRequest, runtime *dara.RuntimeOptions) (_result *DeleteLogAnalysisResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteLogAnalysis"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Disables log dumping for a General-purpose NAS file system.
//
// @param request - DeleteLogAnalysisRequest
//
// @return DeleteLogAnalysisResponse
func (client *Client) DeleteLogAnalysis(request *DeleteLogAnalysisRequest) (_result *DeleteLogAnalysisResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DeleteLogAnalysisWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a mount target.
//
// Description:
//
// After you delete a mount target, the mount target cannot be restored. Proceed with caution.
//
// @param request - DeleteMountTargetRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteMountTargetResponse
func (client *Client) DeleteMountTargetWithOptions(request *DeleteMountTargetRequest, runtime *dara.RuntimeOptions) (_result *DeleteMountTargetResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.MountTargetDomain) {
		query["MountTargetDomain"] = request.MountTargetDomain
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteMountTarget"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes a mount target.
//
// Description:
//
// After you delete a mount target, the mount target cannot be restored. Proceed with caution.
//
// @param request - DeleteMountTargetRequest
//
// @return DeleteMountTargetResponse
func (client *Client) DeleteMountTarget(request *DeleteMountTargetRequest) (_result *DeleteMountTargetResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DeleteMountTargetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an export directory of a protocol service.
//
// Description:
//
// This operation is available only to Cloud Parallel File Storage (CPFS) file systems on the China site (aliyun.com).
//
// @param request - DeleteProtocolMountTargetRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteProtocolMountTargetResponse
func (client *Client) DeleteProtocolMountTargetWithOptions(request *DeleteProtocolMountTargetRequest, runtime *dara.RuntimeOptions) (_result *DeleteProtocolMountTargetResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.ExportId) {
		query["ExportId"] = request.ExportId
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.ProtocolServiceId) {
		query["ProtocolServiceId"] = request.ProtocolServiceId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteProtocolMountTarget"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes an export directory of a protocol service.
//
// Description:
//
// This operation is available only to Cloud Parallel File Storage (CPFS) file systems on the China site (aliyun.com).
//
// @param request - DeleteProtocolMountTargetRequest
//
// @return DeleteProtocolMountTargetResponse
func (client *Client) DeleteProtocolMountTarget(request *DeleteProtocolMountTargetRequest) (_result *DeleteProtocolMountTargetResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DeleteProtocolMountTargetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a protocol service of a Cloud Parallel File Storage (CPFS) file system.
//
// Description:
//
//	  This operation is available only to CPFS file systems on the China site (aliyun.com).
//
//		- When you delete a protocol service, the export directories in the protocol service are also deleted.
//
// @param request - DeleteProtocolServiceRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteProtocolServiceResponse
func (client *Client) DeleteProtocolServiceWithOptions(request *DeleteProtocolServiceRequest, runtime *dara.RuntimeOptions) (_result *DeleteProtocolServiceResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.ProtocolServiceId) {
		query["ProtocolServiceId"] = request.ProtocolServiceId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteProtocolService"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes a protocol service of a Cloud Parallel File Storage (CPFS) file system.
//
// Description:
//
//	  This operation is available only to CPFS file systems on the China site (aliyun.com).
//
//		- When you delete a protocol service, the export directories in the protocol service are also deleted.
//
// @param request - DeleteProtocolServiceRequest
//
// @return DeleteProtocolServiceResponse
func (client *Client) DeleteProtocolService(request *DeleteProtocolServiceRequest) (_result *DeleteProtocolServiceResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DeleteProtocolServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a snapshot or cancels a snapshot that is being created.
//
// Description:
//
//	  The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
//
//		- Only advanced Extreme NAS file systems support this feature.
//
// @param request - DeleteSnapshotRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteSnapshotResponse
func (client *Client) DeleteSnapshotWithOptions(request *DeleteSnapshotRequest, runtime *dara.RuntimeOptions) (_result *DeleteSnapshotResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.SnapshotId) {
		query["SnapshotId"] = request.SnapshotId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteSnapshot"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes a snapshot or cancels a snapshot that is being created.
//
// Description:
//
//	  The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
//
//		- Only advanced Extreme NAS file systems support this feature.
//
// @param request - DeleteSnapshotRequest
//
// @return DeleteSnapshotResponse
func (client *Client) DeleteSnapshot(request *DeleteSnapshotRequest) (_result *DeleteSnapshotResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DeleteSnapshotWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 删除 VSC 挂载点
//
// @param request - DeleteVscMountPointRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteVscMountPointResponse
func (client *Client) DeleteVscMountPointWithOptions(request *DeleteVscMountPointRequest, runtime *dara.RuntimeOptions) (_result *DeleteVscMountPointResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.MountPointDomain) {
		query["MountPointDomain"] = request.MountPointDomain
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DeleteVscMountPoint"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// 删除 VSC 挂载点
//
// @param request - DeleteVscMountPointRequest
//
// @return DeleteVscMountPointResponse
func (client *Client) DeleteVscMountPoint(request *DeleteVscMountPointRequest) (_result *DeleteVscMountPointResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DeleteVscMountPointWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries permission groups.
//
// @param request - DescribeAccessGroupsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeAccessGroupsResponse
func (client *Client) DescribeAccessGroupsWithOptions(request *DescribeAccessGroupsRequest, runtime *dara.RuntimeOptions) (_result *DescribeAccessGroupsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AccessGroupName) {
		query["AccessGroupName"] = request.AccessGroupName
	}

	if !dara.IsNil(request.FileSystemType) {
		query["FileSystemType"] = request.FileSystemType
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.UseUTCDateTime) {
		query["UseUTCDateTime"] = request.UseUTCDateTime
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeAccessGroups"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries permission groups.
//
// @param request - DescribeAccessGroupsRequest
//
// @return DescribeAccessGroupsResponse
func (client *Client) DescribeAccessGroups(request *DescribeAccessGroupsRequest) (_result *DescribeAccessGroupsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeAccessGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the details of an access point.
//
// Description:
//
// Only General-purpose Network File System (NFS) file systems support this operation.
//
// @param request - DescribeAccessPointRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeAccessPointResponse
func (client *Client) DescribeAccessPointWithOptions(request *DescribeAccessPointRequest, runtime *dara.RuntimeOptions) (_result *DescribeAccessPointResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AccessPointId) {
		query["AccessPointId"] = request.AccessPointId
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeAccessPoint"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the details of an access point.
//
// Description:
//
// Only General-purpose Network File System (NFS) file systems support this operation.
//
// @param request - DescribeAccessPointRequest
//
// @return DescribeAccessPointResponse
func (client *Client) DescribeAccessPoint(request *DescribeAccessPointRequest) (_result *DescribeAccessPointResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeAccessPointWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the information about an access point.
//
// Description:
//
// Only General-purpose Network File System (NFS) file systems support this operation.
//
// @param request - DescribeAccessPointsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeAccessPointsResponse
func (client *Client) DescribeAccessPointsWithOptions(request *DescribeAccessPointsRequest, runtime *dara.RuntimeOptions) (_result *DescribeAccessPointsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AccessGroup) {
		query["AccessGroup"] = request.AccessGroup
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeAccessPoints"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the information about an access point.
//
// Description:
//
// Only General-purpose Network File System (NFS) file systems support this operation.
//
// @param request - DescribeAccessPointsRequest
//
// @return DescribeAccessPointsResponse
func (client *Client) DescribeAccessPoints(request *DescribeAccessPointsRequest) (_result *DescribeAccessPointsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeAccessPointsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the information about rules in a permission group.
//
// @param request - DescribeAccessRulesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeAccessRulesResponse
func (client *Client) DescribeAccessRulesWithOptions(request *DescribeAccessRulesRequest, runtime *dara.RuntimeOptions) (_result *DescribeAccessRulesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AccessGroupName) {
		query["AccessGroupName"] = request.AccessGroupName
	}

	if !dara.IsNil(request.AccessRuleId) {
		query["AccessRuleId"] = request.AccessRuleId
	}

	if !dara.IsNil(request.FileSystemType) {
		query["FileSystemType"] = request.FileSystemType
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.SourceCidrIp) {
		query["SourceCidrIp"] = request.SourceCidrIp
	}

	if !dara.IsNil(request.SourceCidrIpFilter) {
		query["SourceCidrIpFilter"] = request.SourceCidrIpFilter
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeAccessRules"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the information about rules in a permission group.
//
// @param request - DescribeAccessRulesRequest
//
// @return DescribeAccessRulesResponse
func (client *Client) DescribeAccessRules(request *DescribeAccessRulesRequest) (_result *DescribeAccessRulesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeAccessRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries automatic snapshot policies.
//
// Description:
//
//	  The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
//
//		- Only advanced Extreme NAS file systems support this feature.
//
// @param request - DescribeAutoSnapshotPoliciesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeAutoSnapshotPoliciesResponse
func (client *Client) DescribeAutoSnapshotPoliciesWithOptions(request *DescribeAutoSnapshotPoliciesRequest, runtime *dara.RuntimeOptions) (_result *DescribeAutoSnapshotPoliciesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AutoSnapshotPolicyId) {
		query["AutoSnapshotPolicyId"] = request.AutoSnapshotPolicyId
	}

	if !dara.IsNil(request.FileSystemType) {
		query["FileSystemType"] = request.FileSystemType
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeAutoSnapshotPolicies"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries automatic snapshot policies.
//
// Description:
//
//	  The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
//
//		- Only advanced Extreme NAS file systems support this feature.
//
// @param request - DescribeAutoSnapshotPoliciesRequest
//
// @return DescribeAutoSnapshotPoliciesResponse
func (client *Client) DescribeAutoSnapshotPolicies(request *DescribeAutoSnapshotPoliciesRequest) (_result *DescribeAutoSnapshotPoliciesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeAutoSnapshotPoliciesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries automatic snapshot tasks.
//
// Description:
//
//	  The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
//
//		- Only advanced Extreme NAS file systems support the snapshot feature.
//
// @param request - DescribeAutoSnapshotTasksRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeAutoSnapshotTasksResponse
func (client *Client) DescribeAutoSnapshotTasksWithOptions(request *DescribeAutoSnapshotTasksRequest, runtime *dara.RuntimeOptions) (_result *DescribeAutoSnapshotTasksResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AutoSnapshotPolicyIds) {
		query["AutoSnapshotPolicyIds"] = request.AutoSnapshotPolicyIds
	}

	if !dara.IsNil(request.FileSystemIds) {
		query["FileSystemIds"] = request.FileSystemIds
	}

	if !dara.IsNil(request.FileSystemType) {
		query["FileSystemType"] = request.FileSystemType
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeAutoSnapshotTasks"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries automatic snapshot tasks.
//
// Description:
//
//	  The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
//
//		- Only advanced Extreme NAS file systems support the snapshot feature.
//
// @param request - DescribeAutoSnapshotTasksRequest
//
// @return DescribeAutoSnapshotTasksResponse
func (client *Client) DescribeAutoSnapshotTasks(request *DescribeAutoSnapshotTasksRequest) (_result *DescribeAutoSnapshotTasksResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeAutoSnapshotTasksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Deprecated: OpenAPI DescribeBlackListClients is deprecated
//
// Summary:
//
// 获取CPFS服务中黑名单客户端的状态
//
// Description:
//
// The API operation is available only for CPFS file systems.
//
// @param request - DescribeBlackListClientsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeBlackListClientsResponse
// Deprecated
func (client *Client) DescribeBlackListClientsWithOptions(request *DescribeBlackListClientsRequest, runtime *dara.RuntimeOptions) (_result *DescribeBlackListClientsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientIP) {
		query["ClientIP"] = request.ClientIP
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeBlackListClients"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Deprecated: OpenAPI DescribeBlackListClients is deprecated
//
// Summary:
//
// 获取CPFS服务中黑名单客户端的状态
//
// Description:
//
// The API operation is available only for CPFS file systems.
//
// @param request - DescribeBlackListClientsRequest
//
// @return DescribeBlackListClientsResponse
// Deprecated
func (client *Client) DescribeBlackListClients(request *DescribeBlackListClientsRequest) (_result *DescribeBlackListClientsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeBlackListClientsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries data flow subtasks in batches.
//
// Description:
//
// Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.6.0 and later support this operation. You can view the version information on the file system details page in the console.
//
// @param request - DescribeDataFlowSubTasksRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeDataFlowSubTasksResponse
func (client *Client) DescribeDataFlowSubTasksWithOptions(request *DescribeDataFlowSubTasksRequest, runtime *dara.RuntimeOptions) (_result *DescribeDataFlowSubTasksResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.Filters) {
		query["Filters"] = request.Filters
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeDataFlowSubTasks"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries data flow subtasks in batches.
//
// Description:
//
// Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.6.0 and later support this operation. You can view the version information on the file system details page in the console.
//
// @param request - DescribeDataFlowSubTasksRequest
//
// @return DescribeDataFlowSubTasksResponse
func (client *Client) DescribeDataFlowSubTasks(request *DescribeDataFlowSubTasksRequest) (_result *DescribeDataFlowSubTasksResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeDataFlowSubTasksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the details of data flow tasks.
//
// Description:
//
// Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.4.0 and later support query of data flow tasks. You can view the version information on the file system details page in the console.
//
// @param request - DescribeDataFlowTasksRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeDataFlowTasksResponse
func (client *Client) DescribeDataFlowTasksWithOptions(request *DescribeDataFlowTasksRequest, runtime *dara.RuntimeOptions) (_result *DescribeDataFlowTasksResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.Filters) {
		query["Filters"] = request.Filters
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeDataFlowTasks"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the details of data flow tasks.
//
// Description:
//
// Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.4.0 and later support query of data flow tasks. You can view the version information on the file system details page in the console.
//
// @param request - DescribeDataFlowTasksRequest
//
// @return DescribeDataFlowTasksResponse
func (client *Client) DescribeDataFlowTasks(request *DescribeDataFlowTasksRequest) (_result *DescribeDataFlowTasksResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeDataFlowTasksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the dataflows of a CPFS file system.
//
// Description:
//
//	  Only CPFS for LINGJUN V2.4.0 and later support data flows. You can view the version information on the file system details page in the console.
//
//		- In Filters, FsetIds, DataFlowlds, SourceStorage, ThroughputList, and Status support exact match only. FileSystemPath, Description, and SourceStoragePath support fuzzy match.
//
//		- Combined query is supported.
//
// @param request - DescribeDataFlowsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeDataFlowsResponse
func (client *Client) DescribeDataFlowsWithOptions(request *DescribeDataFlowsRequest, runtime *dara.RuntimeOptions) (_result *DescribeDataFlowsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.Filters) {
		query["Filters"] = request.Filters
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeDataFlows"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the dataflows of a CPFS file system.
//
// Description:
//
//	  Only CPFS for LINGJUN V2.4.0 and later support data flows. You can view the version information on the file system details page in the console.
//
//		- In Filters, FsetIds, DataFlowlds, SourceStorage, ThroughputList, and Status support exact match only. FileSystemPath, Description, and SourceStoragePath support fuzzy match.
//
//		- Combined query is supported.
//
// @param request - DescribeDataFlowsRequest
//
// @return DescribeDataFlowsResponse
func (client *Client) DescribeDataFlows(request *DescribeDataFlowsRequest) (_result *DescribeDataFlowsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeDataFlowsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the directory quotas of a file system.
//
// Description:
//
// Only General-purpose NAS file systems support the directory quota feature.
//
// @param request - DescribeDirQuotasRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeDirQuotasResponse
func (client *Client) DescribeDirQuotasWithOptions(request *DescribeDirQuotasRequest, runtime *dara.RuntimeOptions) (_result *DescribeDirQuotasResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.Path) {
		query["Path"] = request.Path
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeDirQuotas"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the directory quotas of a file system.
//
// Description:
//
// Only General-purpose NAS file systems support the directory quota feature.
//
// @param request - DescribeDirQuotasRequest
//
// @return DescribeDirQuotasResponse
func (client *Client) DescribeDirQuotas(request *DescribeDirQuotasRequest) (_result *DescribeDirQuotasResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeDirQuotasWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 获取文件系统列表简要信息
//
// @param request - DescribeFileSystemBriefInfosRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeFileSystemBriefInfosResponse
func (client *Client) DescribeFileSystemBriefInfosWithOptions(request *DescribeFileSystemBriefInfosRequest, runtime *dara.RuntimeOptions) (_result *DescribeFileSystemBriefInfosResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.FileSystemType) {
		query["FileSystemType"] = request.FileSystemType
	}

	if !dara.IsNil(request.OrderByField) {
		query["OrderByField"] = request.OrderByField
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.SortOrder) {
		query["SortOrder"] = request.SortOrder
	}

	if !dara.IsNil(request.StorageType) {
		query["StorageType"] = request.StorageType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeFileSystemBriefInfos"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// 获取文件系统列表简要信息
//
// @param request - DescribeFileSystemBriefInfosRequest
//
// @return DescribeFileSystemBriefInfosResponse
func (client *Client) DescribeFileSystemBriefInfos(request *DescribeFileSystemBriefInfosRequest) (_result *DescribeFileSystemBriefInfosResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeFileSystemBriefInfosWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Deprecated: OpenAPI DescribeFileSystemStatistics is deprecated, please use NAS::2017-06-26::DescribeResourceStatistics instead.
//
// Summary:
//
// Queries the statistics of file systems that are owned by the current account.
//
// @param request - DescribeFileSystemStatisticsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeFileSystemStatisticsResponse
// Deprecated
func (client *Client) DescribeFileSystemStatisticsWithOptions(request *DescribeFileSystemStatisticsRequest, runtime *dara.RuntimeOptions) (_result *DescribeFileSystemStatisticsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeFileSystemStatistics"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Deprecated: OpenAPI DescribeFileSystemStatistics is deprecated, please use NAS::2017-06-26::DescribeResourceStatistics instead.
//
// Summary:
//
// Queries the statistics of file systems that are owned by the current account.
//
// @param request - DescribeFileSystemStatisticsRequest
//
// @return DescribeFileSystemStatisticsResponse
// Deprecated
func (client *Client) DescribeFileSystemStatistics(request *DescribeFileSystemStatisticsRequest) (_result *DescribeFileSystemStatisticsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeFileSystemStatisticsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries file systems.
//
// @param request - DescribeFileSystemsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeFileSystemsResponse
func (client *Client) DescribeFileSystemsWithOptions(request *DescribeFileSystemsRequest, runtime *dara.RuntimeOptions) (_result *DescribeFileSystemsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ChargeType) {
		query["ChargeType"] = request.ChargeType
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.FileSystemIds) {
		query["FileSystemIds"] = request.FileSystemIds
	}

	if !dara.IsNil(request.FileSystemType) {
		query["FileSystemType"] = request.FileSystemType
	}

	if !dara.IsNil(request.OrderByField) {
		query["OrderByField"] = request.OrderByField
	}

	if !dara.IsNil(request.PackageIds) {
		query["PackageIds"] = request.PackageIds
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.ResourceGroupId) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !dara.IsNil(request.SortOrder) {
		query["SortOrder"] = request.SortOrder
	}

	if !dara.IsNil(request.StorageType) {
		query["StorageType"] = request.StorageType
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	if !dara.IsNil(request.UseUTCDateTime) {
		query["UseUTCDateTime"] = request.UseUTCDateTime
	}

	if !dara.IsNil(request.VpcId) {
		query["VpcId"] = request.VpcId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeFileSystems"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries file systems.
//
// @param request - DescribeFileSystemsRequest
//
// @return DescribeFileSystemsResponse
func (client *Client) DescribeFileSystems(request *DescribeFileSystemsRequest) (_result *DescribeFileSystemsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeFileSystemsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the information about created filesets.
//
// Description:
//
//	  Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.7.0 and later support this operation. You can view the version information on the file system details page in the console.
//
//		- In Filters, FsetIds supports exact match only. FileSystemPath and Description support fuzzy match.
//
//		- Combined query is supported.
//
// @param request - DescribeFilesetsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeFilesetsResponse
func (client *Client) DescribeFilesetsWithOptions(request *DescribeFilesetsRequest, runtime *dara.RuntimeOptions) (_result *DescribeFilesetsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.Filters) {
		query["Filters"] = request.Filters
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.OrderByField) {
		query["OrderByField"] = request.OrderByField
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.SortOrder) {
		query["SortOrder"] = request.SortOrder
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeFilesets"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the information about created filesets.
//
// Description:
//
//	  Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.7.0 and later support this operation. You can view the version information on the file system details page in the console.
//
//		- In Filters, FsetIds supports exact match only. FileSystemPath and Description support fuzzy match.
//
//		- Combined query is supported.
//
// @param request - DescribeFilesetsRequest
//
// @return DescribeFilesetsResponse
func (client *Client) DescribeFilesets(request *DescribeFilesetsRequest) (_result *DescribeFilesetsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeFilesetsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 查询 VSC 绑定信息
//
// @param request - DescribeFilesystemsVscAttachInfoRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeFilesystemsVscAttachInfoResponse
func (client *Client) DescribeFilesystemsVscAttachInfoWithOptions(request *DescribeFilesystemsVscAttachInfoRequest, runtime *dara.RuntimeOptions) (_result *DescribeFilesystemsVscAttachInfoResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.ResourceIds) {
		query["ResourceIds"] = request.ResourceIds
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeFilesystemsVscAttachInfo"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// 查询 VSC 绑定信息
//
// @param request - DescribeFilesystemsVscAttachInfoRequest
//
// @return DescribeFilesystemsVscAttachInfoResponse
func (client *Client) DescribeFilesystemsVscAttachInfo(request *DescribeFilesystemsVscAttachInfoRequest) (_result *DescribeFilesystemsVscAttachInfoResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeFilesystemsVscAttachInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries lifecycle policies.
//
// Description:
//
// Only General-purpose NAS file systems support this operation.
//
// @param request - DescribeLifecyclePoliciesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeLifecyclePoliciesResponse
func (client *Client) DescribeLifecyclePoliciesWithOptions(request *DescribeLifecyclePoliciesRequest, runtime *dara.RuntimeOptions) (_result *DescribeLifecyclePoliciesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(dara.ToMap(request))
	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeLifecyclePolicies"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("GET"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries lifecycle policies.
//
// Description:
//
// Only General-purpose NAS file systems support this operation.
//
// @param request - DescribeLifecyclePoliciesRequest
//
// @return DescribeLifecyclePoliciesResponse
func (client *Client) DescribeLifecyclePolicies(request *DescribeLifecyclePoliciesRequest) (_result *DescribeLifecyclePoliciesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeLifecyclePoliciesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the log dump information configured in log analysis.
//
// @param request - DescribeLogAnalysisRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeLogAnalysisResponse
func (client *Client) DescribeLogAnalysisWithOptions(request *DescribeLogAnalysisRequest, runtime *dara.RuntimeOptions) (_result *DescribeLogAnalysisResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemType) {
		query["FileSystemType"] = request.FileSystemType
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeLogAnalysis"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the log dump information configured in log analysis.
//
// @param request - DescribeLogAnalysisRequest
//
// @return DescribeLogAnalysisResponse
func (client *Client) DescribeLogAnalysis(request *DescribeLogAnalysisRequest) (_result *DescribeLogAnalysisResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeLogAnalysisWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries mount targets.
//
// @param request - DescribeMountTargetsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeMountTargetsResponse
func (client *Client) DescribeMountTargetsWithOptions(request *DescribeMountTargetsRequest, runtime *dara.RuntimeOptions) (_result *DescribeMountTargetsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.DualStackMountTargetDomain) {
		query["DualStackMountTargetDomain"] = request.DualStackMountTargetDomain
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.MountTargetDomain) {
		query["MountTargetDomain"] = request.MountTargetDomain
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeMountTargets"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries mount targets.
//
// @param request - DescribeMountTargetsRequest
//
// @return DescribeMountTargetsResponse
func (client *Client) DescribeMountTargets(request *DescribeMountTargetsRequest) (_result *DescribeMountTargetsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeMountTargetsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the clients on which a file system is mounted.
//
// Description:
//
//	  Only General-purpose NAS file systems support this operation.
//
//		- This operation returns the clients that have accessed the specified file system within the last minute. If the file system is mounted on a client but the client did not access the file system within the last minute, the client is not included in the returned information.
//
// @param request - DescribeMountedClientsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeMountedClientsResponse
func (client *Client) DescribeMountedClientsWithOptions(request *DescribeMountedClientsRequest, runtime *dara.RuntimeOptions) (_result *DescribeMountedClientsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientIP) {
		query["ClientIP"] = request.ClientIP
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.MountTargetDomain) {
		query["MountTargetDomain"] = request.MountTargetDomain
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeMountedClients"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the clients on which a file system is mounted.
//
// Description:
//
//	  Only General-purpose NAS file systems support this operation.
//
//		- This operation returns the clients that have accessed the specified file system within the last minute. If the file system is mounted on a client but the client did not access the file system within the last minute, the client is not included in the returned information.
//
// @param request - DescribeMountedClientsRequest
//
// @return DescribeMountedClientsResponse
func (client *Client) DescribeMountedClients(request *DescribeMountedClientsRequest) (_result *DescribeMountedClientsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeMountedClientsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries whether the NFS ACL feature is enabled for a file system.
//
// @param request - DescribeNfsAclRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeNfsAclResponse
func (client *Client) DescribeNfsAclWithOptions(request *DescribeNfsAclRequest, runtime *dara.RuntimeOptions) (_result *DescribeNfsAclResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeNfsAcl"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries whether the NFS ACL feature is enabled for a file system.
//
// @param request - DescribeNfsAclRequest
//
// @return DescribeNfsAclResponse
func (client *Client) DescribeNfsAcl(request *DescribeNfsAclRequest) (_result *DescribeNfsAclResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeNfsAclWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the export directories of a protocol service.
//
// Description:
//
// This operation is available only to Cloud Parallel File Storage (CPFS) file systems on the China site (aliyun.com).
//
// @param request - DescribeProtocolMountTargetRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeProtocolMountTargetResponse
func (client *Client) DescribeProtocolMountTargetWithOptions(request *DescribeProtocolMountTargetRequest, runtime *dara.RuntimeOptions) (_result *DescribeProtocolMountTargetResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.Filters) {
		query["Filters"] = request.Filters
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeProtocolMountTarget"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the export directories of a protocol service.
//
// Description:
//
// This operation is available only to Cloud Parallel File Storage (CPFS) file systems on the China site (aliyun.com).
//
// @param request - DescribeProtocolMountTargetRequest
//
// @return DescribeProtocolMountTargetResponse
func (client *Client) DescribeProtocolMountTarget(request *DescribeProtocolMountTargetRequest) (_result *DescribeProtocolMountTargetResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeProtocolMountTargetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the information about protocol services.
//
// Description:
//
// This operation is available only to Cloud Parallel File Storage (CPFS) file systems on the China site (aliyun.com).
//
// @param request - DescribeProtocolServiceRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeProtocolServiceResponse
func (client *Client) DescribeProtocolServiceWithOptions(request *DescribeProtocolServiceRequest, runtime *dara.RuntimeOptions) (_result *DescribeProtocolServiceResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.ProtocolServiceIds) {
		query["ProtocolServiceIds"] = request.ProtocolServiceIds
	}

	if !dara.IsNil(request.Status) {
		query["Status"] = request.Status
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeProtocolService"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the information about protocol services.
//
// Description:
//
// This operation is available only to Cloud Parallel File Storage (CPFS) file systems on the China site (aliyun.com).
//
// @param request - DescribeProtocolServiceRequest
//
// @return DescribeProtocolServiceResponse
func (client *Client) DescribeProtocolService(request *DescribeProtocolServiceRequest) (_result *DescribeProtocolServiceResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeProtocolServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the regions in which File Storage NAS is available.
//
// @param request - DescribeRegionsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeRegionsResponse
func (client *Client) DescribeRegionsWithOptions(request *DescribeRegionsRequest, runtime *dara.RuntimeOptions) (_result *DescribeRegionsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemType) {
		query["FileSystemType"] = request.FileSystemType
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeRegions"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the regions in which File Storage NAS is available.
//
// @param request - DescribeRegionsRequest
//
// @return DescribeRegionsResponse
func (client *Client) DescribeRegions(request *DescribeRegionsRequest) (_result *DescribeRegionsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeRegionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 控制台概览页资源统计---内部使用接口
//
// @param request - DescribeResourceStatisticsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeResourceStatisticsResponse
func (client *Client) DescribeResourceStatisticsWithOptions(request *DescribeResourceStatisticsRequest, runtime *dara.RuntimeOptions) (_result *DescribeResourceStatisticsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemType) {
		query["FileSystemType"] = request.FileSystemType
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeResourceStatistics"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// 控制台概览页资源统计---内部使用接口
//
// @param request - DescribeResourceStatisticsRequest
//
// @return DescribeResourceStatisticsResponse
func (client *Client) DescribeResourceStatistics(request *DescribeResourceStatisticsRequest) (_result *DescribeResourceStatisticsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeResourceStatisticsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the information about the access control list (ACL) feature of a Server Message Block (SMB) file system that resides in an Active Directory (AD) domain.
//
// @param request - DescribeSmbAclRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeSmbAclResponse
func (client *Client) DescribeSmbAclWithOptions(request *DescribeSmbAclRequest, runtime *dara.RuntimeOptions) (_result *DescribeSmbAclResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeSmbAcl"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the information about the access control list (ACL) feature of a Server Message Block (SMB) file system that resides in an Active Directory (AD) domain.
//
// @param request - DescribeSmbAclRequest
//
// @return DescribeSmbAclResponse
func (client *Client) DescribeSmbAcl(request *DescribeSmbAclRequest) (_result *DescribeSmbAclResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeSmbAclWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the information about one or more snapshots of a file system.
//
// Description:
//
//	  The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
//
//		- Only advanced Extreme NAS file systems support this feature.
//
// @param request - DescribeSnapshotsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeSnapshotsResponse
func (client *Client) DescribeSnapshotsWithOptions(request *DescribeSnapshotsRequest, runtime *dara.RuntimeOptions) (_result *DescribeSnapshotsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.FileSystemType) {
		query["FileSystemType"] = request.FileSystemType
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.SnapshotIds) {
		query["SnapshotIds"] = request.SnapshotIds
	}

	if !dara.IsNil(request.SnapshotName) {
		query["SnapshotName"] = request.SnapshotName
	}

	if !dara.IsNil(request.SnapshotType) {
		query["SnapshotType"] = request.SnapshotType
	}

	if !dara.IsNil(request.Status) {
		query["Status"] = request.Status
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeSnapshots"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the information about one or more snapshots of a file system.
//
// Description:
//
//	  The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
//
//		- Only advanced Extreme NAS file systems support this feature.
//
// @param request - DescribeSnapshotsRequest
//
// @return DescribeSnapshotsResponse
func (client *Client) DescribeSnapshots(request *DescribeSnapshotsRequest) (_result *DescribeSnapshotsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeSnapshotsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// You can call the DescribeStoragePackages operation to query the list of storage plans.
//
// @param request - DescribeStoragePackagesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeStoragePackagesResponse
func (client *Client) DescribeStoragePackagesWithOptions(request *DescribeStoragePackagesRequest, runtime *dara.RuntimeOptions) (_result *DescribeStoragePackagesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	if !dara.IsNil(request.UseUTCDateTime) {
		query["UseUTCDateTime"] = request.UseUTCDateTime
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeStoragePackages"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// You can call the DescribeStoragePackages operation to query the list of storage plans.
//
// @param request - DescribeStoragePackagesRequest
//
// @return DescribeStoragePackagesResponse
func (client *Client) DescribeStoragePackages(request *DescribeStoragePackagesRequest) (_result *DescribeStoragePackagesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeStoragePackagesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 查询 VSC 挂载点绑定信息
//
// @param request - DescribeVscMountPointAttachInfoRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVscMountPointAttachInfoResponse
func (client *Client) DescribeVscMountPointAttachInfoWithOptions(request *DescribeVscMountPointAttachInfoRequest, runtime *dara.RuntimeOptions) (_result *DescribeVscMountPointAttachInfoResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.InstanceIds) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.MountPointDomain) {
		query["MountPointDomain"] = request.MountPointDomain
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.VscIds) {
		query["VscIds"] = request.VscIds
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeVscMountPointAttachInfo"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// 查询 VSC 挂载点绑定信息
//
// @param request - DescribeVscMountPointAttachInfoRequest
//
// @return DescribeVscMountPointAttachInfoResponse
func (client *Client) DescribeVscMountPointAttachInfo(request *DescribeVscMountPointAttachInfoRequest) (_result *DescribeVscMountPointAttachInfoResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeVscMountPointAttachInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 查询挂载点信息
//
// @param request - DescribeVscMountPointsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVscMountPointsResponse
func (client *Client) DescribeVscMountPointsWithOptions(request *DescribeVscMountPointsRequest, runtime *dara.RuntimeOptions) (_result *DescribeVscMountPointsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.MountPointDomain) {
		query["MountPointDomain"] = request.MountPointDomain
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeVscMountPoints"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// 查询挂载点信息
//
// @param request - DescribeVscMountPointsRequest
//
// @return DescribeVscMountPointsResponse
func (client *Client) DescribeVscMountPoints(request *DescribeVscMountPointsRequest) (_result *DescribeVscMountPointsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeVscMountPointsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries all zones in a region and the file system types that are supported in each zone.
//
// @param request - DescribeZonesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeZonesResponse
func (client *Client) DescribeZonesWithOptions(request *DescribeZonesRequest, runtime *dara.RuntimeOptions) (_result *DescribeZonesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemType) {
		query["FileSystemType"] = request.FileSystemType
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DescribeZones"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries all zones in a region and the file system types that are supported in each zone.
//
// @param request - DescribeZonesRequest
//
// @return DescribeZonesResponse
func (client *Client) DescribeZones(request *DescribeZonesRequest) (_result *DescribeZonesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DescribeZonesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 取消绑定 VSC 文件系统
//
// @param request - DetachVscFromFilesystemsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DetachVscFromFilesystemsResponse
func (client *Client) DetachVscFromFilesystemsWithOptions(request *DetachVscFromFilesystemsRequest, runtime *dara.RuntimeOptions) (_result *DetachVscFromFilesystemsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.ResourceIds) {
		query["ResourceIds"] = request.ResourceIds
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DetachVscFromFilesystems"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// 取消绑定 VSC 文件系统
//
// @param request - DetachVscFromFilesystemsRequest
//
// @return DetachVscFromFilesystemsResponse
func (client *Client) DetachVscFromFilesystems(request *DetachVscFromFilesystemsRequest) (_result *DetachVscFromFilesystemsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DetachVscFromFilesystemsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 取消绑定 VSC 挂载点
//
// @param request - DetachVscMountPointRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DetachVscMountPointResponse
func (client *Client) DetachVscMountPointWithOptions(request *DetachVscMountPointRequest, runtime *dara.RuntimeOptions) (_result *DetachVscMountPointResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.MountPointDomain) {
		query["MountPointDomain"] = request.MountPointDomain
	}

	if !dara.IsNil(request.VscAttachInfos) {
		query["VscAttachInfos"] = request.VscAttachInfos
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DetachVscMountPoint"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// 取消绑定 VSC 挂载点
//
// @param request - DetachVscMountPointRequest
//
// @return DetachVscMountPointResponse
func (client *Client) DetachVscMountPoint(request *DetachVscMountPointRequest) (_result *DetachVscMountPointResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DetachVscMountPointWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Disables and empties the recycle bin of a General-purpose NAS file system.
//
// Description:
//
//	  Only General-purpose NAS file systems support this operation.
//
//		- If you disable the recycle bin, all files in the recycle bin are permanently deleted.
//
//		- If you disable and then enable the recycle bin, the recycle bin is empty. You cannot retrieve the deleted files.
//
// @param request - DisableAndCleanRecycleBinRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DisableAndCleanRecycleBinResponse
func (client *Client) DisableAndCleanRecycleBinWithOptions(request *DisableAndCleanRecycleBinRequest, runtime *dara.RuntimeOptions) (_result *DisableAndCleanRecycleBinResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(dara.ToMap(request))
	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DisableAndCleanRecycleBin"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("GET"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Disables and empties the recycle bin of a General-purpose NAS file system.
//
// Description:
//
//	  Only General-purpose NAS file systems support this operation.
//
//		- If you disable the recycle bin, all files in the recycle bin are permanently deleted.
//
//		- If you disable and then enable the recycle bin, the recycle bin is empty. You cannot retrieve the deleted files.
//
// @param request - DisableAndCleanRecycleBinRequest
//
// @return DisableAndCleanRecycleBinResponse
func (client *Client) DisableAndCleanRecycleBin(request *DisableAndCleanRecycleBinRequest) (_result *DisableAndCleanRecycleBinResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DisableAndCleanRecycleBinWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Disables the NFS ACL feature for a file system.
//
// @param request - DisableNfsAclRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DisableNfsAclResponse
func (client *Client) DisableNfsAclWithOptions(request *DisableNfsAclRequest, runtime *dara.RuntimeOptions) (_result *DisableNfsAclResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DisableNfsAcl"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Disables the NFS ACL feature for a file system.
//
// @param request - DisableNfsAclRequest
//
// @return DisableNfsAclResponse
func (client *Client) DisableNfsAcl(request *DisableNfsAclRequest) (_result *DisableNfsAclResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DisableNfsAclWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Disables the access control list (ACL) feature for a Server Message Block (SMB) file system that resides in an Active Directory (AD) domain.
//
// @param request - DisableSmbAclRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DisableSmbAclResponse
func (client *Client) DisableSmbAclWithOptions(request *DisableSmbAclRequest, runtime *dara.RuntimeOptions) (_result *DisableSmbAclResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("DisableSmbAcl"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Disables the access control list (ACL) feature for a Server Message Block (SMB) file system that resides in an Active Directory (AD) domain.
//
// @param request - DisableSmbAclRequest
//
// @return DisableSmbAclResponse
func (client *Client) DisableSmbAcl(request *DisableSmbAclRequest) (_result *DisableSmbAclResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.DisableSmbAclWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Enables the NFS ACL feature for a file system.
//
// @param request - EnableNfsAclRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return EnableNfsAclResponse
func (client *Client) EnableNfsAclWithOptions(request *EnableNfsAclRequest, runtime *dara.RuntimeOptions) (_result *EnableNfsAclResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("EnableNfsAcl"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Enables the NFS ACL feature for a file system.
//
// @param request - EnableNfsAclRequest
//
// @return EnableNfsAclResponse
func (client *Client) EnableNfsAcl(request *EnableNfsAclRequest) (_result *EnableNfsAclResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.EnableNfsAclWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Enables the recycle bin feature for a file system.
//
// Description:
//
// Only General-purpose NAS file systems support this operation.
//
// @param request - EnableRecycleBinRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return EnableRecycleBinResponse
func (client *Client) EnableRecycleBinWithOptions(request *EnableRecycleBinRequest, runtime *dara.RuntimeOptions) (_result *EnableRecycleBinResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.ReservedDays) {
		query["ReservedDays"] = request.ReservedDays
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("EnableRecycleBin"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Enables the recycle bin feature for a file system.
//
// Description:
//
// Only General-purpose NAS file systems support this operation.
//
// @param request - EnableRecycleBinRequest
//
// @return EnableRecycleBinResponse
func (client *Client) EnableRecycleBin(request *EnableRecycleBinRequest) (_result *EnableRecycleBinResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.EnableRecycleBinWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Enables the access control list (ACL) feature for a Server Message Block (SMB) file system that resides in an Active Directory (AD) domain.
//
// @param request - EnableSmbAclRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return EnableSmbAclResponse
func (client *Client) EnableSmbAclWithOptions(request *EnableSmbAclRequest, runtime *dara.RuntimeOptions) (_result *EnableSmbAclResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AuthCenter) {
		query["AuthCenter"] = request.AuthCenter
	}

	if !dara.IsNil(request.AuthMethod) {
		query["AuthMethod"] = request.AuthMethod
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.Keytab) {
		query["Keytab"] = request.Keytab
	}

	if !dara.IsNil(request.KeytabMd5) {
		query["KeytabMd5"] = request.KeytabMd5
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("EnableSmbAcl"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Enables the access control list (ACL) feature for a Server Message Block (SMB) file system that resides in an Active Directory (AD) domain.
//
// @param request - EnableSmbAclRequest
//
// @return EnableSmbAclResponse
func (client *Client) EnableSmbAcl(request *EnableSmbAclRequest) (_result *EnableSmbAclResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.EnableSmbAclWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries whether a directory contains files that are stored in the Infrequent Access (IA) or Archive storage class, or whether a file is stored in the IA or Archive storage class.
//
// Description:
//
// Only General-purpose NAS file systems support this operation.
//
// @param request - GetDirectoryOrFilePropertiesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetDirectoryOrFilePropertiesResponse
func (client *Client) GetDirectoryOrFilePropertiesWithOptions(request *GetDirectoryOrFilePropertiesRequest, runtime *dara.RuntimeOptions) (_result *GetDirectoryOrFilePropertiesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.Path) {
		query["Path"] = request.Path
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("GetDirectoryOrFileProperties"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries whether a directory contains files that are stored in the Infrequent Access (IA) or Archive storage class, or whether a file is stored in the IA or Archive storage class.
//
// Description:
//
// Only General-purpose NAS file systems support this operation.
//
// @param request - GetDirectoryOrFilePropertiesRequest
//
// @return GetDirectoryOrFilePropertiesResponse
func (client *Client) GetDirectoryOrFileProperties(request *GetDirectoryOrFilePropertiesRequest) (_result *GetDirectoryOrFilePropertiesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.GetDirectoryOrFilePropertiesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 获取生命周期策略不活跃天数范围
//
// @param request - GetLifecycleRuleTimeRangeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetLifecycleRuleTimeRangeResponse
func (client *Client) GetLifecycleRuleTimeRangeWithOptions(request *GetLifecycleRuleTimeRangeRequest, runtime *dara.RuntimeOptions) (_result *GetLifecycleRuleTimeRangeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(dara.ToMap(request))
	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("GetLifecycleRuleTimeRange"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("GET"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// 获取生命周期策略不活跃天数范围
//
// @param request - GetLifecycleRuleTimeRangeRequest
//
// @return GetLifecycleRuleTimeRangeResponse
func (client *Client) GetLifecycleRuleTimeRange(request *GetLifecycleRuleTimeRangeRequest) (_result *GetLifecycleRuleTimeRangeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.GetLifecycleRuleTimeRangeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the recycle bin configurations of a General-purpose NAS file system.
//
// Description:
//
// Only General-purpose File Storage NAS (NAS) file systems support this operation.
//
// @param request - GetRecycleBinAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetRecycleBinAttributeResponse
func (client *Client) GetRecycleBinAttributeWithOptions(request *GetRecycleBinAttributeRequest, runtime *dara.RuntimeOptions) (_result *GetRecycleBinAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(dara.ToMap(request))
	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("GetRecycleBinAttribute"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("GET"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the recycle bin configurations of a General-purpose NAS file system.
//
// Description:
//
// Only General-purpose File Storage NAS (NAS) file systems support this operation.
//
// @param request - GetRecycleBinAttributeRequest
//
// @return GetRecycleBinAttributeResponse
func (client *Client) GetRecycleBinAttribute(request *GetRecycleBinAttributeRequest) (_result *GetRecycleBinAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.GetRecycleBinAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 获取Viper配置
//
// @param request - GetViperGrayConfigRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetViperGrayConfigResponse
func (client *Client) GetViperGrayConfigWithOptions(request *GetViperGrayConfigRequest, runtime *dara.RuntimeOptions) (_result *GetViperGrayConfigResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Condition) {
		query["Condition"] = request.Condition
	}

	if !dara.IsNil(request.ConfigName) {
		query["ConfigName"] = request.ConfigName
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("GetViperGrayConfig"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// 获取Viper配置
//
// @param request - GetViperGrayConfigRequest
//
// @return GetViperGrayConfigResponse
func (client *Client) GetViperGrayConfig(request *GetViperGrayConfigRequest) (_result *GetViperGrayConfigResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.GetViperGrayConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the infrequently-accessed files in a specified directory of a General-purpose NAS file system and the subdirectories that contain the files.
//
// Description:
//
// Only General-purpose NAS file systems support this operation.
//
// @param request - ListDirectoriesAndFilesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListDirectoriesAndFilesResponse
func (client *Client) ListDirectoriesAndFilesWithOptions(request *ListDirectoriesAndFilesRequest, runtime *dara.RuntimeOptions) (_result *ListDirectoriesAndFilesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.DirectoryOnly) {
		query["DirectoryOnly"] = request.DirectoryOnly
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.MaxResults) {
		query["MaxResults"] = request.MaxResults
	}

	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.Path) {
		query["Path"] = request.Path
	}

	if !dara.IsNil(request.StorageType) {
		query["StorageType"] = request.StorageType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListDirectoriesAndFiles"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the infrequently-accessed files in a specified directory of a General-purpose NAS file system and the subdirectories that contain the files.
//
// Description:
//
// Only General-purpose NAS file systems support this operation.
//
// @param request - ListDirectoriesAndFilesRequest
//
// @return ListDirectoriesAndFilesResponse
func (client *Client) ListDirectoriesAndFiles(request *ListDirectoriesAndFilesRequest) (_result *ListDirectoriesAndFilesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.ListDirectoriesAndFilesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries data retrieval tasks.
//
// Description:
//
// Only General-purpose NAS file systems support this operation.
//
// @param request - ListLifecycleRetrieveJobsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListLifecycleRetrieveJobsResponse
func (client *Client) ListLifecycleRetrieveJobsWithOptions(request *ListLifecycleRetrieveJobsRequest, runtime *dara.RuntimeOptions) (_result *ListLifecycleRetrieveJobsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.PageNumber) {
		query["PageNumber"] = request.PageNumber
	}

	if !dara.IsNil(request.PageSize) {
		query["PageSize"] = request.PageSize
	}

	if !dara.IsNil(request.Status) {
		query["Status"] = request.Status
	}

	if !dara.IsNil(request.StorageType) {
		query["StorageType"] = request.StorageType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListLifecycleRetrieveJobs"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries data retrieval tasks.
//
// Description:
//
// Only General-purpose NAS file systems support this operation.
//
// @param request - ListLifecycleRetrieveJobsRequest
//
// @return ListLifecycleRetrieveJobsResponse
func (client *Client) ListLifecycleRetrieveJobs(request *ListLifecycleRetrieveJobsRequest) (_result *ListLifecycleRetrieveJobsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.ListLifecycleRetrieveJobsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the directories that are recently deleted.
//
// Description:
//
// Only General-purpose NAS file systems support this operation.
//
// @param request - ListRecentlyRecycledDirectoriesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListRecentlyRecycledDirectoriesResponse
func (client *Client) ListRecentlyRecycledDirectoriesWithOptions(request *ListRecentlyRecycledDirectoriesRequest, runtime *dara.RuntimeOptions) (_result *ListRecentlyRecycledDirectoriesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(dara.ToMap(request))
	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListRecentlyRecycledDirectories"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("GET"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the directories that are recently deleted.
//
// Description:
//
// Only General-purpose NAS file systems support this operation.
//
// @param request - ListRecentlyRecycledDirectoriesRequest
//
// @return ListRecentlyRecycledDirectoriesResponse
func (client *Client) ListRecentlyRecycledDirectories(request *ListRecentlyRecycledDirectoriesRequest) (_result *ListRecentlyRecycledDirectoriesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.ListRecentlyRecycledDirectoriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the jobs of the recycle bin.
//
// Description:
//
//	  Only General-purpose NAS file systems support this operation.
//
//		- You can query a maximum of 50 jobs that are recently executed.
//
// @param request - ListRecycleBinJobsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListRecycleBinJobsResponse
func (client *Client) ListRecycleBinJobsWithOptions(request *ListRecycleBinJobsRequest, runtime *dara.RuntimeOptions) (_result *ListRecycleBinJobsResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(dara.ToMap(request))
	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListRecycleBinJobs"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("GET"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the jobs of the recycle bin.
//
// Description:
//
//	  Only General-purpose NAS file systems support this operation.
//
//		- You can query a maximum of 50 jobs that are recently executed.
//
// @param request - ListRecycleBinJobsRequest
//
// @return ListRecycleBinJobsResponse
func (client *Client) ListRecycleBinJobs(request *ListRecycleBinJobsRequest) (_result *ListRecycleBinJobsResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.ListRecycleBinJobsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries deleted files or directories.
//
// Description:
//
// Only General-purpose NAS file systems support this operation.
//
// @param request - ListRecycledDirectoriesAndFilesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListRecycledDirectoriesAndFilesResponse
func (client *Client) ListRecycledDirectoriesAndFilesWithOptions(request *ListRecycledDirectoriesAndFilesRequest, runtime *dara.RuntimeOptions) (_result *ListRecycledDirectoriesAndFilesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(dara.ToMap(request))
	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListRecycledDirectoriesAndFiles"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("GET"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries deleted files or directories.
//
// Description:
//
// Only General-purpose NAS file systems support this operation.
//
// @param request - ListRecycledDirectoriesAndFilesRequest
//
// @return ListRecycledDirectoriesAndFilesResponse
func (client *Client) ListRecycledDirectoriesAndFiles(request *ListRecycledDirectoriesAndFilesRequest) (_result *ListRecycledDirectoriesAndFilesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.ListRecycledDirectoriesAndFilesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries tags.
//
// @param request - ListTagResourcesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListTagResourcesResponse
func (client *Client) ListTagResourcesWithOptions(request *ListTagResourcesRequest, runtime *dara.RuntimeOptions) (_result *ListTagResourcesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.NextToken) {
		query["NextToken"] = request.NextToken
	}

	if !dara.IsNil(request.ResourceId) {
		query["ResourceId"] = request.ResourceId
	}

	if !dara.IsNil(request.ResourceType) {
		query["ResourceType"] = request.ResourceType
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ListTagResources"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries tags.
//
// @param request - ListTagResourcesRequest
//
// @return ListTagResourcesResponse
func (client *Client) ListTagResources(request *ListTagResourcesRequest) (_result *ListTagResourcesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.ListTagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies a permission group.
//
// Description:
//
// The default permission group (DEFAULT_VPC_GROUP_NAME) cannot be modified.
//
// @param request - ModifyAccessGroupRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyAccessGroupResponse
func (client *Client) ModifyAccessGroupWithOptions(request *ModifyAccessGroupRequest, runtime *dara.RuntimeOptions) (_result *ModifyAccessGroupResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AccessGroupName) {
		query["AccessGroupName"] = request.AccessGroupName
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.FileSystemType) {
		query["FileSystemType"] = request.FileSystemType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyAccessGroup"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Modifies a permission group.
//
// Description:
//
// The default permission group (DEFAULT_VPC_GROUP_NAME) cannot be modified.
//
// @param request - ModifyAccessGroupRequest
//
// @return ModifyAccessGroupResponse
func (client *Client) ModifyAccessGroup(request *ModifyAccessGroupRequest) (_result *ModifyAccessGroupResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.ModifyAccessGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the information about an access point.
//
// Description:
//
// Only General-purpose Network File System (NFS) file systems support this operation.
//
// @param request - ModifyAccessPointRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyAccessPointResponse
func (client *Client) ModifyAccessPointWithOptions(request *ModifyAccessPointRequest, runtime *dara.RuntimeOptions) (_result *ModifyAccessPointResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AccessGroup) {
		query["AccessGroup"] = request.AccessGroup
	}

	if !dara.IsNil(request.AccessPointId) {
		query["AccessPointId"] = request.AccessPointId
	}

	if !dara.IsNil(request.AccessPointName) {
		query["AccessPointName"] = request.AccessPointName
	}

	if !dara.IsNil(request.EnabledRam) {
		query["EnabledRam"] = request.EnabledRam
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyAccessPoint"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Modifies the information about an access point.
//
// Description:
//
// Only General-purpose Network File System (NFS) file systems support this operation.
//
// @param request - ModifyAccessPointRequest
//
// @return ModifyAccessPointResponse
func (client *Client) ModifyAccessPoint(request *ModifyAccessPointRequest) (_result *ModifyAccessPointResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.ModifyAccessPointWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies a rule in a permission group.
//
// Description:
//
// The rules in the default permission group (DEFAULT_VPC_GROUP_NAME) cannot be modified.
//
// @param request - ModifyAccessRuleRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyAccessRuleResponse
func (client *Client) ModifyAccessRuleWithOptions(request *ModifyAccessRuleRequest, runtime *dara.RuntimeOptions) (_result *ModifyAccessRuleResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AccessGroupName) {
		query["AccessGroupName"] = request.AccessGroupName
	}

	if !dara.IsNil(request.AccessRuleId) {
		query["AccessRuleId"] = request.AccessRuleId
	}

	if !dara.IsNil(request.FileSystemType) {
		query["FileSystemType"] = request.FileSystemType
	}

	if !dara.IsNil(request.Ipv6SourceCidrIp) {
		query["Ipv6SourceCidrIp"] = request.Ipv6SourceCidrIp
	}

	if !dara.IsNil(request.Priority) {
		query["Priority"] = request.Priority
	}

	if !dara.IsNil(request.RWAccessType) {
		query["RWAccessType"] = request.RWAccessType
	}

	if !dara.IsNil(request.SourceCidrIp) {
		query["SourceCidrIp"] = request.SourceCidrIp
	}

	if !dara.IsNil(request.UserAccessType) {
		query["UserAccessType"] = request.UserAccessType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyAccessRule"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Modifies a rule in a permission group.
//
// Description:
//
// The rules in the default permission group (DEFAULT_VPC_GROUP_NAME) cannot be modified.
//
// @param request - ModifyAccessRuleRequest
//
// @return ModifyAccessRuleResponse
func (client *Client) ModifyAccessRule(request *ModifyAccessRuleRequest) (_result *ModifyAccessRuleResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.ModifyAccessRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// An automatic snapshot policy is modified. After you modify an automatic snapshot policy that is applied to a file system, the modification immediately applies to subsequent snapshots that are created for the file system.
//
// Description:
//
//	  The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
//
//		- Only advanced Extreme NAS file systems support this feature.
//
// @param request - ModifyAutoSnapshotPolicyRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyAutoSnapshotPolicyResponse
func (client *Client) ModifyAutoSnapshotPolicyWithOptions(request *ModifyAutoSnapshotPolicyRequest, runtime *dara.RuntimeOptions) (_result *ModifyAutoSnapshotPolicyResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AutoSnapshotPolicyId) {
		query["AutoSnapshotPolicyId"] = request.AutoSnapshotPolicyId
	}

	if !dara.IsNil(request.AutoSnapshotPolicyName) {
		query["AutoSnapshotPolicyName"] = request.AutoSnapshotPolicyName
	}

	if !dara.IsNil(request.RepeatWeekdays) {
		query["RepeatWeekdays"] = request.RepeatWeekdays
	}

	if !dara.IsNil(request.RetentionDays) {
		query["RetentionDays"] = request.RetentionDays
	}

	if !dara.IsNil(request.TimePoints) {
		query["TimePoints"] = request.TimePoints
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyAutoSnapshotPolicy"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// An automatic snapshot policy is modified. After you modify an automatic snapshot policy that is applied to a file system, the modification immediately applies to subsequent snapshots that are created for the file system.
//
// Description:
//
//	  The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
//
//		- Only advanced Extreme NAS file systems support this feature.
//
// @param request - ModifyAutoSnapshotPolicyRequest
//
// @return ModifyAutoSnapshotPolicyResponse
func (client *Client) ModifyAutoSnapshotPolicy(request *ModifyAutoSnapshotPolicyRequest) (_result *ModifyAutoSnapshotPolicyResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.ModifyAutoSnapshotPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the attributes of a dataflow.
//
// Description:
//
//	  Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.4.0 and later support data flows.
//
//		- You can modify the attributes only of the data flows that are in the `Running` state.
//
//		- It generally takes 2 to 5 minutes to modify the attributes of a data flow. You can call the [DescribeDataFlows](https://help.aliyun.com/document_detail/2838084.html) operation to query the status of the data flow to be modified.
//
// @param request - ModifyDataFlowRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyDataFlowResponse
func (client *Client) ModifyDataFlowWithOptions(request *ModifyDataFlowRequest, runtime *dara.RuntimeOptions) (_result *ModifyDataFlowResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DataFlowId) {
		query["DataFlowId"] = request.DataFlowId
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.Throughput) {
		query["Throughput"] = request.Throughput
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyDataFlow"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Modifies the attributes of a dataflow.
//
// Description:
//
//	  Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.4.0 and later support data flows.
//
//		- You can modify the attributes only of the data flows that are in the `Running` state.
//
//		- It generally takes 2 to 5 minutes to modify the attributes of a data flow. You can call the [DescribeDataFlows](https://help.aliyun.com/document_detail/2838084.html) operation to query the status of the data flow to be modified.
//
// @param request - ModifyDataFlowRequest
//
// @return ModifyDataFlowResponse
func (client *Client) ModifyDataFlow(request *ModifyDataFlowRequest) (_result *ModifyDataFlowResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.ModifyDataFlowWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies an AutoRefresh configuration of a dataflow.
//
// Description:
//
//	  This operation is available only to Cloud Parallel File Storage (CPFS) file systems on the China site (aliyun.com).
//
//		- Only CPFS V2.2.0 and later support dataflows. You can view the version information on the file system details page in the console.
//
//		- You can modify the AutoRefresh configurations only for the dataflows that are in the `Running` or `Stopped` state.
//
//		- It generally takes 2 to 5 minutes to modify an AutoRefresh configuration. You can call the [DescribeDataFlows](https://help.aliyun.com/document_detail/2838084.html) operation to query the task of modifying an AutoRefresh configuration.
//
// @param request - ModifyDataFlowAutoRefreshRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyDataFlowAutoRefreshResponse
func (client *Client) ModifyDataFlowAutoRefreshWithOptions(request *ModifyDataFlowAutoRefreshRequest, runtime *dara.RuntimeOptions) (_result *ModifyDataFlowAutoRefreshResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AutoRefreshInterval) {
		query["AutoRefreshInterval"] = request.AutoRefreshInterval
	}

	if !dara.IsNil(request.AutoRefreshPolicy) {
		query["AutoRefreshPolicy"] = request.AutoRefreshPolicy
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DataFlowId) {
		query["DataFlowId"] = request.DataFlowId
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyDataFlowAutoRefresh"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Modifies an AutoRefresh configuration of a dataflow.
//
// Description:
//
//	  This operation is available only to Cloud Parallel File Storage (CPFS) file systems on the China site (aliyun.com).
//
//		- Only CPFS V2.2.0 and later support dataflows. You can view the version information on the file system details page in the console.
//
//		- You can modify the AutoRefresh configurations only for the dataflows that are in the `Running` or `Stopped` state.
//
//		- It generally takes 2 to 5 minutes to modify an AutoRefresh configuration. You can call the [DescribeDataFlows](https://help.aliyun.com/document_detail/2838084.html) operation to query the task of modifying an AutoRefresh configuration.
//
// @param request - ModifyDataFlowAutoRefreshRequest
//
// @return ModifyDataFlowAutoRefreshResponse
func (client *Client) ModifyDataFlowAutoRefresh(request *ModifyDataFlowAutoRefreshRequest) (_result *ModifyDataFlowAutoRefreshResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.ModifyDataFlowAutoRefreshWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the description of a file system.
//
// @param tmpReq - ModifyFileSystemRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyFileSystemResponse
func (client *Client) ModifyFileSystemWithOptions(tmpReq *ModifyFileSystemRequest, runtime *dara.RuntimeOptions) (_result *ModifyFileSystemResponse, _err error) {
	_err = tmpReq.Validate()
	if _err != nil {
		return _result, _err
	}
	request := &ModifyFileSystemShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !dara.IsNil(tmpReq.Options) {
		request.OptionsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Options, dara.String("Options"), dara.String("json"))
	}

	query := map[string]interface{}{}
	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.OptionsShrink) {
		query["Options"] = request.OptionsShrink
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyFileSystem"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Modifies the description of a file system.
//
// @param request - ModifyFileSystemRequest
//
// @return ModifyFileSystemResponse
func (client *Client) ModifyFileSystem(request *ModifyFileSystemRequest) (_result *ModifyFileSystemResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.ModifyFileSystemWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies a fileset.
//
// Description:
//
// Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.7.0 and later support this operation.
//
// @param request - ModifyFilesetRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyFilesetResponse
func (client *Client) ModifyFilesetWithOptions(request *ModifyFilesetRequest, runtime *dara.RuntimeOptions) (_result *ModifyFilesetResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DeletionProtection) {
		query["DeletionProtection"] = request.DeletionProtection
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.FsetId) {
		query["FsetId"] = request.FsetId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyFileset"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Modifies a fileset.
//
// Description:
//
// Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.7.0 and later support this operation.
//
// @param request - ModifyFilesetRequest
//
// @return ModifyFilesetResponse
func (client *Client) ModifyFileset(request *ModifyFilesetRequest) (_result *ModifyFilesetResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.ModifyFilesetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Deprecated: OpenAPI ModifyLDAPConfig is deprecated
//
// Summary:
//
// 修改LDAP配置
//
// Description:
//
// The API operation is available only for Cloud Parallel File Storage (CPFS) file systems.
//
// @param request - ModifyLDAPConfigRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyLDAPConfigResponse
// Deprecated
func (client *Client) ModifyLDAPConfigWithOptions(request *ModifyLDAPConfigRequest, runtime *dara.RuntimeOptions) (_result *ModifyLDAPConfigResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.BindDN) {
		query["BindDN"] = request.BindDN
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.SearchBase) {
		query["SearchBase"] = request.SearchBase
	}

	if !dara.IsNil(request.URI) {
		query["URI"] = request.URI
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyLDAPConfig"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Deprecated: OpenAPI ModifyLDAPConfig is deprecated
//
// Summary:
//
// 修改LDAP配置
//
// Description:
//
// The API operation is available only for Cloud Parallel File Storage (CPFS) file systems.
//
// @param request - ModifyLDAPConfigRequest
//
// @return ModifyLDAPConfigResponse
// Deprecated
func (client *Client) ModifyLDAPConfig(request *ModifyLDAPConfigRequest) (_result *ModifyLDAPConfigResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.ModifyLDAPConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies a lifecycle policy.
//
// Description:
//
// Only General-purpose NAS file systems support this operation.
//
// @param request - ModifyLifecyclePolicyRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyLifecyclePolicyResponse
func (client *Client) ModifyLifecyclePolicyWithOptions(request *ModifyLifecyclePolicyRequest, runtime *dara.RuntimeOptions) (_result *ModifyLifecyclePolicyResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.EnableLifecycle) {
		query["EnableLifecycle"] = request.EnableLifecycle
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.FsetIds) {
		query["FsetIds"] = request.FsetIds
	}

	if !dara.IsNil(request.LifecyclePolicyName) {
		query["LifecyclePolicyName"] = request.LifecyclePolicyName
	}

	if !dara.IsNil(request.LifecycleRuleName) {
		query["LifecycleRuleName"] = request.LifecycleRuleName
	}

	if !dara.IsNil(request.Path) {
		query["Path"] = request.Path
	}

	if !dara.IsNil(request.StorageType) {
		query["StorageType"] = request.StorageType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyLifecyclePolicy"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Modifies a lifecycle policy.
//
// Description:
//
// Only General-purpose NAS file systems support this operation.
//
// @param request - ModifyLifecyclePolicyRequest
//
// @return ModifyLifecyclePolicyResponse
func (client *Client) ModifyLifecyclePolicy(request *ModifyLifecyclePolicyRequest) (_result *ModifyLifecyclePolicyResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.ModifyLifecyclePolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies a mount target.
//
// @param request - ModifyMountTargetRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyMountTargetResponse
func (client *Client) ModifyMountTargetWithOptions(request *ModifyMountTargetRequest, runtime *dara.RuntimeOptions) (_result *ModifyMountTargetResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AccessGroupName) {
		query["AccessGroupName"] = request.AccessGroupName
	}

	if !dara.IsNil(request.DualStackMountTargetDomain) {
		query["DualStackMountTargetDomain"] = request.DualStackMountTargetDomain
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.MountTargetDomain) {
		query["MountTargetDomain"] = request.MountTargetDomain
	}

	if !dara.IsNil(request.Status) {
		query["Status"] = request.Status
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyMountTarget"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Modifies a mount target.
//
// @param request - ModifyMountTargetRequest
//
// @return ModifyMountTargetResponse
func (client *Client) ModifyMountTarget(request *ModifyMountTargetRequest) (_result *ModifyMountTargetResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.ModifyMountTargetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the export directory parameters of a protocol service. Only the description can be modified. The virtual private cloud (VPC) ID and vSwitch ID cannot be changed. To change these IDs, you must delete the export directory and create a new one.
//
// Description:
//
// This operation is available only to Cloud Parallel File Storage (CPFS) file systems on the China site (aliyun.com).
//
// @param request - ModifyProtocolMountTargetRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyProtocolMountTargetResponse
func (client *Client) ModifyProtocolMountTargetWithOptions(request *ModifyProtocolMountTargetRequest, runtime *dara.RuntimeOptions) (_result *ModifyProtocolMountTargetResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AccessGroupName) {
		query["AccessGroupName"] = request.AccessGroupName
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.ExportId) {
		query["ExportId"] = request.ExportId
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.ProtocolServiceId) {
		query["ProtocolServiceId"] = request.ProtocolServiceId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyProtocolMountTarget"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Modifies the export directory parameters of a protocol service. Only the description can be modified. The virtual private cloud (VPC) ID and vSwitch ID cannot be changed. To change these IDs, you must delete the export directory and create a new one.
//
// Description:
//
// This operation is available only to Cloud Parallel File Storage (CPFS) file systems on the China site (aliyun.com).
//
// @param request - ModifyProtocolMountTargetRequest
//
// @return ModifyProtocolMountTargetResponse
func (client *Client) ModifyProtocolMountTarget(request *ModifyProtocolMountTargetRequest) (_result *ModifyProtocolMountTargetResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.ModifyProtocolMountTargetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies a protocol service. You can modify the description of a protocol service.
//
// Description:
//
// This operation is available only to Cloud Parallel File Storage (CPFS) file systems on the China site (aliyun.com).
//
// @param request - ModifyProtocolServiceRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifyProtocolServiceResponse
func (client *Client) ModifyProtocolServiceWithOptions(request *ModifyProtocolServiceRequest, runtime *dara.RuntimeOptions) (_result *ModifyProtocolServiceResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.Description) {
		query["Description"] = request.Description
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.ProtocolServiceId) {
		query["ProtocolServiceId"] = request.ProtocolServiceId
	}

	if !dara.IsNil(request.ProtocolSpec) {
		query["ProtocolSpec"] = request.ProtocolSpec
	}

	if !dara.IsNil(request.Throughput) {
		query["Throughput"] = request.Throughput
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifyProtocolService"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Modifies a protocol service. You can modify the description of a protocol service.
//
// Description:
//
// This operation is available only to Cloud Parallel File Storage (CPFS) file systems on the China site (aliyun.com).
//
// @param request - ModifyProtocolServiceRequest
//
// @return ModifyProtocolServiceResponse
func (client *Client) ModifyProtocolService(request *ModifyProtocolServiceRequest) (_result *ModifyProtocolServiceResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.ModifyProtocolServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates the information about the access control list (ACL) feature of a Server Message Block (SMB) file system that resides in an Active Directory (AD) domain.
//
// @param request - ModifySmbAclRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ModifySmbAclResponse
func (client *Client) ModifySmbAclWithOptions(request *ModifySmbAclRequest, runtime *dara.RuntimeOptions) (_result *ModifySmbAclResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.AuthCenter) {
		query["AuthCenter"] = request.AuthCenter
	}

	if !dara.IsNil(request.AuthMethod) {
		query["AuthMethod"] = request.AuthMethod
	}

	if !dara.IsNil(request.EnableAnonymousAccess) {
		query["EnableAnonymousAccess"] = request.EnableAnonymousAccess
	}

	if !dara.IsNil(request.EncryptData) {
		query["EncryptData"] = request.EncryptData
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.HomeDirPath) {
		query["HomeDirPath"] = request.HomeDirPath
	}

	if !dara.IsNil(request.Keytab) {
		query["Keytab"] = request.Keytab
	}

	if !dara.IsNil(request.KeytabMd5) {
		query["KeytabMd5"] = request.KeytabMd5
	}

	if !dara.IsNil(request.RejectUnencryptedAccess) {
		query["RejectUnencryptedAccess"] = request.RejectUnencryptedAccess
	}

	if !dara.IsNil(request.SuperAdminSid) {
		query["SuperAdminSid"] = request.SuperAdminSid
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ModifySmbAcl"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Updates the information about the access control list (ACL) feature of a Server Message Block (SMB) file system that resides in an Active Directory (AD) domain.
//
// @param request - ModifySmbAclRequest
//
// @return ModifySmbAclResponse
func (client *Client) ModifySmbAcl(request *ModifySmbAclRequest) (_result *ModifySmbAclResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.ModifySmbAclWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Activates File Storage NAS.
//
// @param request - OpenNASServiceRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return OpenNASServiceResponse
func (client *Client) OpenNASServiceWithOptions(runtime *dara.RuntimeOptions) (_result *OpenNASServiceResponse, _err error) {
	req := &openapiutil.OpenApiRequest{}
	params := &openapiutil.Params{
		Action:      dara.String("OpenNASService"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Activates File Storage NAS.
//
// @return OpenNASServiceResponse
func (client *Client) OpenNASService() (_result *OpenNASServiceResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.OpenNASServiceWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Deprecated: OpenAPI RemoveClientFromBlackList is deprecated
//
// Summary:
//
// 移除黑名单
//
// Description:
//
// The IP address of a client to remove from the blacklist.
//
// @param request - RemoveClientFromBlackListRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return RemoveClientFromBlackListResponse
// Deprecated
func (client *Client) RemoveClientFromBlackListWithOptions(request *RemoveClientFromBlackListRequest, runtime *dara.RuntimeOptions) (_result *RemoveClientFromBlackListResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientIP) {
		query["ClientIP"] = request.ClientIP
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.RegionId) {
		query["RegionId"] = request.RegionId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("RemoveClientFromBlackList"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Deprecated: OpenAPI RemoveClientFromBlackList is deprecated
//
// Summary:
//
// 移除黑名单
//
// Description:
//
// The IP address of a client to remove from the blacklist.
//
// @param request - RemoveClientFromBlackListRequest
//
// @return RemoveClientFromBlackListResponse
// Deprecated
func (client *Client) RemoveClientFromBlackList(request *RemoveClientFromBlackListRequest) (_result *RemoveClientFromBlackListResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.RemoveClientFromBlackListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Rolls back a file system to a snapshot of the file system.
//
// Description:
//
//	  The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
//
//		- Only advanced Extreme NAS file systems support this feature.
//
//		- The file system must be in the Running state.
//
//		- To roll back a file system to a snapshot, you must specify the ID of the snapshot that is created from the file system.
//
// @param request - ResetFileSystemRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ResetFileSystemResponse
func (client *Client) ResetFileSystemWithOptions(request *ResetFileSystemRequest, runtime *dara.RuntimeOptions) (_result *ResetFileSystemResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.SnapshotId) {
		query["SnapshotId"] = request.SnapshotId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("ResetFileSystem"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Rolls back a file system to a snapshot of the file system.
//
// Description:
//
//	  The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
//
//		- Only advanced Extreme NAS file systems support this feature.
//
//		- The file system must be in the Running state.
//
//		- To roll back a file system to a snapshot, you must specify the ID of the snapshot that is created from the file system.
//
// @param request - ResetFileSystemRequest
//
// @return ResetFileSystemResponse
func (client *Client) ResetFileSystem(request *ResetFileSystemRequest) (_result *ResetFileSystemResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.ResetFileSystemWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Retries failed a data retrieval task.
//
// Description:
//
// Only General-purpose NAS file systems support this operation.
//
// @param request - RetryLifecycleRetrieveJobRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return RetryLifecycleRetrieveJobResponse
func (client *Client) RetryLifecycleRetrieveJobWithOptions(request *RetryLifecycleRetrieveJobRequest, runtime *dara.RuntimeOptions) (_result *RetryLifecycleRetrieveJobResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.JobId) {
		query["JobId"] = request.JobId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("RetryLifecycleRetrieveJob"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Retries failed a data retrieval task.
//
// Description:
//
// Only General-purpose NAS file systems support this operation.
//
// @param request - RetryLifecycleRetrieveJobRequest
//
// @return RetryLifecycleRetrieveJobResponse
func (client *Client) RetryLifecycleRetrieveJob(request *RetryLifecycleRetrieveJobRequest) (_result *RetryLifecycleRetrieveJobResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.RetryLifecycleRetrieveJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a directory quota for a file system.
//
// Description:
//
// Only General-purpose File Storage NAS (NAS) file systems support the directory quota feature.
//
// @param request - SetDirQuotaRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return SetDirQuotaResponse
func (client *Client) SetDirQuotaWithOptions(request *SetDirQuotaRequest, runtime *dara.RuntimeOptions) (_result *SetDirQuotaResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.FileCountLimit) {
		query["FileCountLimit"] = request.FileCountLimit
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.Path) {
		query["Path"] = request.Path
	}

	if !dara.IsNil(request.QuotaType) {
		query["QuotaType"] = request.QuotaType
	}

	if !dara.IsNil(request.SizeLimit) {
		query["SizeLimit"] = request.SizeLimit
	}

	if !dara.IsNil(request.UserId) {
		query["UserId"] = request.UserId
	}

	if !dara.IsNil(request.UserType) {
		query["UserType"] = request.UserType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("SetDirQuota"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Creates a directory quota for a file system.
//
// Description:
//
// Only General-purpose File Storage NAS (NAS) file systems support the directory quota feature.
//
// @param request - SetDirQuotaRequest
//
// @return SetDirQuotaResponse
func (client *Client) SetDirQuota(request *SetDirQuotaRequest) (_result *SetDirQuotaResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.SetDirQuotaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Sets the quota for a fileset.
//
// Description:
//
//	  Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.7.0 and later support this operation.
//
//		- The minimum capacity quota of a fileset is 10 GiB, and the maximum capacity quota is 1,000 TiB. The scaling step size is 1 GiB. The capacity quota cannot exceed the total capacity of the file system.
//
//		- A fileset supports a minimum of 10,000 files or directories and a maximum of 10 billion files or directories. The scaling step size is 1.
//
//		- When you modify a directory quota, you must set the quota capacity or the file quantity to be greater than the capacity or file quantity that has been used.
//
//		- The quota statistics have a 5-minute latency. The actual usage takes effect after 5 minutes.
//
// @param request - SetFilesetQuotaRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return SetFilesetQuotaResponse
func (client *Client) SetFilesetQuotaWithOptions(request *SetFilesetQuotaRequest, runtime *dara.RuntimeOptions) (_result *SetFilesetQuotaResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.FileCountLimit) {
		query["FileCountLimit"] = request.FileCountLimit
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.FsetId) {
		query["FsetId"] = request.FsetId
	}

	if !dara.IsNil(request.SizeLimit) {
		query["SizeLimit"] = request.SizeLimit
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("SetFilesetQuota"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Sets the quota for a fileset.
//
// Description:
//
//	  Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.7.0 and later support this operation.
//
//		- The minimum capacity quota of a fileset is 10 GiB, and the maximum capacity quota is 1,000 TiB. The scaling step size is 1 GiB. The capacity quota cannot exceed the total capacity of the file system.
//
//		- A fileset supports a minimum of 10,000 files or directories and a maximum of 10 billion files or directories. The scaling step size is 1.
//
//		- When you modify a directory quota, you must set the quota capacity or the file quantity to be greater than the capacity or file quantity that has been used.
//
//		- The quota statistics have a 5-minute latency. The actual usage takes effect after 5 minutes.
//
// @param request - SetFilesetQuotaRequest
//
// @return SetFilesetQuotaResponse
func (client *Client) SetFilesetQuota(request *SetFilesetQuotaRequest) (_result *SetFilesetQuotaResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.SetFilesetQuotaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Enables a dataflow.
//
// Description:
//
//	  This operation is available only to Cloud Parallel File Storage (CPFS) file systems on the China site (aliyun.com).
//
//		- Only CPFS V2.2.0 and later support data flows. You can view the version information on the file system details page in the console.
//
//		- You can enable the data flows that are only in the `Stopped` state.
//
//		- If the value of DryRun is `true`, you can check whether sufficient resources are available to enable the specified data flow. If the resources are insufficient, the data flow cannot be enabled.
//
//		- It generally takes 2 to 5 minutes to enable a data flow. You can query the data flow status by calling the [DescribeDataFlows](https://help.aliyun.com/document_detail/2402270.html) operation.
//
// @param request - StartDataFlowRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return StartDataFlowResponse
func (client *Client) StartDataFlowWithOptions(request *StartDataFlowRequest, runtime *dara.RuntimeOptions) (_result *StartDataFlowResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DataFlowId) {
		query["DataFlowId"] = request.DataFlowId
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("StartDataFlow"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Enables a dataflow.
//
// Description:
//
//	  This operation is available only to Cloud Parallel File Storage (CPFS) file systems on the China site (aliyun.com).
//
//		- Only CPFS V2.2.0 and later support data flows. You can view the version information on the file system details page in the console.
//
//		- You can enable the data flows that are only in the `Stopped` state.
//
//		- If the value of DryRun is `true`, you can check whether sufficient resources are available to enable the specified data flow. If the resources are insufficient, the data flow cannot be enabled.
//
//		- It generally takes 2 to 5 minutes to enable a data flow. You can query the data flow status by calling the [DescribeDataFlows](https://help.aliyun.com/document_detail/2402270.html) operation.
//
// @param request - StartDataFlowRequest
//
// @return StartDataFlowResponse
func (client *Client) StartDataFlow(request *StartDataFlowRequest) (_result *StartDataFlowResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.StartDataFlowWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Disables a dataflow.
//
// Description:
//
//	  This operation is available only to Cloud Parallel File Storage (CPFS) file systems on the China site (aliyun.com).
//
//		- Only CPFS V2.2.0 and later support dataflows. You can view the version information on the file system details page in the console.
//
//		- You can disable only the dataflows that are in the `Running` state.
//
//		- After a dataflow is disabled, you cannot create a dataflow task for the dataflow. If AutoRefresh is configured, source data updates are not synchronized to CPFS.
//
//		- After a dataflow is disabled, the dataflow throughput is no longer billed because resources are reclaimed. However, the dataflow may fail to be restarted due to insufficient resources.
//
//		- It generally takes 2 to 5 minutes to disable a dataflow. You can call the [DescribeDataFlows](https://help.aliyun.com/document_detail/2402271.html) operation to query the dataflow status.
//
// @param request - StopDataFlowRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return StopDataFlowResponse
func (client *Client) StopDataFlowWithOptions(request *StopDataFlowRequest, runtime *dara.RuntimeOptions) (_result *StopDataFlowResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DataFlowId) {
		query["DataFlowId"] = request.DataFlowId
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("StopDataFlow"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Disables a dataflow.
//
// Description:
//
//	  This operation is available only to Cloud Parallel File Storage (CPFS) file systems on the China site (aliyun.com).
//
//		- Only CPFS V2.2.0 and later support dataflows. You can view the version information on the file system details page in the console.
//
//		- You can disable only the dataflows that are in the `Running` state.
//
//		- After a dataflow is disabled, you cannot create a dataflow task for the dataflow. If AutoRefresh is configured, source data updates are not synchronized to CPFS.
//
//		- After a dataflow is disabled, the dataflow throughput is no longer billed because resources are reclaimed. However, the dataflow may fail to be restarted due to insufficient resources.
//
//		- It generally takes 2 to 5 minutes to disable a dataflow. You can call the [DescribeDataFlows](https://help.aliyun.com/document_detail/2402271.html) operation to query the dataflow status.
//
// @param request - StopDataFlowRequest
//
// @return StopDataFlowResponse
func (client *Client) StopDataFlow(request *StopDataFlowRequest) (_result *StopDataFlowResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.StopDataFlowWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates tags and binds the tags to file systems.
//
// @param request - TagResourcesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return TagResourcesResponse
func (client *Client) TagResourcesWithOptions(request *TagResourcesRequest, runtime *dara.RuntimeOptions) (_result *TagResourcesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.ResourceId) {
		query["ResourceId"] = request.ResourceId
	}

	if !dara.IsNil(request.ResourceType) {
		query["ResourceType"] = request.ResourceType
	}

	if !dara.IsNil(request.Tag) {
		query["Tag"] = request.Tag
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("TagResources"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Creates tags and binds the tags to file systems.
//
// @param request - TagResourcesRequest
//
// @return TagResourcesResponse
func (client *Client) TagResources(request *TagResourcesRequest) (_result *TagResourcesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.TagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Removes tags from a file system.
//
// @param request - UntagResourcesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UntagResourcesResponse
func (client *Client) UntagResourcesWithOptions(request *UntagResourcesRequest, runtime *dara.RuntimeOptions) (_result *UntagResourcesResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.All) {
		query["All"] = request.All
	}

	if !dara.IsNil(request.ResourceId) {
		query["ResourceId"] = request.ResourceId
	}

	if !dara.IsNil(request.ResourceType) {
		query["ResourceType"] = request.ResourceType
	}

	if !dara.IsNil(request.TagKey) {
		query["TagKey"] = request.TagKey
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("UntagResources"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Removes tags from a file system.
//
// @param request - UntagResourcesRequest
//
// @return UntagResourcesResponse
func (client *Client) UntagResources(request *UntagResourcesRequest) (_result *UntagResourcesResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.UntagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the retention period of data in the recycle bin of a file system.
//
// Description:
//
// Only General-purpose NAS file systems support this operation.
//
// @param request - UpdateRecycleBinAttributeRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateRecycleBinAttributeResponse
func (client *Client) UpdateRecycleBinAttributeWithOptions(request *UpdateRecycleBinAttributeRequest, runtime *dara.RuntimeOptions) (_result *UpdateRecycleBinAttributeResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(dara.ToMap(request))
	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("UpdateRecycleBinAttribute"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("GET"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Modifies the retention period of data in the recycle bin of a file system.
//
// Description:
//
// Only General-purpose NAS file systems support this operation.
//
// @param request - UpdateRecycleBinAttributeRequest
//
// @return UpdateRecycleBinAttributeResponse
func (client *Client) UpdateRecycleBinAttribute(request *UpdateRecycleBinAttributeRequest) (_result *UpdateRecycleBinAttributeResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.UpdateRecycleBinAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Scales up an Extreme NAS file system or a Cloud Parallel File Storage (CPFS) file system.
//
// Description:
//
//	  Only Extreme NAS file systems and CPFS file systems can be scaled up. CPFS file systems are available only on the China site (aliyun.com).
//
//		- A General-purpose NAS file system is automatically scaled up. You do not need to call this operation to scale up a General-purpose NAS file system.
//
// @param request - UpgradeFileSystemRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpgradeFileSystemResponse
func (client *Client) UpgradeFileSystemWithOptions(request *UpgradeFileSystemRequest, runtime *dara.RuntimeOptions) (_result *UpgradeFileSystemResponse, _err error) {
	_err = request.Validate()
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !dara.IsNil(request.Capacity) {
		query["Capacity"] = request.Capacity
	}

	if !dara.IsNil(request.ClientToken) {
		query["ClientToken"] = request.ClientToken
	}

	if !dara.IsNil(request.DryRun) {
		query["DryRun"] = request.DryRun
	}

	if !dara.IsNil(request.FileSystemId) {
		query["FileSystemId"] = request.FileSystemId
	}

	if !dara.IsNil(request.FileSystemType) {
		query["FileSystemType"] = request.FileSystemType
	}

	req := &openapiutil.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapiutil.Params{
		Action:      dara.String("UpgradeFileSystem"),
		Version:     dara.String("2017-06-26"),
		Protocol:    dara.String("HTTPS"),
		Pathname:    dara.String("/"),
		Method:      dara.String("POST"),
		AuthType:    dara.String("AK"),
		Style:       dara.String("RPC"),
		ReqBodyType: dara.String("formData"),
		BodyType:    dara.String("json"),
	}
	if dara.IsNil(client.SignatureVersion) || dara.StringValue(client.SignatureVersion) != "v4" {
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	} else {
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = dara.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Scales up an Extreme NAS file system or a Cloud Parallel File Storage (CPFS) file system.
//
// Description:
//
//	  Only Extreme NAS file systems and CPFS file systems can be scaled up. CPFS file systems are available only on the China site (aliyun.com).
//
//		- A General-purpose NAS file system is automatically scaled up. You do not need to call this operation to scale up a General-purpose NAS file system.
//
// @param request - UpgradeFileSystemRequest
//
// @return UpgradeFileSystemResponse
func (client *Client) UpgradeFileSystem(request *UpgradeFileSystemRequest) (_result *UpgradeFileSystemResponse, _err error) {
	runtime := &dara.RuntimeOptions{}
	_body, _err := client.UpgradeFileSystemWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}
